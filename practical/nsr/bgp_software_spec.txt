$Header: /cvs/juniper/sw-projects/os/nsr/bgp_software_spec.txt,v 1.1 2005/10/18 23:28:35 roque Exp $

BGP non-stop routing (RLI 2711)

S3.02.P05.T01
{Add author(s) and contributor names and email addresses.}

Copyright (C) 2005, Juniper Networks, Inc.

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.


{IMPORTANT: As necessary, note if this document discusses a feature
which is export restricted or contains other limitations regarding who
can receive it or learn about it.}


1.  INTRODUCTION

Non-stop routing functionality is ment to provide transparent
switchover from master to backup RE, such that network peers are not
aware of the switchover event.

Furthermore, given that NSR is an HA solution that is intended to
replace the current routing HA functionality (graceful-restart), it
needs to overcome the problems that the current solution has in
operational environments.

These are, mainly:
 o Requirement on network peers to "aid" the restarting router, and
 the fact that different administrative entities are in control of
 this decision.
 o The ambiguity between control plane failures and link failures; a
 restart "helper" needs to assume control plane failure on loss of
 control plane keepalives.
 o The convergence delay introduced by graceful-restart during a restart
 event.

The first two issues are automatically addressed by the main premisse
of maintaining adjacencies / sessions during a switchover event. The
latter needs to be kept as a solution requirement.

Additionally, the performance impact of the solution is of critical
concern. Routing Engines in deployed systems are typically running
underpowered. The performance impact of NSR on the master RE has to be
kept to the absolute minimum in order for the solution to be feasible
in an operational context.

To complete the list of requirements, the system must be designed such
that a switchover may occur at any point regardless of the ammount of
routing information that is currently in-flight in the network. That
is, correctness is a requirement; while that may sound trivial
synchronization mecanisms often have "holes" that fail to meet this
requirement and which may go unrealized given the complexity of
testing this sort of scenarios.

Applying these top level requirements to BGP means:
 o Being able to maintain the TCP sessions after an RE switchover.
 o Running the master and backup RE as asynchronously as possible; the
 assumption being that synchronous operations (in which the master
 waites for an ACK for the backup) negatively impact performance.

1.1 The rational for TCP socket replication

Due to the incremental update nature of BGP, the correctness
requirement above also mandates that no messages (i.e. BGP
updates) can be lost in a switchover event.

Thus at the minimum, the master RE must not ACK a TCP segment that has
not been received by the secondary RE; and conversely it must not send
a TCP segment to the network peer if that segment is not sent to the
backup RE TCP stack. As the backup RE could be responsible for a
retransmission when the TCP segment loss coincident with a switchover.


			+--------------------+
			|		     |
			|  +--------------+  |
			|  | rpd          |  |
			|  |    3.{rib-in}|  |
			|  |              |  |
			|  | 2. [recvbuf] |  |
			|  +--------------+  |
			|        /\	     |
			|	 ||	     |
			|  +--------------+  |
			|  |  kern        |  |
			|  |1.[so recvbuf]|  |
			|  +--------------+  |
			+--------------------+

			      figure 1.

Consider figure 1 that represents the receive processing for received
protocol data on a TCP socket. Received TCP segments are acknowledged
when a segment is added in sequence to the socket receive buffer (1.).

That data is then buffered by the kernel until the unix process (rpd)
can read it. Given that this a stream, that data can further be stored
in rpd specific receive buffers so that the protocol in question can
reconstruct messages from the stream (2.).

Protocol messages will then be interpreted as add/change/delete
operations into a database.

Given that protocols cannot recover from loss of messages and that
transparency is a requirement we have to consider all possible
instances where protocol data can be buffered.

When choosing a point at which data can be replicated (1, 2, 3) we
have to consider that given that data can be lost before the
replication point, the TCP stream can only be ACKed post replication.

Thus we have the following possibilities:
- Replicate the rib-in database (3). This would imply withholding ACKs
  on the TCP stream until protocol messages are guaranteed to have been
  processed and replicated.

- Replicate the data delivered at the application (2). Withhold ACKs
  until the TCP socket is read. Since the pure raw data from the
  stream can easily be GiGs this would have to be combined w/ 3.

- Replicate the socket stream at point 1 and perform duplicate
  processing by the application.

The latter option is less complex in terms of tieing kernel and rpd
processing and is the one that will introduce the smallest ammount of
synchronization delay on master RE, as visible by a network peeer.

The same ration is applicable for outbound data sent from the master RE to
a network peer. The correctness requirement force us to to replicate
the outbound TCP segments, as explained above. This allows us to
reconstruct, on the secondary the stream of outbound messages that has
been sent from master RE to network peer. This "snooped" socket
information is suficient to replicate the BGP rib-out (i.e. knowledge
of what has been advertised to the network).

1.2 Top level design

2.  FUNCTIONALITY

CLI Config

This project add a new traceflag to BGP, which is currently hidden:

regress@pro6-d> show configuration protocols bgp
traceoptions {
    file bgp.log size 8m world-readable;
    flag policy;
    flag normal;
+   flag synchronization detail;
}

CLI

With the NSR project, rpd will be running on the backup RE, and all
BGP CLI commands are now enabled. These may display different values
than on the master RE. The critial information that rpd is replicating
are the contents of the BGP rib-in ("show route receive-protocol bgp")
and BGP rib-out ("show route advertising-protocol bgp").

3.  CAVEATS

{As necessary, describe any caveats, limitations and/or dependencies
of the above functionality. This includes calling out non-goals that
are specifically not supported for this feature}


4.  OTHER REQUIREMENTS

{As necessary, outline the general implementation requirements *not*
covered in the project requirements (RLIs, etc.) and call out any
specific additional requirements for protocols, edge cases, etc.  If
there is a significant amount of the latter then you should break this
section down in to subsections.}


[=== Everything from here down is internal (white box) documentation
and should not be documented or related to customers without a
specific need. (e.g. customer support workarounds for critical issues,
performance targets where the performance is the feature, etc.) ===]


5.  IMPLEMENTATION DETAILS

{As necessary, give a description of the internal implementation
details.}

a., b., c. {description of implementation of functional sub-areas}

{As necessary, describe the internal implementation details including
each of the following which are relevant to the functionality:

Goals (and non-goals}
Assumptions
Description of the implementation
    Description of whether the work is wholly new or extends existing work
    Components
    Data structures
    Algorithms
Rationale (for the design decisions made -- useful for the next person
	  who touches this code)
Internal APIs/Messages (and intent)
Constraints and limitations
Examples or interaction description
}


6.  PERFORMANCE

{As necessary, describe any performance issues or that there are
none.}

6.1.  Performance Related Resources

{As necessary, Describe the resource bottlenecks (e.g. CPU, RAM,
interface bandwidth, # of logical interfaces, etc.) of the function
and the general assumptions underlying any given performance
calculation. Also mention any changes from previous releases. This
includes any changes in microcode usage (Bchip. Lchip, Ichip, etc),
either positive or negative. Please see
<https://wintermute.juniper.net/junos/projects/microcode/> for more info.}

6.2.  Target Performance

{As necessary and appropriate, describe the target performance.  Where
possible, justify this target based on the resource estimates.
Specify if this target performance is based on believed maximum
performance of the function or based on a comfortably achievable
number.  Where relevant, specify where conditions will reduce the
performance below the target performance (e.g. extended functionality,
other load on the box, etc.).  It is also useful to return to this
section and fill in the actual tested performance when the numbers are
available.}


7.  COMPATIBILITY ISSUES

{As necessary, list any issues related to:
1. migration to/from this feature
2. any change of default system or software behavior
3. backwards/forwards compatibility: this would include any places
   old config will break, config will be deprecated, network layouts
   must change, the feature will or will not work with new or old
   hardware, etc.
}


8.  SECURITY ISSUES

{As necessary, list any security considerations or issues here.}


9.  Graceful RE Switchover (GRES), Hobson Impact

{Generally, when you are updating state in the kernel which is to be
consumed by other peers -- PFEs, LCCs --, you need to consider adding
support for GRES.  Some examples of these are:
- New ifstates
- Change in the routing socket message format for an existing message
- New daemons
- Updating kernel state in non-rtsock context
- State updates on the RE owing to messages from the PFE
- New IPCs to the PFE/FPCs
- New TLVs
- New rtsock messages
- New PICs
If you have questions, send email to replicant-coders.
}

10.  NOTES

{As necessary, add any additional notes which do not fit in the above
sections.}


11.  GLOSSARY

{As necessary, define any terms or acronyms used.}


12.  REVIEW COMMENTS

{We use the audit trail of the RLI tracking PR to record review comments,
so please include a pointer to the pr here. If the spec review is done
via email, the owner of the spec will send it out for comments with
"bugs@juniper.net" included on the To: or CC: line and the Subject:
containing "<catagory>/<tracking pr number>:", as shown below:

Subject: rli/12345: Code review for new frombitz feature

More info on valid Subject: line formats can be found at
http://www-in.juniper.net/useful_info/gnats-faq.html. All the reviewers
have to do is reply to the email with their review comments, making
sure "bugs@juniper.net" is in the To: or CC: and their comments will
be automagically archived to the pr. In the case of a meeting to
review the specs, the owner will add the review comments to the audit
trail of the tracking pr themselves. Review comments would include who
attended the meeting and the input provided by the reviewers.

When the owner updates the spec in cvs, they include the changes
made and the tracking pr number in the commit log, something like:

   pr: 12345
   Comments:

   Updates from spec review:

   - add description of ucode changes (jdoe)
   - remove the "annoy user" config command (bsmith)
}
