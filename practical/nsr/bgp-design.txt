		       BGP stateful replication

Functional specification

Pedro Marques

------------------------------------------------------------------------
1. Introduction
------------------------------------------------------------------------

The goal of BGP stateful replication functionality construct a copy of
contents of the BGP rib-in and rib-out, for each BGP peer, that are
consistent to what has been received and sent in the network to that
peer.

While rpd is running as secondary, the rib-out is being populated, not
by running BGP state machine on availiable information, but by
"snooping" TCP messages that are being sent by the primary rpd to the
network peer.

On a switch-over event, BGP state machine runs, based on existing
rib-in and system information and calculates the desirable state for
each rib-out entry. Any delta to the current state is then advertised
to the peer.

The replication procedure is asynchronous between primary and
secondary. Instead the secondary is synchronized with the routing data
that has been exchanged with the network peer(s).

It is possible to model BGP as a state machine that takes a given set
of inputs and generates outputs. The outputs are the loc-rib and
rib-out information advertised to peers, the inputs are the rib-in and
other information that BGP receives from the system (e.g. IGP
information, interface state).

The objective of NSR is to replicate in the secondary RE the
information that constitutes this inputs. Additionally, for protocols
such as BGP which use incremental messages, it is necessary to have
knowledge of each peers rib-out state.

------------------------------------------------------------------------
2. Primary
------------------------------------------------------------------------

The main task of the system is still to have the primary rpd talk to
network peers and establish routing state. Adding state replication
should be an extra service on top of this basic task and have the
least performance impact possible.

There are two tasks that the primary must be able to perform on behalf
of the secondary: inform the secondary of which sessions are
established, so that the secondary can request socket replication; act
as a server for initial bring-up synchronization.

2.1 Communication channel between primary and secondary.

Primary and secondary rpd will communicate via a TCP socket in the
internal routing instance (__juniper_private1__). It is the
responsability of the secondary to initiate this connection.

The BGP replication server code will create a new task an open a
listen socket for this purpose.

Primary and secondary should exchange BGPM_RSYNC_OPEN messages, when the
socket is open.

    BGPM_RSYNC_OPEN message (type 1)

    +-------+---------------+
    | type  | len (2 bytes) |
    +-------+---------------+
    | vers  |
    +-------+

    o API Version = 1 (1 octect)

    In case the format or state machine of replication messages has to
    change, API version works as a negotiation mecanism. API version
    selected is the minimum of the versions advertised by both peers.

2.2 Primary / secondary synchronization state machine

  State machine and messages used between primary and secondary to
  perform initial synchronization for a set of peers. This will be
  invoked when the secondary starts up. It may also be invoked when
  the secondary has unsychronized peers.

  A peer may be unsynchonized if and when the secondary receives a
  parameter it cannot interpret since non-BGP dependent state has not
  synchronized as expected. Example is an OPEN for an external peer
  that depends on an ifl that hasn't been communicated to the
  secondary RE.

	  primary				secondary
  --------------------------------	--------------------------------

				  <--	  1. Request(s)

    2. Estab (Open)		  -->

				  <--     3. Ack

    4. Start rsync job

       UPDATEs			  ==>

    5. Complete			  -->


Notes:

Event 2
________________
  Increment ack pending
  counter; start timer if not
  running; Allowed only
  when rsync_walk is not
  running;

Event 3
________________
  Schedule peer for rsync job.

Event 4
________________

  Triggered when count ack
  pending peers drops to 0;
  or timer expires.

2.3. New session establishment

If a secondary is present, in order to transition a BGP session into
established state, the primary must:
  a) set RECORD mode on socket
  b) inform the secondary about this session via an BGP_RSYNC_ESTABLISH
  message, via the IRS socket.
  c) wait for the respective acknowledgment
  d) transition peer state to ESTABLISHED

2.4. Messages

The secondary can use the request message to initate socket
replication for either all established peers or a particular set of
peers.

    BGPM_RSYNC_REQUEST message (type 3)

    +-------+---------------+
    | type  | len (2 bytes) |
    +-------+---------------+
    | neighbor list ...
    +-----------------------+

    o If the neighbor list is empty, this message is interpreted as a
    request for synchronization of all peers.

    o Otherwise, this is interpreted as a request for synchronization
    for the particular set of neighbors, encoded as:

    {instance-id (2 octects), AF (1 byte), len (1 byte), neighbor
    address ... }

    If a synchronization request is received for a non-established
    peer, the primary should respond with an error.

    Only one synchronization job may be running at a time. If the
    primary receives a subsequent request while a job is runnig it
    will respond with an error. It is the job of the secondary to
    enqueue future synchronization requests.

When the primary receives a SYNC_REQUEST for an established peer (or all
peers), it should generate the respective establish
messages. Additionally it should keep track of the peers for which it
is waiting for an acknowledgement. It should also start a timer so
that it times out waiting for ACKs from the secondary.

Must be able to send ESTABLISH messages while the synchronization
process is in progress.

    BGPM_RSYNC_ESTABLISH message (type 4)

    +-------+---------------+-------+
    | type  | len (2 bytes) | flags |
    +-------+-------+-------+-------+---------------+
    | instance id   | local address | remote addr   |
    +---------------+---------------+---------------+
    | OPEN msglen   | OPEN ...
    +---------------+--------------- ...
    | TVL encoded private info
    +---------------+--------------- ...

    o flags (1 byte)
        LSB	unsolicited (if set).

    o instance id (2 bytes)

	Instance in which the peer is configured. i.e. master instance
	for inet.0 or vpn neighbors; VRF instance for PE-CE sessions.

    o local and remote addresses

	encoded as {AF, len (1 byte), address}

    o OPEN

	Encoded as defined for the BGP OPEN message. This should
	reflect information advertised by the network peer. Allows the
	secondary to learn infomation such as: router-id, receive nlri
	mask, etc.

    o Private replication information

	The following information is required by the secondary, and is
	encoded as a TLV (type = 1 byte, len = 2 bytes).
	
	The following TLVs are defined

	Type			len
	1	snmp_index	4	network format index
	2	asn_local	2	local as

When the socket between primary and secondary is closed, primary will
disable the replication state on sockets.

    BGPM_RSYNC_ACK message (type 5)

    +-------+---------------+-------+
    | type  | len (2 bytes) | flags |
    +-------+-------+-------+-------+
    | instance id   |   peer addr   |
    +---------------+--------------- ...
    | TVL encoded private info
    +---------------+--------------- ...

    o flags (1 byte)
        LSB	unsolicited (if set).

    o instance id (2 bytes)

	Instance in which the peer is configured. i.e. master instance
	for inet.0 or vpn neighbors; VRF instance for PE-CE sessions.

    o peer addresses

	encoded as {AF, len (1 byte), address}

    BGPM_RSYNC_ERROR message (type 2)

    +-------+---------------+
    | type  | len (2 bytes) |
    +---------------+
    |   code        |
    +	....
    |   variable lenght data
    +	....


    Codes

      1 BGPS_ERR_NOT_ESTABLISHED
	data: address of neighbor from sync_request

      2 BGPS_ERR_IN_PROGRESS
        data: NULL

	Sync job is already in progress.


2.5 Established state synchronization

State synchronization requires examining all the received and
advertised paths in the ribs that affect a given peer.

Design goals:
  - Reduce the number of iterations through the routing tables on
  initial synchronization.
  - Reduce the number of messages exchanged between primary and
  secondary.

This is acomplished by grouping information, as BGP does with
updates. In this case information is grouped by {neighbor list,
bgp_metrics, nlri}.

Code is organized as:
a) Producer job that iterates through the routing tables enqueuing
update entries.
b) Consumer job (scheduled when IRS socket becomes availiable for
writing). This job dequeues entries and formats messages.

The queue should be limited in terms of the number of entries that it
may have.

/*
 * BGP neighbor list
 */
typedef struct {
    hbt_node_t	bnl_hnode;
    u_int	bnl_group;		/* group index */
    bgpb_sbits	*bnl_mask;		/* neighbor mask */
} bgp_nlist_entry_t;

typedef struct {
    hbt_node_t	bnl_hnode;		/* canonicalized entry */
    u_int	bnl_refcount;		/* number of references */
    hbt_node_t	*bnl_entries;		/* (gid, sbits) list */
} bgp_nlist_t;

/*
 * Replication queue entries.
 */
typedef struct {
    hbt_node_t		rsq_qnode;	/* sorted by <nlist, metrics, rt_entry>
    hbt_node_t		rsq_mnode;	/* sorted by <metrics, rt_entry>
    bgp_nlist_t		*rsq_nlist;	/* neighbor list */
    bgp_metrics		*rsq_metrics;	/* bgp_metrics */
    rt_entry_handle	rsq_rtentry;	/* entry to advertise */
} bgp_rsync_entry_t;

/*
 * Per (instance, af, safi) table
 */
typedef struct {
    hbt_node_t		rsy_hnode;
    u_int		rsy_instance;	/* instance-id */
    u_char		rsy_af;
    u_short		rsy_safi;

    hbt_node_t		*rsy_in;	/* rib-in update queue */
    hbt_node_t		*rsy_out;	/* rib-out update queue */

    hbt_node_t		*rsy_mets_in;	/* rib-in metrics queue */
    hbt_node_t		*rsy_mets_out;	/* rib-out metrics queue */

} bgp_rsync_db_t;

    When enqueuing an entry:
    a) search in metric db for <metric, rt_entry>
    b) if found, add neighbor to nlist.
    c) otherwise, create new entry in metric db and update queue.

Given that queue entries hold pointers to rt_entries, these rt_entries
must be referenced via an rt_bit. The bgp sync server task should
allocate an rtbit per table, when performing synchronization.

    BGPM_RSYNC_UPDATE message (type 6, 7)

    +-------+---------------+
    | type  | len (2 bytes) |
    +-------+---------------+
    |  instance id  |
    +---------------+
    | neigbor list ...
    +----------------------- ...
    | BGP path attributes ...
    +----------------------- ...
    | NLRI
    +----------------------- ...

    o Type

	rib-in (6), rib-out (7)

    o Neighbor list

	length (in bytes) (2 octects)

	variable lenght list of:
	   <af (1-byte), len (1 byte), address (variable)>

    o Data

	A sequence of entries in the form.
	<update length, bgp path attributes, nlri>

	+----------------+----------------
	| update len     | update (BGP attributes + NLRI) ...
	+----------------+----------------
	           ...         ...
	+----------------+----------------
	| update len     | update (BGP attributes + NLRI) ...
	+----------------+----------------

    The usage of this format for initial synchronization messages
    should allow the secondary code to process these updates using the
    same code that processes data from the snooped sockets.


    Maximum UPDATE message size	- 32k.

    BGPM_SYNC_COMPLETE message (type 8)

    +-------+---------------+
    | type  | len (2 bytes) |
    +-------+---------------+

    All synchronization job has completed.

2.4 Sychronization server

    - bgp_rsync_init ()

	o Create rsync task
	o listen on IRS socket used to communicate with secondary

    - bgp_rsync_walker ()

	o Create a queue entry. If another entry with the same metrics
	and NLRI is already present, the neighbor list is merged.

	o When advertising rib-out entries, if there are any infop
	entries these are enqueued first. Remaining sbits peers are
	considering to have same info as advertisement entry.

	o rib-out VRF entries are advertised by the exporting
	family. i.e.  vpn-a route is advertised with RD, etc in
	safi 128.

    - bgp_rsync_job ()

	o Synchronization job

------------------------------------------------------------------------
3. Secondary
------------------------------------------------------------------------

3.1 Peer and Peergroup data structure.

bgpPeer

Replicate				| Setup
----------------------------------------+------------------------------------
o snmp_index				| o gateway
o asn local				| o cur_prefixes
o router-id				| o sync
o local address				| o config 
o holdtime
o nlri (received from peer)
o nlri_refresh

3.2 Config parsing and initialization

o One cannot assume that a peer is member of same group in secondary
and primary. This can be because of sw changes or because we did break
a member out of a group and not merged it back...

task vector
  - cleanup
  - init
  - reinit
  - ifchange
  - terminate

o bgp_secondary_init()

  peer initialization
    bgp_peer_init calls connect start. This function should work
    differently on secondary.
    need to initialize <task, gateway>.

  auto-export: executes normally on the secondary.

  o cluster list information required for rib-in processing.

  rtarget: flash processing builds the data-base that is used to
  filter outgoing advertisements. This information is only necessary
  after a switch-over. However it should exist prior to processing VPN
  route advertisements.

  Option

  Yes		More code running on the secondary, building state
		that is not absolutly necessary.

  No		Order based dependency on switch-over.
  

  Import policy change should still cause reinit, given that we are
  installing rt_entries in the table.

  Main differences:
    - bgp_listen_init
    - bgp_peer_init

  Option a) Restructure initialization code.
	- common_init
	- primary_init
	- secondary_init


o bgp_reinit_all ()

  Can it be reused unmodified (?)

3.3 Socket replication

If the secondary receives a rib-out entry and it has no rt_entry it
has to create a fake one to hook the rib-out entry to... because of
async between primary BGP messages and interface up down via kernel.

- rib-out update procedure

  rib_out is organized as:

  rt_head tsi -> bgp_adv_entry (per group)
		 o desired metrics
	         o list of bgpg_rtinfo_entry
		   - bitmask
		   - advertised metrics

  rtinfo entries are not present if advertised metrics are equal to
  desired metrics.

  Proposal:
       Keep a list of infop entries, advertisement entry has no
       contents. Delete will reset bits from rtinfo.
       Thus another reason for advertisement entry to have NULL
       metrics.

       This means that infop entries must have bgpaf_metrics
       information.

  code organization:

  o rcv_nlri / rcv_unreach should be used unmodified for rib-in.

  o bgp_rtsec_ribout_rcv ()

	o arguments: group, peer, advertisement

	- find rib that is being advertised.
	    for vpn address families:
	    a) if bgp_adv_main is set, this is the master table.
	    b) otherwise find instance by advertised RD.

	  [ dependency between received advertisement and processing
	    of config ]
	    
	- find rt_head
	    if it doesn't exist create dummy rt_entry with low
	    preference.

	- find tsi

	- find rtinfo for neighbor and update entry.

3.4 Label allocation

BGP allocates labels for vpn and labeled-unicast advertisemets.
This means adding state to the internal db "bgp_out_label_tree" as
well as adding a route to mpls.0.

By snooping the outgoing route advertisements, it is possible to
determine the outgoing label to NLRI association.

The primary executes a decision that is:

    rt_entry		-> allocate label -> advertise nlri.
       rt_nexthop

Secondary will keep track of the out_labels advertised by the primary,
in a separate data-structure, and create an mpls.0 rt_entry for that
label, which has a Ficticious next-hop { next-hop should mean "krt tsi
information is valid" }.

At switch-over time the output metrics allocation function will use
the previous value of the advertised label as an "hint" as to the
label to allocate.

It can consult the krt tsi next-hop information and verify that the
label value is compatible with the next-hop that it is using as the
out_label key.

3.5 Initial synchronization

While a peer is not in sync, a snooped delete must create a fake
poison entry. We use a special bgp_metrics handle for this purpose.
When synchronization completes, all entries that point to this metric
must be removed.

This can be done via:
a) Full walk through all tables, all rt_entries and all bgp_tsi.
b) Keeping dependency information of which bgp_rtentry structures and
infop structures currently point to this null metrics structure.

Information received from the primary cannot override information
received from snooping the socket, as the latter is more recent by
definition. Thus information from primary is dropped if there is
already and entry created by the snooping procedure.

3.6 Transition to established state

In the primary this is the stage at which bgprib_{peer,peergroup,state}_t
entries are created.

    code path on primary:
	bgp_rt_send_init
	  bgp_rt_group_peer_init
	    - allocates per rib structures
            - set flash vector; allocate rtbit
        - sets sbits
	- starts init/join job

On secondary:
	sbits		should be set on establishment
	jbits		should be set when synchronization finishes
	sync		- unset -

	init_state	BGP_INIT_NONE -> BGP_INIT_COMPLETE
			(when sync is done)

    current call graph:

    bgp_rt_group_peer_init ()
	- bgp_rt_group_rib_init ()
	    - bgp_rib_alloc ()		- must not be called.

    bgp_secondary_establish

3.7 Socket close processing

Need to clear rib_in and rtinfo entries for sockets being closed.

Possibility to reuse the existing cleanup functions with a different
state machine.


------------------------------------------------------------------------
4. Switch-over procedure
------------------------------------------------------------------------

4.1 Indirect next-hop indexes

Indirect nexthop information needs to have protocol next-hop;


------------------------------------------------------------------------
5. Verification
------------------------------------------------------------------------

5.1 Script that compares existing state.