Id: l2ckt-vpls-design.txt,v 1.1 2007/06/03 03:47:43 wlin Exp $

S3.02.P05.T01

	NSR for L2CKT / LDP-VPLS Design Specification

	    Wen Lin (wlin@juniper.net)

Copyright (C) 2007, Juniper Networks, Inc.

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.


1. Introduction

This document contains design detail for NSR support for L2CKT and LDP-VPLS
within RPD. For the over all goal and requirement, please refer to its
corresponding functional specification "NSR for L2CKT / LDP-VPLS Functional 
Specification". Please note, in this document, the L2CKT component refers to the 
code implemented in the L2VPN directory for both L2CKT and LDP-VPLS 
functionalities and it is used to distinguish code implemented in LDP directory 
for L2CKT and LDP-VPLS.

1.1 Related RLIs and PRs:

RLI 2724 - NSR: L2 Circuit stateful replication
RLI 5131 - NSR: LDP-VPLS stateful replication
PR 103293 - Tracking PR for RLI 2724
PR 103294 - Tracking PR for RLI 5131


2. Design Overview

As it is specified in the functional spec, in order to support NSR for 
L2CKT/LDP-VPLS, we have to replicate the following information on the standby 
RE:

- Label advertised to the neighbor on the remote PE by the master RE. Unlike 
graceful restart, the same label will be retained for both L2CKT and 
LDP-VPLS after a successful switch-over.

-  The IFL of the dynamic VT or LSI interface for LDP-VPLS.

The standby RE also needs to learn the label advertised by the remote neighbor.  

As for now, there is no need to use mirror storage or JSR or internal socket
to replicate information from the master RE to the standby RE for L2CKT/LDP-VPLS.
Because of the support of LDP NSR, the L2CKT component can recover both the 
incoming and out-going labels from the label bindings of LDP on the standby RE and
for IFL, the information is already replicated by the kernel and KRT passes this 
information to the L2CKT component. We will discuss each in the next couple of 
sessions in detail.


2. Label Recovery on Standby RE

2.1 Label advertised by the remote neighbor

A Neighbor advertises the label to the master RE in a LDP label mapping message.
The LDP on the standby RE snoops on the incoming label mapping message and a 
corresponding inlib label binding is replicated on the Standby RE.  The LDP on the
standby RE adds a remote route for L2CKT in the l2circuit.0 table. 

The standby RE registers for the route flash for l2circuit.0 table during the 
init process. Once the route is added by LDP on the standby RE, it gets flashed 
to the L2CKT component. The L2CKT/VPLS process the L2KCT route added by 
the LDP on the standby RE and gets the out label from the neighbor the same way 
it does as it is on the master RE. 

When the neighbor withdraws the label, the LDP on the standby RE deletes the 
remote route for L2CKT in the l2circuit.0.  When the route flashes to the L2CKT 
component, the L2CKT/VPLS deletes the out label for the pseudo wires.

To summarize, for recovering the out label advertised by the remote neighbor on 
the standby RE, as far as both LDP and L2CKT/LDP-VPLS concern, there is no change 
to that part of process: the LDP on the standby RE works as the way it does today
and for the L2CKT component, the standby RE behaves the same as the master RE.


2.1 Label advertised to the remote neighbor

2.1.1 Before the Switch-over

On the master RE:

A label is allocated for the pseudo wire by the L2CKT component. The local LDP
sends a label mapping message to the neighbor once the targeted session to the 
neighbor is established. When the label is deallocated by the L2CKT component, 
it causes the LDP to send a label withdraw message to the remote neighbor.


On the standby RE:

Whenever the LDP snoops the out going label mapping or label withdraw message for
the L2CKT, it creates or withdraws a corresponding outlib label binding for the 
L2CKT. The L2CKT component relies on LDP's outlib label binding to restore the 
label advised to the remote neighbor. The L2CKT component provides callback 
functions for LDP to trigger the creation or deletion of the label repository 
whenever a new outlib label binding for the L2CKT is created or an existing L2CKT 
outlib label binding is withdrawn in the LDP. The label repository is used to 
store the label for the pseudo wire which is recovered from the LDP outlib label 
binding. The same scheme is used for both L2CKT and LDP-VPLS with either a VT or 
LSI interface.

The LDP withdraws the outlib label binding for a L2CKT when:
 - It snoops a label withdraw message send out by the master RE. 
 - When the session to the remote neighbor goes down and the binding itself
   is still in ACTIVE state.
 - Release a previous active binding for the same L2CKT prefix when it snoops 
   a different label mapping for the same L2CKT prefix since the LDP never sends 
   more than one active label for the same prefix.


As far as the LDP is concerned, it only needs to invokes callback functions 
provided by the L2CKT directly and there is no job or timer evolved.  On the other
hand at L2CKT side, we restrict the callback functions to do as less work as 
possible - i.e. it is only used to create or delete the corresponding label 
repository and all the remaining work for the L2CKT component will be scheduled to
be processed in the l2ckt_intf_change_process() through l2ckt_intf_change_timer_start().


The label repository created in the L2CKT component is stored in a patricia tree 
and it is keyed by <nbr_id, vc_id> which is used to uniquely identify a 
l2ckt_intf through the neighbor interface tree for L2CKT/LDP-VPLS maintained by 
the global l2ckt_global_t structure. There is no instance information needed here:
the instance concept in L2CKT component is used to better match the configuration.
As VPLS is configured under the instance. LDP itself is not aware of the VPLS 
instance so is the l2circuit.0 table that is shared by all VPLS instance.

The L2CKT component on the standby RE never allocates the label by itself without
first finding a matching label in the label repository. Whenever an in label is 
needed for the pseudo wire interface, it first do a label lookup in the label 
repository based on the nbr_id and vc_id. If a match is found, it resurrects
the label and marks the entry in the repository as 'IN USE'. Otherwise it delays 
the process until the l2ckt_intf_change_process() is triggered and then the same
process is repeated to look for the matching label.


The pseudo code for triggering the creation or deletion of L2CKT/VPLS label
repository is as follows:

/*
 * When a new outlib label binding is created for L2CKT
 */

ldp_standby_new_outlib_binding( ... ) /* LDP */
   if (outlib binding type if for LDP_PFX_L2CKT)				
       l2ckt_repo_ldp_label_add()  /* callback provided by L2CKT component */


/* 
 * When a existing outlib label binding for L2CKT is withdrawn
 */

ldp_standby_outlib_binding_withdraw(...) /* LDP */
   if (outlib binding type if for LDP_PFX_L2CKT)
      l2ckt_repo_ldp_label_delete(...)  /* callback provided by L2CKT component */


When a new outlib label binding is created for the L2CKT, there is no L2CKT route 
associated with this outlib label binding because there is no local L2CKT route 
in the l2circuit.0 on the standby RE to associated with at this point. However 
such a association is crucial for LDP to keep the outlib label binding for the 
L2CKT and not send a label withdraw message during the switch-over. The 
association of the outlib label binding for the L2CKT with a L2CKT route is done 
later when the L2CKT local route in the l2circuit.0 table is added by L2CKT 
component and gets flashed to the standby LDP.  Whenever the L2CKT on the standby 
RE resurrects the label from the label repository, it adds the local route to the 
l2circuit.0 table the same way it does as it is a master RE.  The standby LDP 
registers for route flash for routes in the l2circuit.0 table. When the L2CKT 
local route gets flashed to the LDP, this will be the time for the LDP to 
associate the outlib label binding with the L2CKT local route.  Similarly, if the
local route is deleted from the l2circuit.0 table, the LDP disassociates the 
routes from the outlib label binding but it does not delete the outlib label 
binding. The decision as to whether an outlib lable binding for L2CKT should be 
deleted is deferred until the switch-over period unless the LDP on the standby RE 
snoops the label withdraw message for this outlib label binding or the session to 
the remote neighbor is closed.


2.1.2 During the Switch-over

When switch-over occurs, there is a switch-over period for LDP that was the
standby RE. During that period, the LDP evaluates all outlib label bindings. 
Outlib label that is in ACITVE state and does not have an associated route is 
getting added to the outlib expiration queue and it will be deleted later.
Besides that, a label withdraw message is enqueued that will be sent out to the 
remote neighbor.

For the L2CKT component, the new primary RE deletes all the label repository 
entries that is marked 'IN USE'. For the entries that is not 'IN USE' it will be
deleted in 60 seconds.  Upon the deletion, the label stored in the entry is also 
deallocated if the entry is not 'IN USE'.


2.1.3 Race Condition during the Switch-over:

It is only meaningful to consider the case where L2CKT/VPLS on the master RE 
already allocated label for the pseudo wire. We assume a switch-over occurs right
after the following couple of cases:

1) The L2CKT/VPLS on primary RE has not installed a local route in the l2circuit.0
table and a switch-over occurs.
    
Expected behavior: Before the switch-over, the LDP on the master RE has no 
knowledge of label allocated by the L2CKT component, hence there is no work need 
to be done by the LDP. After the switch-over the L2CKT component on new primary RE
allocates a new label for the pseudo wire. Since the traffic has not start to
to flow between the two neighbors before the switch-over, so there is no packet
loss involved.


2) On Primary RE, the L2CKT/VPLS installed the local route to the l2circuit.0. 
However route has not flashed to the LDP.

Expected behavior: It is expected to behave the same as the case 1).


3) On the Primary RE, the LDP sent out the label mapping message to the neighbor, 
but the standby has not built outlib label binding for the L2CKT.

Expected behavior: Since there is no label binding for L2CKT in the LDP on the 
standby RE, no corresponding label repository is created on the L2CKT side. Also
no label withdraw message will be sent out by the LDP. For the new primary RE,
the L2CKT component allocates a new label for the pseudo wire interface. A label
mapping message with a different label but the same FEC will be sent out to the 
neighbor. If the traffic already started to flow between the two neighbors before 
the switch-over, then there is a packet loss before the VPLS connection is up 
again and neighbor starts to use the new label.


4) On the Primary RE, the LDP sent out the label mapping message to the neighbor.
On the standby RE, the LDP built an outlib label binding for the L2CKT and a 
switch-over occurs before the L2CKT builds the label repository.

Expected behavior: Since there is no route associated with the outlib label 
binding for the L2CKT, during the switch-over period, this outLib label binding 
is added in the expiration queue that is expected to be deleted later and LDP
also enqueues a label withdraw message.  Since there is no corresponding label 
repository on the L2CKT side, the new master allocates a new label and adds a 
local route to the l2circuit.0 table. If the local route added by the L2CKT is 
flashed to the LDP within the LDP switch-over period, it is possible that the 
previously enqueued label withdraw message has not been sent out yet.  If the 
L2CKT happens to allocate the same label, we should avoid the case where the LDP
sends out the label withdraw message after the label mapping message for the same 
label/FEC. It is believed that the current LDP code already takes care it - LDP 
cancels the label withdraw message in this case. 

Most likely there is a short period of packet loss before the L2CKT/VPLS connection
is up on the new master RE.


5) On the standby RE, the LDP built an outLib label binding for the L2CKT and 
also the corresponding label repository is built on the L2CKT side. However, 
a switch-over occurs before the LDP can associate the route to the outLib label 
binding.

Expected behavior: On the LDP side, the situation is exactly as it is described 
in case 4). On the L2CKT side, the label repository that are not 'IN USE' is not
getting deleted at least 60 seconds after the RE switch-over.  If the  L2CKT is
able to resurrect the label within that window or L2CKT already resurrected the 
label before the switch-over, then there will be no or minimum traffic loss. 
On the other hand, if the L2CKT fails to resurrect the label, then a new label 
will be allocated. This will be the same as case 4).


3. IFL Recovery on Standby RE

The standby RE relies on the kernel to replicate all the IFL information. This 
includes IFL for the dynamic interface of VT or LSI created for LDP-VPLS.

For LDP-VPLS, the IFL repository is used to store information recovered from the
kernel on the standby RE. The same IFL repository is used for both NSR and 
graceful restart purpose.  However for NSR, the label is not allocated at the
creation of an IFL repository since for NSR the label is recovered from the LDP. 
The IFL repository is keyed on the <nbr_id, vc_id>.

On the standby RE, the creation of IFL repository for VT or LSI interface is 
triggered by KRT through VPLS IFF change (vpls_iffchange()). The allocation of the
subunit for the IFL is done at the creation of the IFL repository. The deletion of
IFL repository is triggered through either vc_iflchange() on IFC_DELETE or 
vc_ifdchange(). The creation or deletion of the IFL repository should trigger the 
L2CKT to re-evaluate the VPLS interface.

On standby RE, the LDP-VPLS never allocate a new subunit for the VT or LSI 
interface by itself - It always tries to find a matching IFL based on 
<nbr_id, vc_id> in the IFL repository. If a match is found, it marks the entry as 
'IN USE' and the corresponding IFL is resurrected. Otherwise, it fails the 
creation of the VT or LSI interface.

When switch-over occurs, all IFL repository entries which is 'IN USE' are getting
deleted. Entries not 'IN USE' are getting deleted 60 seconds later. 

When deleting a IFL repository entry that is not 'IN USE', first its corresponding
subunits is deallocated, and if the deletion happens upon the switch-over, then a
message is sent to kernel to delete the IFL.


3.1 Label Mismatch

Now for LDP VPLS, for a specified neighbor and vc id, the same in-coming label
is stored in both the label repository created based on the LDP and IFL 
repository created based on the iff change message from the kernel. 

Because of the race condition there could be a mismatch between the label stored
in the label repository and label associated with an IFL repository for the same 
set of neighbor and vc id.  The mismatch could be caused by the LDP on the 
standby RE lagged behind in processing the label mapping and withdraw messages 
that it snooped from the master RE.  Meanwhile, the kernel already replicated the 
information to the standby RE which leaded to L2CKT component creating a new IFL 
repository entry with a different VT or LSI interface and different in-coming 
label.

Say for a specified neighbor and vc id, on the master RE, it already updated a 
VPLS interface and its in-coming label from VT1, L1 to VT2, L2. As a result of 
that, the kernel received an "iff delete" for VT1 with label L1 and then an 
"iff add" for VT2 with label L2. Because before the switch-over, the kernel 
successfully replicated these information to the standby RE, so the L2CKT component
on the standby RE deleted the IFL repository entry with VT1, L1 and also created
a new IFL repository entry with VT2, L2 for the same set of neighbor and vc id. 
However, because the LDP on the standby RE lagged behind in processing the label 
withdraw message (for label L1) and label mapping message (for label L2), as a 
result, the L2CKT component on the standby RE still had a label repository with 
label L1 for the same set of neighbor and vc id before the switch-over.  Now
the switch-over occurs and we have a mismatch of label between labels stored in 
the label repository and label associated with an IFL repository for the same 
set of neighbor and vc id.  In this case, the L2CKT component should not resurrect 
the label in the label repository. Otherwise, the new master RE would establish 
a PW connection with the remote neighbor with a VT2 interface and a corresponding 
label L1 and causes problem later on for the graceful restart. This is because for 
graceful restart, the label is always recovered from the kernel and in the kernel, 
the VT2 is associated with L2.


3.2 Support for Mesh-group

When the RLI 4523, LDP-BGP VPLS inter-working, is implemented in 9.0, together
with the IFL info replicated by the kernel, there will also be a mesh-group ID.
When an IFL repository is created, we will store the mesh-group ID in the IFL
repository entry. On the standby RE, by the time when the L2CKT component comes to 
resurrect the subunit for the IFL, it finds a matching IFL repository. The 
L2CKT component checks whether the mesh-group stored in the corresponding IFL
repository entry matches what it is configured. If there is a mismatch, the 
VT or LSI interface will not be created.


3.3 Other Race Conditions

If the IFL repository creation is missed because of the switch-over, the new 
primary RE will allocate a new subunit by the time it parses the configuration and
starts to create VPLS interface.

If the IFL repository deletion is missed because of the switch-over, the clean up
of IFL repository entry upon the switch-over deallocates the subunit for the IFL 
and sends IFL deletion message to the kernel for the entry that is not 'IN USE'. 
The IFL repository entry itself is also getting deleted. 

If kernel fails to replicate a IFL for VT or LSI interface or failed to pass 
the information to the L2CKT component, then the creation of the VPLS interface on
the standby RE is not going to happen until the standby RE becomes the master.



4. Interface Notification

4.1 vc_ifachange()

This is called for all l2ckt_intf which includes ce-facing interface for L2CKT or
local ce-facing interface and vc interface (VT/LSI) for LDP-VPLS or key and end 
interfaces for LSW.  It is used to catch interface status changes (UP/DOWN/DELETING) and AF changes.

Standby RE 'registers' for vc_ifachange() and there will be no change introduced 
for standby RE.


4.2 vc_iflchange()

This is called for all l2ckt_intf which includes ce-facing interface for L2CKT or
local ce-facing interface and vc interface (VT/LSI) for LDP-VPLS or key and end 
interfaces for LSW. It is used to catch changes in encapsulation, MTU, CW, VLAN 
ID support and IFC_DELETE (Interface is marked for deletion).

The standby RE 'registers' for vc_iflchange() and deletes the corresponding IFL 
repository for VT/LSI interface on IFC_DELETE. Otherwise, it behaves the same as 
the master RE.


4.3 vc_ifdchange()

We are only interested for VT/LSI interface. To deal with changes in the VT/LSI
for IFC_DELETE, IFC_ADD, IFC_UPDOWN.

Standby RE 'registers' for vc_ifdchange() and if VT interface flaps, it deletes 
all the IFL repository entries for the related VT interface. Otherwise it behaves 
the same as the master RE.


4.4 vpls_iffchange()

This is used for extracting IFL info replicated in the kernel for VT/LSI interface
through from the KRT and builds the corresponding IFL repository.



5. L2circuit.0 Route

There is no difference for invoking the addition / deletion of a local route 
to the l2circuit.0 table between a primary and standby RE for L2CKT/LDP-VPLS.


6. Pseudo Wire Route

There is no difference for invoking the addition / deletion of pseudo wire routes 
to the mpls.0 table between a primary and standby RE for L2CKT/LDP-VPLS.


7. Function Vector

In order to have minimum impact on the existing code and share as much code as 
possible between the master RE and standby RE, a function vector is used and it is
initialized differently at init time based on the master or standby RE. This is 
similiar to what has been implemented for the NSR of L2VPN/BGP-VPLS.

static struct l2ckt_mastership_vec l2ckt_primary_vec = {
    .m_vpls_dyn_ifl_add = l2ckt_vpls_primary_dyn_ifl_add,
    .m_vpls_dyn_ifl_change_trigger = NULL,
    .m_vpls_dyn_ifl_delete = l2ckt_vpls_primary_dyn_ifl_delete,
    .m_vpls_repo_ifl_delete_all = l2ckt_vpls_primary_repo_ifl_delete_all,
    .m_vpls_process_iff_change = vpls_process_iff_change,
    .m_vpls_process_ifl_delete = NULL,
    .m_vpls_repo_ifl_delete_all_vt = l2ckt_vpls_primary_repo_ifl_delete_all_vt,
    .m_label_alloc = l2ckt_primary_assign_label,
    .m_label_free = l2ckt_site_primary_label_free
};

static struct l2ckt_mastership_vec l2ckt_standby_vec = {
    .m_vpls_dyn_ifl_add = l2ckt_vpls_standby_dyn_ifl_add,
    .m_vpls_dyn_ifl_change_trigger = l2ckt_vpls_standby_dyn_ifl_change_trigger,
    .m_vpls_dyn_ifl_delete = NULL,
    .m_vpls_repo_ifl_delete_all = l2ckt_vpls_standby_repo_ifl_delete_all,
    .m_vpls_process_iff_change = vpls_process_iff_change,
    .m_vpls_process_ifl_delete = l2ckt_vpls_standby_process_ifl_delete,
    .m_vpls_repo_ifl_delete_all_vt = l2ckt_vpls_standby_repo_ifl_delete_all_vt,
    .m_label_alloc = l2ckt_standby_assign_label,
    .m_label_free = l2ckt_site_standby_label_free
};



.m_vpls_dyn_ifl_add
-------------------------------------------------------------------
   Master:
     - If there is matching IFL repositry, set IN USE flag (in GR state)
     - write to the kernel thru iff, ifl messages

   Standby:
     - try to resurrect IFL: find matching IFL repository, set 'IN USE' flag


.m_vpls_dyn_ifl_change_trigger
-------------------------------------------------------------------
   Master:
     - Nothing
	
   Standby:
     - triggered by vpls_iffchange()
     - evoke l2ckt_intf_change_process()


.m_vpls_dyn_ifl_delete
-------------------------------------------------------------------
   Master:
     - triggered by vpls intf delete
     - free subunit
     - send delete IFL message to the kernel

   Standby:
     - Nothing


.m_vpls_repo_ifl_delete_all
-------------------------------------------------------------------
   Master:
     For GR: when master RE finishes GR
     and for master RE not in GR or not in NSR during l2ckt_init()
     - delete all IFL repositories 
     - and free subunit if not IN USE.
     - send delete message to kernel for IFL not IN USE

   Standby:
     - Invoked on switch-over (l2ckt_re_switchover()) for cleaning up all
       the IFL (for VT/LSI) repositories
     - free subunit if not 'IN USE'.
     - send delete message to kernel for IFL not 'IN USE'.
     


.m_vpls_process_iff_change
-------------------------------------------------------------------
   Master:
     For Master RE in GR state:
     - Listen for vpls_iffchange and build IFL repository
     - allocate subunit for IFL.

   Standby:
     - Listen for vpls_iffchange and build IFL repository.
     - allocate subunit for IFL


.m_vpls_process_ifl_delete 
-------------------------------------------------------------------
   Master:
     - nothing

   Standby:
     - triggered by vc_iflchange() on IFC_DELETE.
     - delete VPLS IFL repository 
     - free subunit if it is not 'IN USE'


.m_vpls_repo_ifl_delete_all_vt
-------------------------------------------------------------------
   Master:
     For Master RE in GR state
     - triggered by vc_ifdchange() for handling VC flaps
     - delete VPLS IFL repository for related VT interface only
     - free subunit if not 'IN USE'
     - no need to handle kernel delete as it is done by IFD down event

   Standby:
     - triggered by vc_ifdchange() for handling VC flaps
     - delete VPLS IFL repository for VT interface only
     - free subunit if not 'IN USE'
     - no need to handle kernel delete as it is done by IFD down event


.m_label_alloc
-------------------------------------------------------------------
   Master:
     - Try to reuse label in the IFL repository first (in GR state)
     - If no match find, allocate new label

   Standby:
     - Try to resurrect label in the label repository built from LDP:
       find matching label repository entry and set 'IN USE' flag.
  

.m_label_free 
-------------------------------------------------------------------
   Master:
     - free label

   Standby:
     - set flag for the label repository entry. Label repository entry stays.

