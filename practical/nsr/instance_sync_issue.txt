1. Introduction
---------------
This document examines ways to see if the Primary and Standby's ribin
and ribout for PE neighbors can be synchronized at a higher level
based on configuration changes as opposed to letting the ribs go out of
sync and eventually synchronizing the Standby's ribs using an internal
route-refresh mechanism between Standby and Primary.

2. Commit synchronization issue
-------------------------------
Even though commit synchronize is turned on, the current infrastructure
 doesn't guarantee that both Primary and Standby have processed commit N 
before processing commit N+1.  Due to this,  the Primary and Standby 
could be processing commits at different rates. In other words, at a 
given point in time, the Primary and Standby could be having a different 
view of the commit database. Eventually, they'd come to the same view after 
all the outstanding commits have been processed.  The application needs 
to handle this scenario of transient commit differences.

One of the issues with the current commit infrastructure is that certain
commit operations could be missed by a process due to the asynchronous
means of acting on commit notifications. This could lead to the Primary and
the Standby undergoing different intermediate state transitions that would
need to be considered in the design. As an example:

Time    Operation           Primary                     Standby
----    ---------           -------                     -------
t0      Add instance A      Consumed                    Consumed
t1      Delete Instance A   Busy                        Consumed
t2      Add instance A      Consumed - but is a no-op   Consumed
                            since there's no change
                            to the config database when
                            to the in-memory database
                            built at time t0.

Handling all these scenarios in rpd makes the application unnecessarily
complex. Furthermore, if there are other applications in the future
that need the same functionality, the same complexity now needs to be
built into other those applications as well.

The idea of a synchronized model - where commit N + 1 does not proceed until
the previous commit N has been successfully processed by both Primary 
and Standby is now being considered. The exact mechanism to achieve this
hasn't been finalized yet. For the purpose of this document, its safe to
assume that both the Primary and the Standby will be looking at an identical
configuration database. Until both have indicated that they've done processing
with the current configuration, the configuration does not change.

With the synchronized model, there are only two states that need to be
handled by the Primary and Standby while processing configuration. Either
the other-RE (used to denote the other RE - it could be Primary or Standby
depending on local RE's state) is faster than us (local-RE) or it is slower.

3. Control connection
---------------------
Create another tcp session between Primary and Standby. This will be
used for control messages exchange. If we use the regular rsync session,
control messages could be HOL blocked due to unconsumed updates sitting
in the queue.

4. RT processing changes in BGP
-------------------------------
Both Primary and Standby maintain a commit_sync table. Its an array
of size BGP_NLRI_MAX. 

struct {
boolean nlri_status
boolean nlri_ack
} bgp_commit_sync_rtgt[BGP_NLRI_MAX];

The above data structure is used both in the Primary and Secondary although
in a different way. 

4.1 Primary operation
---------------------
Before the Primary can send route-refreshes on set of newly learnt
route-targets, it needs an ACK from the Standby indicating the Standby
has learnt those route-targets too so that prefixes containing these
route-targets aren't dropped by the Standby.

In case of route-target deletion, the Standby should delete the route-targets
only after the Primary has deleted them.

4.1.1 RT add
-------------

4.1.1.1 Primary ahead
---------------------
In cases where the Primary is ahead, it doesn't process any route-target
additions. 

When an ack comes in from the Standby indicating the Standby has added
those route-targets to BGP, the Primary processes the newly added
route-targets.

BGP maintains an internal data structure with all configured route-targets
and the rt module maintains a similar data structure. During re-configuration,
these two trees are compared. If the rt module has a route-target that's
not present in BGP's data structure, it indicates an addition.  BGP uses
the rt's data structure as a repository in this case and processes the
additions only after an ACK from the Standby.

For achieving some parallelism, there is an ACK per NLRI sent by the Standby. 

4.1.1.2 Standby ahead
---------------------
In this case, when a ACK from the Standby comes in, its stored in
bgp_commit_sync_rtgt[nlrix].nlri_ack. 

When the Primary parses this config, it does a lookup first to see if the
Standby has already acked this NLRI. Since there's a match, it processes
the route-targets for the NLRI inline.

4.1.2 RT delete
---------------
RT deletion needs to be handshaked with the Standby. Otherwise, the Standby
could delete the RT before the Primary has deleted it. This could lead
to trouble in case like the following:

1. Primary learnt a PE route containing the RT (before the RT gets deleted).
   The route got imported to the CE instance table and also got advertised
   to the CE. The Standby dropped the PE route and failed to create a RIBIN
   entry for this route since it deleted the RT. If a Switchover occurs now,
   the new Primary will find a RIBOUT for the CE prefix, but won't find
   the corresponding RIBIN in the VPN table. There could be an issue when
   sending the withdraw for this prefix.

In order to avoid the problem like above, when the Primary deletes an RT
through a commit notification, it sends a delete request to the Standby.  
It doesn't need to wait for an ACK. It continues to perform the tasks it 
would do during RT deletion. The Standby needs to wait for a RT delete 
notification containing for an NLRI before it can handle a RT delete 
operation. This guarantees the Standby bgp's RIBIN for VPN table's in 
sync (or ahead - meaning it could have more prefixes, which is ok) with
the Primary.

4.1.2.1 Primary
---------------
When Primary processes a set of route-targets associated with an NLRI
as part of this commit, it processes the delete and then sends an delete 
route-target message to Standby.

4.2 Standby operation
---------------------

4.2.2 RT add
------------
When Standby processes a set of new route-targets, it sends an ack to the
Primary with the nlri.

4.2.2.1 Standby
---------------
The Standby processes its configuration, adds the route-targets and send
an ack to the Primary. 

4.2.1 RT delete
---------------

4.2.1.1 Primary ahead
---------------------
Primary processes the deleted route-targets and sends a delete message per
NLRI to the StandbyStandby.  On receiving this message, the Standby 
sets the bgp_commit_sync_rtgt[nlrix].nlri_ack. 

When the RT delete happens through the config processing, Standby checks 
the bgp_commit_sync_rtgt table. In this case, it finds nlri_ack set to TRUE.
The Standby goes ahead and does the cleanup associated with RT delete
inline with commit processing.

4.2.1.2 Standby ahead
---------------------
In cases where the Standby is ahead, it doesn't process any route-target
deletions. 

When an route-target deleted message comes in from the Primary indicating 
the Primary has deleted those route-targets to BGP, the Standby processes 
the deleted route-targets.

5. RD processing changes in rt module
-------------------------------------
BGP stores its RIBOUT as part of the prefix that's being advertised.
If we consider a CE prefix being advertised to PE peers, the associated
RIBOUT would be present as part of the CE prefix. The CE prefix itself
resides in RIB tables associated with that CE instance. If the Standby
needs to digest the PE update, when it snoops the update, it needs to 
have the RD created so that it can insert the RIBOUT entry for this prefix.

The solution is to make sure that the routing tables associated with an
instance are created in the Standby before the Primary sends updates from
those tables to PE peers. In order to do this, the Primary handshakes
with the Standby and learns when those tables are created. Until then,
PE updates are deferred. When the Primary learns that Standby has created
the tables, it walks the instance tables and generates PE updates.

The RD handshake mechanism is very similar BGP's RT handshake. One difference
is that on a instance addition, the Primary creates the tables like it
does today without waiting for an ACK from the Standby. It marks these
tables NOT_SYNC. During PE flash callbacks, BGP doesn't generate updates
if the NOT_SYNC bit is set. When the Standby sends an ACK for RD creation,
the NOT_SYNC bit is reset and a BGP callback is invoked. BGP then walks all 
the associated tables and generates PE updates.

5.1 auto-rd
-----------
For instances where auto-rd is configured, the Primary generates the rd
values. These rd name and the associated value is then send to the Standby.
When the Standby resolves all the RD's in a commit, it ACKs the RD creation.
Instances with auto-rd are marked RD_UNKNOWN in Standby during creation until
they get resolved.

The Primary assigns an "instance number" to an RD. This is the number that's
synced to the Standby. The Standby can create the rd-value based on this
instance number.

5.2 NGEN MVPN
-------------
A set of extended communities for filtering are installed in BGP's table.
These are constructed based on the instance number a a loopback address.
There needs to be a handshake exactly similar to route-target addition
and deletion betwen the Primary and Standby rpd's to handle the
installation and deletion of NGEN MVPN extended communities.

5.3 Data structures
-------------------
The following piece of information is maintained:

#define CSS_DONE_RD     0x0002  /**< Done RD processing */
flag_t  task_commit_sync_status;

#define CSA_DONE_RD     0x0002  /**< Other RE has done RD processing */
flag_t  task_commit_sync_ack;

When the Primary processes RD addition, it sets the CSS_DONE_RD flag in
task_commit_sync_status. When an ACK from the Standby comes in, it
sets the CSA_DONE_RD flag in task_commit_sync_ack. When both of these
flags are set, it denotes config completion of RDs.

In case of auto-rd, after the Primary has created the instance, it sends
a rd-mapping message to Standby that contains the rd-name to instance-number
mapping along with setting the CSS_DONE_RD flag. The Standby waits for
all its auto-rd's in this commit to be resolved before sending an ACK
message to the Primary.

5.4 Primary operation
---------------------

5.4.1 Instance add
------------------

5.4.1.1 Primary ahead
---------------------
Primary creates all the newly configured RD's. It marks all the created 
instance tables as OUT_SYNC. Also, it maintains a newly configured RDs
as a list (rd_commit_list).

If there are any auto-rd's configured it sends a rd-mapping message to the 
Standby with rd_name and the rd_value assigned value.

When an ACK comes in from the Standby, the Primary does resets the OUT_SYNC bit
for all rd's in the rd_commit_list. It invokes BGP's callback for all 
the associated tables so that BGP can start generating the PE updates now.

5.4.1.2 Standby ahead
---------------------
Note: This case is possible only when a commit doesn't have any instance with
auto-rd configuration. 

In that case, the Standby processes the instance addition and sends
an ACK. When the Primary processes this ack, it sets the CSA_DONE_RD
flag in task_commit_sync_ack.

Eventually, when the Primary reads its config, it looks to see if
CSA_DONE_RD is set. If so, instance addition proceeds the same way
as today.  BGP can send PE updates now since the Standby has created 
the requried tables.

5.4.2 Instance delete
---------------------
Instance deletion needs to be handshaked. Otherwise Standby could delete
an instance before the Primary has deleted it. Consider a case where there
were no routes in an instance and Standby went ahead and deleted the instance
acting on the commit notification.  The Primary meanwhile brought up a 
CE neighbor, learnt a route and sent that route to a PE neighbor. The Standby 
would drop this PE update as it has already deleted the RD. If a Switchover 
occured now, the new Primary wouldn't be able to send any withdraws to the 
PE neighbor (due to the instance going down) since it has already deleted 
the instance.

In order to avoid the above problem, when the Primary deletes an RD through a 
commit notification, it sends a delete request to the Standby.  It doesn't 
need to wait for an ACK. It continues to perform the tasks it would do 
during RD deletion. The Standby needs to wait for a RD delete notification
while processing a given commit before it can perform the actual deletion.

5.4.2.1 Primary
---------------
When Primary processes a set of instance deletes as part of this commit, 
it processes the delete and then sends an delete rd message to Standby.

5.2 Standby operation
---------------------

5.2.2 RD add
------------

5.2.2.1 Standby ahead
---------------------
The Standby processes its configuration, creates instance data structures
and send an ACK to the Primary. 

auto-rd instances are marked with RD_UNKNOWN. When the Standby creates them,
it also adds them to autord_commit_tree. When the Primary sends
rd-mapping message, the rd-value is constructed and assigned to these
instances and they're deleted from the autord_commit_tree. When the
autord_commit_tree becomes empty, Standby ACKs the Primary for completion
of instance creation.

5.2.2.2 Primary ahead
---------------------
The mechanism is very similar to section 5.2.2.1 when auto-rds are not
configured.

With auto-rds, when the Standby gets rd-mapping messages, it adds them
to the autord_commit_tree (since a node won't be present). The name/instance-
value mapping is added.  When config is processed for auto-rd instances, 
a lookup is done first on autord_commit_tree to see if a mapping already
exists. In this case since the Primary is faster, the node will be present
and  the rd-value is used and this node is deleted. 

5.2.1 RD delete
---------------

5.2.1.1 Primary ahead
---------------------
The Standby sets the CSA_DONE_RD flag in task_commit_sync_ack when it
receives a RD delete notification from the Primary. When a delete RD 
is processed through commit, the Standby finds the CSA_DONE_RD flag
set and handles the RD deletes in the usual manner.

5.2.1.2 Standby ahead
---------------------
The Standby adds the RD(s) to be deleted to rd_commit_list.  When the 
Primary sends the RD delete notification, actual deletion process is
trigerred  for the RDs in the rd_commit_list.

5.2.1.2.1 Implementation note
-----------------------------
We probably should not set the "deleted" bit on the table until the RD delete
ack from the Primary comes in. If we set the "deleted" while processing
the commit, there may be a snooped PE update for this RD since the Primary
still hasn't deleted the RD and since the deleted bit on the table is set, 
we may drop it on the floor.  

6.0 Route refresh Synchronization
---------------------------------
With the mechanism described so far, the ribin and ribout for PE neighbors
are always in sync with the synchronized table creation and sending
route-refresh to the peer. But there's an issue that a Switchover can
happen before the route-refresh gets sent out. In that case, the new
Primary needs to send the route-refresh. There could be multiple commits
and each commit may or may not lead to route-refreshes on a set of PE
neighbors. The foolproof way to track is based on the commit_seqno. If
the Standby can determine that a route-refresh has been sent for a given
commit_seqno, it can determine what needs to be done after a Switchover.

We cannot send a commit_seqno along the route-refresh message itself. Also
the Standby cannot predict the number of route-refreshes that would be sent
depending on the commits made - since the Primary could combine multiple
route-refresh requests into one depending on various factors (an example
being sending the route-refresh message inline when there's no messages
spooled versus delayed sending which could result in multiple RTs combined
into a single refresh when there are messages spooled). 

One way to implement this is to build an internal ack (to Primary) from the 
Standby when the Standby sees a route-refresh. The Primary knows how many
route-refreshes were enqued to TCP. When all of those have been acked
by the Standby and there are no more pending route-refreshes to be sent,
it looks at the commit_seqno (stored as part of the peer structure) and
sends a COMPLETE message with the commit_seqno. The Standby records the
commit_seqno from the COMPLETE message. After Switchover, if its commit_seqno
for that neighbor matches the one learnt from Primary (there have been
no more commits and the last commit's route-refresh has been sent), the
Standby doesn't need to sent a route-refresh out for this neighbor.

Note that these counters are per NLRI.

6.1 ORF
-------
The mechanism is similar in case route-refresh ORF is configured. The
pending bit in the primary is cleared only after all the ORF updates
have been sent out. The Standby would acknowledge all ORF route-refreshes.

The Standby doesn't track which RT's have gone out in each commit. Hence
after Switchover if it determins that a route-refresh needs to be sent out,
it sends out ORF updates for all configured RTs.

7.0 RTF
-------
There's no special handling required to process incoming filters since
the Standby can snoop the incoming updates and install them. Filter
updates generated at the local router need to be handshaked in the same
way as route-target creation/deletion.

8.0 Config completion
---------------------
Similar to RD, there are RT flags defined and used in a similar way
as described earlier.

#define CSS_DONE_RT     0x0001  /**< Done RT processing */

#define CSA_DONE_RT     0x0001  /**< Other RE has done RT processing */

When the local RE has finished its commit processing, the flag
corresponding to RD or RT gets ste in task_commit_sync_status. When
the other-RE indicates processing complete, the flag gets set on
task_commit_sync_ack.

When the RD/RT flags are set on both task_commit_sync_status and 
task_commit_sync_ack, this denotes config completion. The mechanism required 
by the infrastructure to signal config completion will be implemented
based on the above two variables.

9.0 rpd bootup
--------------
The Standby processes the initial config without any commit handshake.
After that all commits are synchronized. 

After the Standby establishes the rsync connection, further commits from
that point of time are commit-synchronized.

10. Non-NSR configuration
-------------------------
The commit-synchronize machinery does not get kicked in when NSR isn't
enabled.
