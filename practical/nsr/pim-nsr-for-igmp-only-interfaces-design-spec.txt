$id: $

PIM NSR support for IGMP-only enabled interfaces Design Specification

Author: Vikram Nagarajan <vikramna@juniper.net>

Copyright (C) 2011, Juniper Networks, Inc.

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.


TABLE OF CONTENTS

1.	INTRODUCTION
1.1	SCOPE
1.2	REVISION HISTORY
1.3	REFERENCED DOCUMENTS
1.4	GLOSSARY

2.	ARCHITECTURE OVERVIEW
2.1	DESIGN REQUIREMENTS

3.	DESIGN DETAILS
3.1	ASSUMPTIONS AND DEPENDENCIES

3.2	HIGH LEVEL DESIGN
3.2.1	Existing PIM NSR Mechanism
3.2.2	Existing IGMP-only-enabled interfaces and PIM Interaction
3.2.3	PIM NSR Design for mirroring Join State on IGMP-only-enabled interface

3.3	DESIGN RISK ITEMS
3.4	IMPACTED SOFTWARE COMPONENTS
3.4.1	SOFTWARE COMPONENTS IMPACTED BY DESIGN
3.4.2	POTENTIALLY IMPACTED SOFTWARE COMPONENTS

3.5	COMPONENT INTERACTIONS
3.5.1	PIM NSR Module
3.5.1.1 PIM NSR Definition
3.5.1.2 PIM NSR Module Changes
3.5.1.3 pim_rdb_pseudo_gmp_t
3.5.1.4 Pseudo-GMP mirroring APIs

3.5.2   Mirroring Module
3.5.2.1 Mirroring Module Definition
3.5.2.2 When IGMP interface goes down  (or) 'clear igmp membership <interface>'
3.5.2.3 'clear igmp membership <group>'
3.5.2.4 Resolve Mechanisms for Pseudo-GMP RDB
3.5.2.5 After RE switchover
3.5.2.6 Initial State Synchronization
3.5.2.7 Clean up of RDBs
3.5.2.8 pim_xif_resync_gmp_oif

3.6	INTER PROCESS COMMUNICATION
3.7	CONCURRENCY STRATEGY
3.8	STARTUP STRATEGY
3.9	MEMORY MANAGEMENT
3.10	FAULT AND EXCEPTION HANDLING
3.11	DEBUG SUPPORT
3.11.1  CLI Commands
3.11.1.1 Show PIM join extensive
3.11.2  PIM NSR trace logs
3.12	TESTABILITY, SERVICEABILITY AND DIAGNOSE-ABILITY
3.13	CONSTRAINTS AND LIMITATIONS
3.14	REJECTED DESIGN ALTERNATIVES
4.	PATENT OPPORTUNITIES
5.	PERFORMANCE
5.1	PERFORMANCE RELATED RESOURCES
5.2	TARGET PERFORMANCE
5.3	64-BIT KERNEL SUPPORT
6.	SCALING
7.	MULTI-CORE ENVIRONMENT
8.	COMPATIBILITY ISSUES
9.	HIGH AVAILABILITY (HA)
9.1	GRACEFUL RE SWITCHOVER (GRES), ISSU IMPACT
9.2	NSR IMPACT
10.	LOGICAL SYSTEM / ROUTING INSTANCE IMPACT
11.	MULTI / VIRTUAL CHASSIS IMPACT (HOBSON OR CHAI)
12.	PLATFORMS SUPPORTED
13.	SDK IMPACT
13.1	SDK CUSTOMER USAGE
14.	JUNOS READY SOFTWARE CONSIDERATIONS
15.	FREE SOFTWARE CONSIDERATIONS
16.	3RD PARTY SOFTWARE CONSIDERATIONS
16.1	FUNCTIONAL ROLE OF 3RD PARTY CODE WITHIN JUNOS
16.2	INTEGRATION DETAILS OF 3RD PARTY CODE WITHIN JUNOS
17.	POSIX NON-COMPLIANCE
18.	FUTURE CONSIDERATIONS
19.	REVIEW COMMENTS
19.1	REVIEW STAKEHOLDER MATRIX


INDEX OF FIGURES
----------------
FIGURE 1: Existing PIM NSR Mirroring Mechanism
FIGURE 2: Existing IGMP-only-enabled interfaces and PIM interaction
FIGURE 3: PIM NSR Design for mirroring Join State on IGMP-only-enabled interface



1. INTRODUCTION

This document describes the design details of Non Stop Routing (NSR) support 
for IGMP-only-enabled interfaces. 

IGMP-only-enabled interfaces are represented in PIM as Pseudo-GMP interface.
The IGMP-only-enabled interfaces on the router are represented in code as xif. 
xif is a single Pseudo-GMP interface that is created for the entire router 
to represent all the IGMP-only-enabled interfaces on the system.   

Currently (until 12.2), PIM NSR works only for IGMP Reports/PIM Joins received
on PIM enabled interfaces (pif). With 12.3, PIM states created due to IGMP reports
received on IGMP-only-enabled interfaces (xif) will be replicated to 
the backup RE using new replication database (RDB) for IGMP-only-enabled interafaces.

1.1 SCOPE

Since current PIM NSR code works only on pif, the IGMP/MLD reports received
on IGMP-only-enabled interface (non-PIM enabled interface) will create PIM 
state only on the master. The backup will not know about these states. On 
switchover, PIM on the new master will have to wait for the IGMP reports 
to come in from the network and then create state. Until such time, there will
be traffic loss for the groups.  

With this RLI, the PIM state created on the master RE for IGMP-only-enabled 
interfaces will be mirrored to the backup RE using new set of RDBs so that PIM 
on the backup RE can create the suitable state for IGMP-only-enabled interfaces. 

This RDB for IGMP-only-enabled interfaces will be independent of the RDBs that are
used to mirror Join/Prune state received on PIM-enabled interfaces.

IGMP module will not run on the backup RE since states needed for control plane
and forwarding plane are handled by PIM NSR mirroring.  


1.2 REVISION HISTORY

  Revision: 1.1
      Initial Draft. 09/16/2011.
      Vikram Nagarajan

  Revision: 1.2

  Revision: 1.3

  Revision: 1.4

1.3 REFERENCED DOCUMENTS

[IGMP-only-NSR-FS]   PIM NSR support for IGMP-only-interfaces Functional Specification
                 sw-projects/os/nsr/pim-nsr-for-igmp-only-interfaces-funcspec.txt

[PIM-NSR]        PIM NSR Phase 2 and Phase 3 Functional Specification
                 RLI 6259, RLI 11800
                 sw-projects/os/nsr/pim-nsr-6259-11800-funcspec.txt

IGMP-only-enabled interfaces related specificatons 
                 sw-projects/routing/multicast/igmp/igmp-pim-interaction.txt
                 sw-projects/routing/multicast/igmp/igmp-pim-separation-fs.txt
                 sw-projects/routing/multicast/igmp/igmp-pim-separation-utp.txt
                 sw-projects/routing/multicast/igmp/igmp-pim-seperation-func-spec.txt
                 sw-projects/routing/multicast/igmp/igmp-without-pim-fs.txt

1.4 GLOSSARY

 NSR       Non Stop Routing
 RDB       Replication DataBase

2. ARCHITECTURE OVERVIEW


The changes made for this RLI do not affect the overall JUNOS architecture.
There is enhancement made to the PIM NSR module to support mirroring PIM states 
created on account of IGMP/MLD reports received on IGMP/MLD-only-enabled interfaces. 

2.1 DESIGN REQUIREMENTS

Non stop routing for IGMP-only-enabled interfaces. There should be no 
traffic disruption (<1%)for multicast streams after RE switch over.

The backup RE should keep the same PIM Join state for Pseudo-GMP interface 
as master RE. The states on the new master should not be recreated after  
switchover.

3. DESIGN DETAILS


3.1 ASSUMPTIONS AND DEPENDENCIES

(i)   PIM NSR implementation for IGMP-only-enabled interfaces is dependent on 
      multicast route synchronization by way of ksyncd. The multicast routes 
      have to be synced to the backup by ksyncd.  

(ii)  PIM NSR implementation for IGMP-only-enabled interfaces is not tied with
      implementation of regular Joins/Prunes recevied on regular PIM interfaces. 
      This implementation takes care of only Joins received on interfaces that 
      have only IGMP/MLD configured. 

(iii) This RLI is depenedent on RLI 14680 'Automatic make-before-break PIM join 
      rebalancing on ECMP (source-code)'. The dependency is because the RLI 14680 
      introduces a mechanism for mirroring RPF information for the SGs 
      independently of Join/Prune mirroring. 

      Prior to RLI 14680, for Join-Load-Balance NSR, we sent the upstream information 
      along with regular Join/Prune mirroring. If we do not have regular PIM interface 
      as downstream and have only IGMP-only-enabled interfaces as downstream, and if we have 
      Join-Load-Balance configured, there is no way for the SGs created on the backup  
      to know about the upstream. This is because, SGs are not mirrored using the 
      regular Join/Prune mirroring. So, the upstream information is also not available.
  
      With RLI 14680, the RPF information for each SG is mirrored independently
      of regular Join/Prune mirroring and hence, the SGs created on backup for
      IGMP-only-enabled interfaces will have the upstream information with this
      form of mirroring RPF. The RLI 14680 is done in 12.2. 

(iv)  This RLI for PIM NSR support for IGMP-only-enabled interfaces is supported
only for PIM Sparse mode.


3.2 HIGH LEVEL DESIGN

3.2.1 Existing PIM NSR Mechanism:
---------------------------------

The Figure 1: shows how Join/Prune messages/states received on PIM interfaces 
are mirrored to the backup RE prior to this RLI. 


 
                                                               LIBMIRROR API 
              +--------+      +-----------------+                   |                        +-----------------+     +----------+
   PIM------->|Create  |----> |  Join RDB       |                   |                        |  Join RDB       |     |Create    |
    ^         | Join SG|      |  Key: nbr + pif |==Join RDB Encode==|==Join RDB Decode ====> |  Key: nbr + pif |---->|  Join SG |
    |         +--------+      |  S1G1 S2G2      |                   |                        |  S1G1 S2G2..    |     |          | 
    |                         +-----------------+                   |                        +-----------------+     +----------+
    |                                                               |
    |          +-------+      +-----------------+                   |                        +-----------------+     +----------+
   (pif)------>|Create |----->| Nbr RDB         |                   |                        |  Nbr RDB        |     | Create   | 
    ^  ^       |   Nbr |      | Key: ifl-index  |==Nbr RDB Encode===|==Nbr RDB Decode=====>  |  Key: ifl-index |---->|    Nbr   | 
    |  |       +-------+      | Nbr address     |                   |                        |  Nbr address    |     +----------+ 
    |  |                      +-----------------+                   |                        +-----------------+     
    |  |          
    |  +-----------+
  IGMP             | 
    ^              |
    |              |
    |              |
  IGMP Report     PIM Join
                
                        Master RE                                                        Backup RE

                             Figure 1: Existing PIM NSR Mirroring Mechanism

We can see from the existing PIM NSR mechanism for PIM enabled interfaces 
in the above Figure, that for mirroring Join/Prune, we need a pif and a 
nbr. For IGMP static joins, we use self-neighbor of pif (pif->pif_our_nbr)
to mirror the Joins. 

In the case of IGMP-only-enabled interfaces, there is no pif or nbr. So, the
Joins created on the master are not mirrored to the backup. 

3.2.2 Existing IGMP-only-enabled interfaces and PIM Interaction: 
-----------------------------------------------------------------

The Figure below shows how the huge list of downstream interfaces
are managed optimally with the use of IGMP-only-enabled interfaces.


                                                        +-------------+
     PIM ---->SG(a)--->pim_sfsm_join_req          Y     | Add SG(a)   | 
     |                    is xif oif tree empty ------->|  PIM SFSM   |  
     | (xif)                        |                   |             | 
     |                              | N                 +-------------+ 
     |                              | 
   IGMP                             +------->Add b,c,d to patricia_tree  
  | | | |                                    sg_gmp_interfaces
  | | | |
  | | | |
  a b c d
  ^ ^ ^ ^
  | | | |
  | | | |
IGMP Reports

         Figure 2: Existing IGMP-only-enabled interfaces and PIM interaction

Instead of creating each downstream pif for each ifl, the set of all IGMP-only
enabled interfaces are represented by xif. The SG when it receives first
IGMP report on interface a, checks for the oif_tree to be empty. If empty,
it passes the SG through the SFSM creating downstream list. Also, it creates
a patricia_tree sg_gmp_interfaces to store the downstream ifls. 

Now, when IGMP report is received for the same SG on b, c, d, we don't 
pass it through the SFSM.  Instead, we just populate the sg_gmp_interfaces 
tree with the downstream IFLs.  This way, we can scale upto 64K downstream IFLs 
which have just IGMP hosts on the downstream. 


3.2.3 PIM NSR Design for mirroring Join State on IGMP-only-enabled interface: 
----------------------------------------------------------------------------


In the below figure, we can see how the PIM states for IGMP-only enabled interfaces
get created on the master and by replication, how PIM states get created on the
backup.  

                                                                              [C]                     
      [A]                           [B]                         +--------------------------------+                [D]     
 +-------------------+      +------------------------+          | pim_xif_create                 |        +---------------------------+
 |  IGMP Module      |      |  PIM Module            |          | pim_jp_add_local_receiver      |        | pim_sfsm_join_req         |
 |mgm_group_change() |      | pim_xif_add_gmp_oif()  |--------->|    pim_jp_remove_local_receiver|------->| pim_xif_add_ifindex       |
 |  SG,ifl, change_id|----->| pim_xif_del_gmp_oif()  |<---------| jp_add_sparse_join_entry       |        |  if oif_tree_empty        |   
 | change id: ADD/DEL|      |    SG,ifl              |          |    jp_add_sparse_join_entry    |        |      pim_xif_add_ifindex  |  
 +-------------------+      +------------------------+          | jp_add_jp_entry                |        |      Process Join in SFSM |
      ^                               |                         | pim_jp_job_worker              |        |  else                     |             
      |                               |                         +--------------------------------+        |      pim_xif_add_ifindex  |
      |                               |                                                                   +---------------------------+
      |                               |
      |                               |
      |                               |
IGMP Report/Leave                     v      [E]                               [F]      
received on            +-----------------------------------+           +---------------------+ 
IGMP-only-enabled      |    Create pseudo_gmp RDB          |           | Encode RDB into     |
interface              |   RDB Key: Source, Group, iflindex|---------->|   TLV and send      | 
                       |                                   |           |   to backup RE      | 
                       +-----------------------------------+           +-------+-------------+ 
                                                                               | 
                          Master RE                                            |
                                                                               |
              ----------------------------------   LIBMIRROR  -----------------|-----------------------------------------------
                                                                               |
                                                                               |
                          Backup RE                        [G]                 |
                                                     +------------------+      |
                                                     |Decode TLV and [G]|      |
                                      +--------------| form RDB with    |<-----+ 
                                      |              | Source, Group    |
                                      |              | and iflindex     |
                                      |              +------------------+
                                      |                                      [I]
                                      V   [H]                   +--------------------------------+                   [J]
                            +---------+--------------+          | pim_xif_create                 |        +---------------------------+
                            |  PIM Module            |          | pim_jp_add_local_receiver      |        | pim_sfsm_join_req         |
                            | pim_xif_add_gmp_oif()  |--------->|    pim_jp_remove_local_receiver|------->| pim_xif_add_ifindex       |
                            | pim_xif_del_gmp_oif()  |<---------| jp_add_sparse_join_entry       |        |  if oif_tree_empty        |   
                            |    SG,ifl              |          |    jp_add_sparse_join_entry    |        |      pim_xif_add_ifindex  |  
                            +------------------------+          | jp_add_jp_entry                |        |      Process Join in SFSM |
                                                                | pim_jp_job_worker              |        |  else                     |     
                                                                +--------------------------------+        |      pim_xif_add_ifindex  |
                                                                                                          +---------------------------+


    
         Figure 3: PIM NSR Design for mirroring Join State on IGMP-only-enabled interface


When a IGMP/MLD report is received on an IGMP/MLD-only-enabled interface, 
PIM gets notified from from mgm_group_change. (Boxes [A] and [B])

    MGM_GROUP_ADDED       :  pim_xif_add_gmp_oif
        Notifies PIM about the interest of a new group.
    MGM_GROUP_REMOVED     :  pim_xif_del_gmp_oif
        Notifies PIM about the leave of an existing group. 
    MGM_GROUP_SRC_REMOVED : pim_xif_del_gmp_grp
        Notifies PIM to remove all the sources from a group. 

The function pim_xif_del_gmp_grp() that deletes the sources 
from a group walks the tree and iteratively calls pim_xif_del_gmp_oif()
for each S,G. Effectively, it is enough if the backup RE is 
notified about pim_xif_add_gmp_oif() and pim_xif_del_gmp_oif() alone.


This results in Join/Prune state being queued for creation [C]. When the 
job gets triggered it gets processed in pim_fsm_join_req()in block [D].
Here, the downstream ifl gets added to the sg_gmp_interfaces tree, 
which is the tree of downstream interfaces for an SG.  If it was 
the first downstream ifl for the SG, it gets processed in SFSM to 
create downstream states. Else, it just returns without further processing. 

Also, the received ADD/REMOVE message is processed for NSR to form 
an RDB [E]. The RDB is encoded in TLVs for mirrorring [F]. On backup,
the decoded TLV messages are parsed and an RDB is formed [G]. 

With the formed RDB on the backup, the SG and ifl are extracted and 
the same functions pim_xif_add_gmp_oif() and pim_xif_del_gmp_oif()
that got called on the master are now called on the backup. [H]. 
This is a kind of simulation of IGMP/MLD received reports on the backup.
Only, the messages are coming from the mirror rather than from the
IGMP module on the backup.

From here, the PIM processing takes over that is similar to that
on the master. ([I] and [J]). This leads to the appropriate PIM state 
creation on the backup. 



3.3 DESIGN RISK ITEMS
 
None.

3.4 IMPACTED SOFTWARE COMPONENTS

A new mirroring component is added for PIM states created on account of 
IGMP reports received on IGMP-only-enabled interfaces. This will add a 
new mirroring type in the current mirroring module.

This new mirroring component will also interact with existing PIM NSR components 
to sync the PIM states during Initial State Synchronization (ISS) stage and for
resolving the RDB entries on backup when interfaces come up later than the RDBs.  


3.4.1 SOFTWARE COMPONENTS IMPACTED BY DESIGN

The following components will be impacted by this RLI.

 1) Common NSR mirroring component
 2) PIM NSR module
 3) IGMP-only-enabled interfaces notification module  
 4) Common PIM module

3.4.2 POTENTIALLY IMPACTED SOFTWARE COMPONENTS

The PIM NSR mirroring mechanism is currently being changed under RLI 14680. 
This change could have potential impact with the current code changes.

3 .5 COMPONENT INTERACTIONS

3.5.1 PIM NSR Module

3.5.1.1 PIM NSR Definition

PIM NSR module mirrors the PIM neighbor, RP, and Join/Prune states from the 
master RE to the backup RE. Now we extend this module to mirror PIM state created
for IGMP-only-enabled interfaces.

3.5.1.2 PIM NSR Module Changes

A new data structure pim_pseudo_gmp_t is added in PIM NSR module. This data 
structure represents IGMP Report information which is needed to build 
up Join state on the backup RE. New mirroring APIs are created to mirror the 
addition/deletion of the RDB entry when corresponding IGMP report/leave is received. 
Only mirror_add and mirror_del are used. mirror_update is not used since, we 
receive either a IGMP Report/Leave for a SG. Two new files pim_rdb_pseudo_gmp.c 
and pim_mirror_pseudo_gmp.c are created for the new data structure and new APIs. 

    (i)   Two new files pim_mirror_pseudo_gmp.c and pim_rdb_pseudo_gmp.c 
    (ii)  Makefile changes 
    (iii) RPD infra changes to notify about new mirror type.
    (iv)  New Mirror Registry entries.
    (v)   New RDB structure pim_rdb_pseudo_gmp_t
    (vi)  Mirroring functions to add/delete RDB and encode/decode TLVs.

The following sections describe the changes in detail.

3.5.1.3 pim_rdb_pseudo_gmp_t

This RDB entry contains the IGMP Report/Leave related information. This 
contains the Source, Group for which the Report/Leave was received. Also,
it contains the ifl index on which this Report/Leave was received. This is
applicable for statically configured IGMP groups on IGMP-only-enabled 
interfaces. 


    pim_rdb_pseudo_gmp_key  (Source, Group, kernel_index, iflindex)
             u_int              pr_rdb_pseudo_gmp_kernel_inst_index
             ifl_idx_t          pr_rdb_pseudo_gmp_idx
             pim_ipx_addr       pr_rdb_pseudo_gmp_source_addr
             pim_ipx_addr       pr_rdb_pseudo_gmp_group_addr

    pim_rdb_pseudo_gmp_t
             pim_rdb_pseudo_gmp_key     pr_pseudo_gmp_key 
             mc_af                         pr_rdb_pseudo_gmp_mcaf    

             thread                        pr_rdb_pseudo_gmp_mirror_thr
             mirror_data_node              pr_rdb_pseudo_gmp_mirror_node

             boolean                       pr_rdb_pseudo_gmp_resolved
             u_int32_t                     pr_rdb_pseudo_gmp_lock_count


3.5.1.4 Pseudo-GMP state  mirroring APIs

When there is a IGMP/MLD report received and PIM is notified on the master,  
corresponding Pseudo-GMP RDB entry will be added/deleted to/from the RDB 
database. The addition/deletion will then be mirrored to the backup RE. 
The backup RE decodes the mirrored RDB entry and adjusts the related 
Psdueo-GMP state accordingly. Figure 3 depicts the mirroring procedures 
for Pseudo-GMP RDB. 

The following functions are used to maintain the Pseudo-GMP RDB entries.

         Master RE                                Backup RE

ADD GROUP
      pim_pseudo_gmp_nsr_recv_processing     
      pim_pseudo_gmp_rdb_key_build        
      pim_pseudo_gmp_find_rdb                
      pim_pseudo_gmp_add_rdb              
      pim_pseudo_gmp_create_rdb              
      pim_pseudo_gmp_add_mirror
               mirror_add
      pim_mirror_pseudo_gmp_lock           
      pim_mirror_pseudo_gmp_unlock           
      pim_mirror_pseudo_gmp_encode           
      pim_mirror_pseudo_gmp_encode_tlv       pim_mirror_pseudo_gmp_decode_op
                                             pim_mirror_pseudo_gmp_decode_tlv
                                             pim_pseudo_gmp_find_rdb
                                             pim_mirror_process_pseudo_gmp_msg
                                             pim_pseudo_gmp_add_rdb_from_mirror
                                             pim_xif_add_gmp_oif
DEL GROUP
      pim_pseudo_gmp_nsr_del_processing           
      pim_pseudo_gmp_rdb_key_build
      pim_pseudo_gmp_find_rdb
      pim_pseudo_gmp_delete_mirror
      pim_pseudo_gmp_del_rdb
              mirror_del
      pim_mirror_pseudo_gmp_lock           
      pim_mirror_pseudo_gmp_unlock           
      pim_mirror_pseudo_gmp_encode           
      pim_mirror_pseudo_gmp_encode_tlv       pim_mirror_pseudo_gmp_decode_op
                                             pim_mirror_pseudo_gmp_decode_tlv
                                             pim_pseudo_gmp_find_rdb
                                             pim_mirror_process_pseudo_gmp_msg
                                             pim_pseudo_gmp_add_rdb_from_mirror
                                             pim_xif_del_gmp_oif


On Master RE, there is no need to update an RDB. When an existing IGMP notification is
getting refreshed, we find for an RDB and if it exists, we do a DELETE of 
that RDB (mirror_del) and then do an ADD of it (mirror_add). 


3.5.2 Mirroring Module

3.5.2.1 Mirroring Module Definition

Mirroring module is responsible for sending the RDB entry received from a NSR 
client on the master RE to the same client on the backup RE. NSR (including PIM 
NSR) clients register encoding, decoding, and other mirroring functions to the 
mirroring module. The encoded TLVized message will be transmitted to the decoding 
function for the same client on the backup RE. 

3.5.2.2 Mirroring Module Changes

A new mirroring type MIRROR_DATA_PIM_PSEUDO_GMP will be added for Pseudo-GMP RDB. 
pim_pseudo_gmp_mirror_registry is added as a new mirroring client. pim_mirror_pseudo_gmp_encode 
and pim_mirror_pseudo_gmp_decode are the encoding and decoding functions for new Pseudo-MGP RDB client. 
    
The newly added functions pim_pseudo_gmp_add_mirror and  pim_pseudo_gmp_delete_mirror 
will be mapped to the existing mirroring functions mirror_add and 
mirror_del/mirror_cancel, respectively. 

3.5.2.3 When IGMP interface goes down  (or) 'clear igmp membership <interface>'

When an IGMP interfaces goes down, pim_xif_gmp_if_down() gets called on the master. 
This will walk the SGs stored on the xifl->pxi_group_table and delete the SGs 
instead of treating them like receiving IGMP leave messages. This is an optimization
when we have a lot of SGs on a downstream ifl and the ifl goes down.  

In NSR case, in master, we will process the above and send an RDB which will 
mean to perform the same action on backup. After sending the special RDB (based on flag), 
we will walk all the RDBs on the master alone. We will not do 'delete mirror'. 
On backup, on receiving the special RDB, we will call pim_xif_gmp_if_down() on backup
which will clean up all the SGs optimally and then, we will delete the RDBs on the backup.
This way, we can reduce the load on the mirroring infrastructure to send the
delete messages of some many SGs. 


3.5.2.4 'clear igmp membership <group>'

This will result in all the groups in the group-range to be timedout prematurely by 
the gmp toolkit. This will result in pim_xif_del_gmp_oif() being called on the master. 
This will result in the Groups being mirrored for deletion which will cause the backup
to remove the SGs for this group.  
   


3.5.2.5 Resolve Mechanisms for Pseudo-GMP RDB
        (i) When the IGMP interface is not up on the backup when the Pseudo-GMP RDB is
            received on the backup.
                Since the interface is not PIM enabled, we will not receive a notification
            if the interfaces come up later in backup. When we receive Pseudo-GMP RDB 
            from master whose ifl is not up on the backup, we mark the RDB as unresolved.
            In the periodic Resolve job, we hook the Pseudo-GMP resolve function. When
            the interface comes up later, when we get called from the resolve job, we 
            will process the RDB and create the Join state on the backup.  This periodic 
            job will run as long as there are unresolved RDBs on the backup.  This low 
            priority background job runs today at 5 seconds interval (PIM_RESOLVE_RDB_INTERVAL).

                    pim_nsr_rslv_job()
                    pim_nsr_rslv_pseudo_gmp_rdbs()

        (ii) When upstream interface information is not resolved when the
             Pseudo-GMP RDB is received on the backup.
                 Similar handling is done for SGs with pifs as downstream. The RPF on the
             backup has to poke the SG with xif as downstream for the upstream state on 
             SG to be resolved.  

3.5.2.6 After RE switchover 
         (i) Set of actions to perform after RE switchover
                  Clear up old RDBs. 
                  Refresh timers for SGs if needed.
                  Wait for refresh from IGMP module. 

3.5.2.7 Initial State Synchronization
         (i) When IGMP/PIM flows exist and NSR is enabled. Walk the tree of
             SGs and form RDBs and mirror. (Or) the existing mechanism causes the
             commit to re-trigger the notifications from MGM to PIM. This causes
             the RDBs to be formed and mirrored automatically

         (ii) When rpd is restarted on the backup, we have the RDBs stored in the 
             mirrored thread. We get callback for mirror connection going up and
             we mirror all the RDBs to the backup.  When NSR is enabled on the 
             router, irrespective of the backup being up, we create and store
             the RDBs in ctx->psc_pseudo_gmp_root. We walk the tree in 
             pim_nsr_pseudo_gmp_mirror_all() and mirror them to the backup.  

         (iii) pim_nsr_rdb_pseudo_gmp_build
                 When NSR is enabled, we need to walk the group_tree searching
             for SGs which have pseudo_gmp as downstream and create RDBs for 
             them and store in ctx->psc_pseudo_gmp_root  and mirror them using
             pim_nsr_pseudo_gmp_mirror_all().  


3.5.2.8 Clean up of RDBs
            Walk the ctx->psc_pseudo_gmp_root and delete the rdbs in it
            and call pim_nsr_rdb_pseudo_gmp_all_delete() for each of the RDBs.
            This is to be done in the below scenarios.
         

            (i)   When NSR is deleted
            (ii)  When PIM NSR is disabled
            (iii) When Interface goes down
            (iv)  When Group Leave is received.
            (v)   When PIM is deleted
            (v)   When Mirror connection goes down 
            (vi)  When RPD is restarted on backup (same as v)
        

3.5.2.9 pim_xif_resync_gmp_oif

   --TBD--
        


3.6 INTER PROCESS COMMUNICATION

The existing mirroring mechanism is used between PIM IGMP-only NSR module and 
mirroring module. 

There is no new IPC mechanism added.

3.7 CONCURRENCY STRATEGY

N/A.

3.8 STARTUP STRATEGY

N/A

3.9 MEMORY MANAGEMENT

The existing RPD memory management mechanism is used.

Both master RE and backup RE maintain Pseudo-GMP RDB entries. One 
IGMP RDB entry maps to IGMP report received on an IGMP-only-enabled interface. 
So the memory consumed increases when the number of IGMP-only-enabled interface 
is increased or the number of SGs is increased. 

3.10 FAULT AND EXCEPTION HANDLING

Existing fault and exception handling mechanism is used.

3.11 DEBUG SUPPORT

The CLI commands used to show PIM states and multicast routes can be used on 
the backup RE. Users should expect the same output on the master RE and backup RE, 
except the statistics and timeout values. 

New PIM NSR trace logs are added for IGMP-only NSR. Once NSR trace is enabled, 
pim_nsr_trace logs all the changes for IGMP-only related events. 

3.11.1 CLI Commands

3.11.1.1 Show PIM join extensive

This command shows the downstream interface list for the SG. If there are IGMP-only
enabled interfaces in downstream, they are shown as 'Pseudo-GMP' and the names of
the downstream interfaces are shown.  

Without Code changes for this RLI:

    {master}
    regress@pro-bng-mc2-k> show pim join extensive
    Instance: PIM.master Family: INET
    R = Rendezvous Point Tree, S = Sparse, W = Wildcard

    Group: 237.1.1.1
        Source: *
        RP: 10.255.3.29
        Flags: sparse,rptree,wildcard
        Upstream interface: ge-0/1/3.0
        Upstream neighbor: 30.1.1.1
        Upstream state: Join to RP
        Uptime: 00:02:01
        Downstream neighbors:
            Interface: Pseudo-GMP
                so-0/0/0.0

    Group: 237.1.1.1
        Source: 133.1.1.1
        Flags: sparse,spt
        Upstream interface: ge-0/1/3.0
        Upstream neighbor: 30.1.1.1
        Upstream state: None, Join to Source
        Keepalive timeout: 358
        Uptime: 00:01:10
        Downstream neighbors:
            Interface: Pseudo-GMP
                so-0/0/0.0

    {master}
    regress@pro-bng-mc2-k> show multicast route extensive inet
    Instance: master Family: INET

    Group: 237.1.1.1
        Source: 133.1.1.1/32
        Upstream interface: ge-0/1/3.0
        Downstream interface list:
            so-0/0/0.0
        Session description: Unknown
        Statistics: 0 kBps, 1 pps, 120 packets
        Next-hop ID: 1048574
        Upstream protocol: PIM
        Route state: Active
        Forwarding state: Forwarding  <==================
        Cache lifetime/timeout: 360 seconds
        Wrong incoming interface notifications: 0
        Uptime: 00:02:00



    {backup}
    regress@pro-bng-mc2-k1> show pim join extensive inet
    Instance: PIM.master Family: INET
    R = Rendezvous Point Tree, S = Sparse, W = Wildcard

                <=======No mirroring for Pseudo-GMP interfaces

    {backup}
    regress@pro-bng-mc2-k1> show multicast route extensive inet
    Instance: master Family: INET

    Group: 237.1.1.1
        Source: 133.1.1.1/32
        Upstream interface: ge-0/1/3.0
        Session description: Unknown
        Statistics: 0 kBps, 0 pps, 0 packets
        Next-hop ID: 0
        Upstream protocol: PIM
        Route state: Active
        Forwarding state: Pruned <=================
        Cache lifetime/timeout: forever
        Wrong incoming interface notifications: 0
        Uptime: 00:00:17


With the RLI changes, the join output on backup will be the same 
as master (except timers). The multicast route on backup will
have state as 'forwarding'.


    {backup}
    regress@pro-bng-mc2-k> show pim join extensive
    Instance: PIM.master Family: INET
    R = Rendezvous Point Tree, S = Sparse, W = Wildcard

    Group: 237.1.1.1
        Source: *
        RP: 10.255.3.29
        Flags: sparse,rptree,wildcard
        Upstream interface: ge-0/1/3.0
        Upstream neighbor: 30.1.1.1
        Upstream state: Join to RP
        Uptime: 00:02:01
        Downstream neighbors:
            Interface: Pseudo-GMP
                so-0/0/0.0

    Group: 237.1.1.1
        Source: 133.1.1.1
        Flags: sparse,spt
        Upstream interface: ge-0/1/3.0
        Upstream neighbor: 30.1.1.1
        Upstream state: None, Join to Source
        Keepalive timeout:
        Uptime: 00:01:10
        Downstream neighbors:
            Interface: Pseudo-GMP
                so-0/0/0.0

    {backup}
    regress@pro-bng-mc2-k> show multicast route extensive inet
    Instance: master Family: INET

    Group: 237.1.1.1
        Source: 133.1.1.1/32
        Upstream interface: ge-0/1/3.0
        Downstream interface list:
            so-0/0/0.0
        Session description: Unknown
        Statistics: 0 kBps, 0 pps, 0 packets
        Next-hop ID: 1048574
        Upstream protocol: PIM
        Route state: Active
        Forwarding state: Forwarding  <==================
        Cache lifetime/timeout: forever
        Wrong incoming interface notifications: 0




3.11.2 PIM NSR trace logs

New NSR trace logs are added for IGMP-only NSR related events. This logs can be 
collected for debugging. These logs exists on both master and backup REs. 



3.12 TESTABILITY, SERVICEABILITY AND DIAGNOSE-ABILITY

When user encounters a IGMP-only enabled NSR issue, the CLI output and 
PIM NSR trace logs mentioned in the previous section should be collected to 
help identify the problem.

3.13 CONSTRAINTS AND LIMITATIONS

None.

3.14 REJECTED DESIGN ALTERNATIVES

None.

4. PATENT OPPORTUNITIES

N/A

5. PERFORMANCE

Once PIM NSR is enabled, PIM will build RDB entries for PIM states, including 
states for IGMP-only RDBs. IGMP-only RDB entries consume memory on both master 
and backup REs. The memory usage scales up when the number of customer streams 
is increased. Other than the memory usage and building the Pseudo-GMP RDB entries, 
there is no performance impact.


Tried with some code on MX960 (targeted platform for this feature) with 64K
downstream ifls and SG entries. This resulted in 

   64K * 3 * 100 = 19M

This did not cause any performance or memory related impact on the system.

5.1 PERFORMANCE RELATED RESOURCES

N/A

5.2 TARGET PERFORMANCE

N/A.

5.3 64-BIT KERNEL SUPPORT

N/A.


6. SCALING

The scaling numbers for number of downstream IFLs is 64K on MX 960 router.

7. MULTI-CORE ENVIRONMENT

N/A.


8. COMPATIBILITY ISSUES

None. This is a new feature.

9. HIGH AVAILABILITY (HA)

9.1 GRACEFUL RE SWITCHOVER (GRES), ISSU IMPACT

None.

9.2 NSR IMPACT

This RLI adds NSR support for IGMP-only-enabled interfaces 


10. LOGICAL SYSTEM / ROUTING INSTANCE IMPACT

None. 

12. PLATFORMS SUPPORTED

This change is platform independent.


13. SDK IMPACT
 
N/A.

13.1 SDK CUSTOMER USAGE

N/A.

14. JUNOS READY SOFTWARE CONSIDERATIONS

N/A.

15. FREE SOFTWARE CONSIDERATIONS

N/A.

16. 3RD PARTY SOFTWARE CONSIDERATIONS

N/A.

16.1 FUNCTIONAL ROLE OF 3RD PARTY CODE WITHIN JUNOS

N/A.

16.2 INTEGRATION DETAILS OF 3RD PARTY CODE WITHIN JUNOS

N/A.

17. POSIX NON-COMPLIANCE

N/A.

18. FUTURE CONSIDERATIONS

None known as yet.

19. REVIEW COMMENTS


19.1 REVIEW STAKEHOLDER MATRIX

Function			Name			Required?	Approval State
---------------------------------------------------------------------------------------------------------------
SW1 (kernel, RPD, PFE etc)				Yes/No/Optional Approved/Rejected/Approved with actions
SW2 (kernel, RPD, PFE etc)				Yes/No/Optional Approved/Rejected/Approved with actions
SW3 (kernel, RPD, PFE etc)				Yes/No/Optional Approved/Rejected/Approved with actions
SW Manager						Yes/No/Optional Approved/Rejected/Approved with actions
JAB							Yes/No/Optional Approved/Rejected/Approved with actions
HW							Yes/No/Optional Approved/Rejected/Approved with actions
---------------------------------------------------------------------------------------------------------------




 Copyright 2010 Juniper Networks, Inc. -- Proprietary and Confidential
Do not distribute outside of the company without the permission of Juniper Networks engineering
Printed copies are for reference only!
