			 RIP and RIPng NSR stateful replication 

-author: Antoine Klink
-email: antoine@juniper.net

Copyright (C) 2007, Juniper Networks, Inc.

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.

1.  INTRODUCTION
----------------
This document describes the functional specification for RIP and RIPng Non Stop
Routing (NSR) support which is beeing provided as part of the main NSR project.
Other protocols in JUNOS, like OSPF and ISIS, already have NSR stateful 
replication. Support for RIP and RIPng will be available as of 8.4 R1.

The NSR main specification [MAIN_SPEC] disucsses the motivation behind  NSR 
and how it improves on graceful-restart which is a currently available 
mechanism in JUNOS. Mainly, NSR aims at allowing faileover between the 
master RE and the secondary RE on a router without causing disturbance in the 
network (i.e without the peer routers noticing this faileover). 
Thus, for every  protocol specific state information needs to be replicated 
on the secondary RE so that when the switcheover happens the rpd on the 
secondary can keep up the flow of protocol-specifc messages to the peers. 

For RIP, a certain router A receives periodic UPDATE messages from its 
neighbors allowing him to keep the latest reachability information in his 
routing table. Router A will in turn propagate this info through his own 
UPDATE messages. Thus all UPDATE messages seen on the primary RE will have to 
be replicated on the secondary. This will allow the secondary to keep the 
same picture of the network as the primary and thus be able to take over
as soon as the switchover happens.
  
1.1. Tracking
-------------
RLI: 2725
Tracking PR: 71150
target release: 8.4 R1

2.FUNCTIONALITY
---------------
There won't be any new configuration knobs to enable NSR for RIP or RIPng. 
NSR is gloabally enabled at the routing-options configuration hierarchy.
The only visible knob introduced will be a new RIP traceoptions flag that 
will allow users to trace NSR related activity:

regress@pro4-a> show configuration protocols rip                 
traceoptions {
    file rip.log size 8m world-readable;
    flag update;
+   flag synchronization;
}
 
Note that all JUNOS CLI commands will be available on the secondary too. 

3. CAVEATS
----------
3 issues still need to be fixed in the context of this RLI. They are described
in:
-PR 96161: RIP can call jsr_split on the standby (upon reception or a primary 
handle) before replication is UP
-PR 96166: Configuration discrepancies between primary and standby (that can 
be originated by the user by mistake) not handled correctly 
-PR 96306: Sending RIP requests to nbrs right after calling jsr_replicate on 
primary fails

Also note that if some routes are expiring on the primary or they are 
already in holddown before replication comes UP they wont be seen on the 
standby in the same state once replication is ON. (please see test F in UTP
for more on this)
 
4. OTHER REQUIREMENTS
---------------------
N/A

5. IMPLEMENTATION DETAILS
-------------------------
The implementation is centered around the replication of the RIPv2 and RIPng 
IO sockets. Once replication is in place the standby RE will be
able to listen to the receive side of a replicated socket and thus "hear" 
the same UPDATES as the primary, leading the standby to have the same view of 
the network as the primary at the moment of a switchover.
For replication to be established, handles need to be sent from the primary RE 
to the backup RE and vice versa. In order to achieve that the mirroring API
is used in both directions.

5.1.Configuration
------------------
As mentioned in section 2 of this document NSR is configured at the 
routing-options level and thus no new configuration information needs to be 
processed at the RIP level. The RIP configuration on the standby should be
same as the one on the primary through the use of commit 'synchronize' and
it will be parsed in exactly the same way as on the primary. Note that the
implementation should be resilient to configuration differences between
primary and standby and this is discussed in the caveats section.

5.2.Initialization and function vector
--------------------------------------
As already discussed, the goal is to have the standby learn the 
same routes as the primary though listening to the replicated socket. 
However, the standby will not be advertising RIP UPDATES of its own and it 
also will not need to listen on the send side of a replicated socket (more on
this later). This implies that some RIP code paths on the primary will be 
different on the standby (most of the time not needed) and for that a 
function vector is kept and it will be initialized differently relative on the
primary and on the standby in the RIPv2 var_init routine. For example, 
nsr_rip2_io_socket_init (same applies to nsr_ripng_io_socket_init) is one 
such function  that is initialized to rip2_master_io_socket_init on the 
primary and to rip2_standby_io_socket_init on the standby with the latter just 
returning TRUE and the former being the code path in the original IO socket 
initialization for RIPV2 and that because the IO socket on the standby is 
not set until jsr_split is called as will be discussed later.
Similar functions  exist to take care of not setting the update timer on the 
standby as well as never triggering any UPDATES or REQUESTS to the nbrs on the 
standby. Also, nsr_rip_bfd_evaluate_peer makes sure that BFD RIP initialiation 
cannot happen on the standby; this is bound to change when BFD/NSR is
implemented. Also a nsr_rip_term_io_nsr_cleanup routine is part of the vector
to allow for both primary and standby to cleanup their NSR related stuff
when RIP is deactivated.
Note that the same config and init routines are invoked on primary and
standby.

5.3.Replication and Mirroring
-----------------------------
As mentioned earlier, socket replication handles need to be exchanged between
the primary and the standby for replication to work. This exchange is 
done over the mirroring API and for that a RIP mirror_registry_entry vector
(rip_mirror_handle_db_registry) is defined and registered with the 
infrastructure in rip_mirror_db_init which in turn is called from the 
var_init routines on initialization. Within the vector are defined the lock, 
unlock, encode, decode, getnext and clear_func routines which are necessary
for any client of the mirroring subsystem (for more info on those please refer
to [MIR_SUB_API]). Also note that the type of the mirror_registry_entry is
MIRROR_DB_BOTH to specify that data is mirrored both from the primary and from
the standby to the other RE.
A structure to be mirrored was also defined (rip_mirror_handle_s) to primarly
contain the replication handle of type jsr_handle_t (rmh_sr).

On the primary, the rip_mirror_handle to be mirrored is generated right after
initializing the IO socket (for RIPv2 or RIPng) in rip_nit_io_common and that
by calling rip_mirror_handle_create (mirror_add is called in that routine 
to add the node to the mirroring subsytem's queue). The jsr_handle (used for 
replication) won't be allocated until the primary gets invoked in the encode 
routine by the mirroring subsystem; at that point the primary calls jsr_alloc 
and encodes the whole structure that will be passed to the standby. Note that 
if socket replication is still not active (task_jsr_active is FALSE) at the 
time of caling rip_mirror_handle_create or when calling task_jsr_alloc in the 
encode subroutine, RIP will register a callabck (rip_jsr_active_cb_register) 
to get notified in the event of replication coming up through. At that point 
RIP will recreate the rip_mirror_handle and re-encode it for transmission.

Upon reception of the mirrored structure the standby will be invoked in its
decode subroutine by the mirroring API witha MIRROR_OP_ADD or MIRROR_OP_INIT 
operation and it will parse (rip_mirrror_handle_db_parse) and process 
(rip_standby_mirror_handle_process) the information. This consists of calling 
task_jsr_secondary_init (in turn invokes jsr_split) that will produce a 
receive side socket descriptor and a send side descriptor as well as a 
secondary jsr_handle. Nothing will be heard on the send side descriptor since 
the replication is already set to half duplex on the primary by calling 
task_jsr_set_half_duplex but; however the descriptor will be assigned to a 
temporary task (rip_replication_task) since it will be needed on switchover.
The receive side descriptor will be assigned to the standby IO 
task which will allow RIP on the standby to hear all UPDATES that the primary 
receives.

For replication to start, the standby jsr_handle still needs to be 
sent to the primary. Thus a standby rip_mirror_handle structure is created,
added to the mirroring subsytem and eventually encoded using the same 'create'
and 'encode' routines as on the primary. Once the primary receives the handle
structure it calls jsr_replicate to initiate replication. Note that right after
replication is ON for RIPv2 or RIPng, requests are sent for all nbrs in order
to get the standby to hear the UPDATES from them as soon as possible 
(not having to wait for the regular UPDATES) (please see caveats for an issue 
with this). Note that if at the moment of receiving these triggered UPDATES 
from the neighbors the interfaces over which RIP is running are not yet up
(it might take time for interfaces to come up on the standby once NSR is 
activated; the RIP neighbors are also down in that case) the UPDATE packets 
will be dropped and the standby will simply hear them again at the time the 
regular UPDATES are sent by the neighbors.

The clear_func routine is called on the standby in case the primary restarts
and vice versa and its purpose is to do the necessary cleanups (The standby 
for example will delete all its RIP routes, its rip_mirror_handles as well
as its replication task as the newly restarted primary will initiate a 
new 'replication handshake'). 

The getnext routine will be caled on the primary when the standby starts (NSR
is activated or the standby is restarted) for the purpose of resynching both
Re's. In the case of RIP all that needs to be synched up is the 
rip_mirror_handle structures for RIPv2 and RIPng if they exist.

Note that the getnext and clear_func (recvd_clear) routines are different 
on the primary and standby so they are part of the previously mentioned 
function vector. The same applies to a 'mirror_handle_process' function that 
is called from the 'decode' subroutine (which is the same for both RE's) and 
which takes car of 'processing' the rip_mirror_handle received from the other
RE.

5.4.Switchover
--------------  
On switchover a common routine for both RIPv2 and RIPng is called on the 
standby (rip_io_task_re_switchover_common). In this routine task_jsr_switchover
(which invokes jsr_merge) is called using the corresponding IO task and 
temporary replication task. This is followed by setting necessary options 
on the newly merged socket and also by cleaning up all the send state which 
will be recovered upon the RE becoming primary. In fact the new primary will 
go through a regular 'commit' process as primary which will allow it to 
have the correct funtion vector, start the update timers etc... This will allow
the new primary to pick up from where the old one left in terms of updating
the nbrs with the current view of the network.
Note that the primary will just restart as the new standby and the replication 
will come up through the same handshake process described above.


6. PERFORMANCE
--------------
N/A

6.1. Performance Related Resources
----------------------------------
N/A

6.2. Target Performance
-----------------------
N/A

7.  COMPATIBILITY ISSUES
------------------------
N/A

8. SECURITY ISSUES
-------------------
N/A

9. Graceful RE Switchover (GRES), Hobson Impact
-----------------------------------------------
N/A

10. NOTES
----------
N/A

11. GLOSSARY
------------
-NSR: Non Stop Routing

12. REVIEW COMMENTS
-------------------

13. REFERENCES
--------------
[MAIN_SPEC] - Non-Stop Routing (NSR) - Functional specification
sw-projects/os/nsr/software_spec.txt

[MIR_SUB_API] - Mirror subsystem API - Functional specification
sw-projects/os/nsr/mirror-subsystem-api.txt