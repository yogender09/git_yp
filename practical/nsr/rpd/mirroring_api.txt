$Id: mirroring_api.txt 

			Mirroring API [MAPI]
		  	 (Non Stop Routing)

		Author: Shivani Aggarwal, February 2007


Copyright Notice

   Copyright (C) 2007, Juniper Networks, Inc.

   NOTICE: This document contains proprietary and confidential
   information of Juniper Networks, Inc. and must not be distributed
   outside of the company without the permission of Juniper Networks
   engineering.



1. Introduction:
=================
This document covers the application visible interfaces of the mirroring
API used by RPD protocols today for Non-stop routing. This has been prepared
using the notes from Dave Katz on the mirroring api.

The intended audience are developers interested in using the mirroring api
infrastructure.



2. Overview:
============

2.1. What is the mirroring api?
-------------------------------
 
    It is a lightweight duplex data stream that is maintained per client.
It provides a seamless way for the client applications to replicate state 
between the 2 REs without having to deal with  primary<==>backup connection
issues.

    It is a state reducing queueing mechanism that supports add/modify/delete 
operations which may be acknowledged (optional).

    It also provides the optional capability, configurable per client, to  
automatically resync the backup RE if the backup RE restarts.

    The mirror subsystem supports multiple clients. Single protocol may use
multiple clients (e.g. one for each type of data structure to be 
replicated). The multiple clients do not interact. 

    The mirroring api maintains a single TCP connection between the 2 REs. 
This TCP connection is used to send and receive data for all clients.

    The data is limited to 0xfffc bytes per transfer. There is some 
infrastructure there for more.


2.2. When to use the Mirroring api?
-----------------------------------

    The mirroring api should be used when data needs to be replicated
between the 2 REs on the system.The mirroring api cannot provide replication
data between modules on the same RE, such as to a file or another daemon on
the same RE.

    The application of the mirrroring api is currently Non Stop Routing (NSR).
However, even for NSR, the mirroring api should be used judiciously since one
of the major goals for Non Stop Routing (NSR) is to not affect, as far as 
possible, the performance of the primary RE.

    The mirroring api use should be restricted to data that cannot be
inferred or learnt by the remote RE by any other optimal/efficient means.
This is not a pervasive copying system or a byte-for-byte replication system.

    Even though the mirroring api provides an acknowledgement capability 
from the backup, it must be used judiciously as this may impact performance, 
convergence, etc. For example: if the application on the primary waits for 
an acknowledgement from the backup before it can continue, this may have 
convergence or performance implications. However if correctness cannot be 
ensured on switchover, this might be an acceptable tradeoff.

    The mirroring api doesn't guarantee that all operations enqueued 
will be sent to the remote RE before switchover. In other words, if 
switchover happens while the mirroring api has pending operations 
enqueued, this state will not make it across and will be lost. This 
is an important limitation to consider for any application that uses
the mirroring api.



3. Mirroring API Usage:
=========================

This section provides information on how the applications can use the 
mirroring api.


3.1 Data Nodes:
---------------

    Client data is organized as data nodes. The node is simply a handle for
    state to be sent. It is usually embedded in the data structure containing
    the state to be replicated. 

    The data structure should also provide a way of locking the data structure.
    The mirroring subsystem performs locking and unlocking operations on
    this data structure through callback functions. The data structure 
    shouldn't be deleted unless all the locks on this data structure are 
    removed.

    If auto resync is enabled, these data nodes should be organized such that
    the get_next callback function can walk all the nodes (e.g. thread, tree,
    etc). The nodes need not be organized if auto resync is not enabled.


    Each data entry in the database may look like:

    /*
     * Mirror database entry.
     */
    struct mirror_data_entry {
        mirror_data_node mirror_node;   <== interface to mirroring subsystem.
        u_int32_t   refcount;  <== reference count on structure 
        thread  thread;  <== data node organized on a thread

        /* Information to be replicated */
        type1   field1;
        type2   field2;
        ...
        ...
    }


*****************************************************************************


3.2. Registration: mirror_register_data()
-----------------------------------------

    First and foremost the client application will need to register with the
    mirroring api it's database and the callback functions.

    Function declaration:
        void mirror_register_data(mirror_registry_entry *)

    The mirror_registry_entry contains the following fields and callback 
    functions that need to be filled out by the application registering 
    the database.

    mirror_registry_entry {
        1. mirror_db_type 		(Mandatory)
        2. mre_data_id			(Mandatory)
        3. mirror_donot_chunk_db_walk
        4. mirror_no_resync

        /* Callback functions */
        5. mirror_data_lock_func 	(Mandatory)
        6. mirror_data_unlock_func 	(Mandatory)
        7. mirror_data_encode_func 	(Mandatory)
        8. mirror_data_decode_func 	(Mandatory)

        9. mirror_data_get_next_func 	(Mandatory if mirror_no_resync FALSE)
	
        10. mirror_recvd_data_clear_func;
        11. mirror_connection_status_change_func;
        12. mirror_data_ack_func;
        13. mirror_init_sync_done_func;
    } 


    1. mirror_dbase_type mirror_db_type (mandatory)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    This is a mandatory field in the register datastructure.

    There are 3 types of databases supported by the mirroring api:
    1. MIRROR_DB_MASTER_TO_STANDBY: one-way; master sends data to standby
    2. MIRROR_DB_STANDBY_TO_MASTER: one-way; standby sends data to master
    3. MIRROR_DB_BOTH: 2-way; master and standby send data to each other

    The database registered should be one of these types. 


    2. byte mre_data_id (mandatory)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
        This is the unique identifier for the database that is registered. 
    This unique identifier must be defined in the enum variable: 
    mirror_data_ids.h::mirror_data_id

    All mirror operations on this database should reference this id. 


    3. boolean mirror_no_resync
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        If the backup restarts, all data in the mirror database is 
    automatically resynced to the backup. This is the default behavior. 
    To disable this feature, this field should be set to TRUE.


    4. boolean mirror_donot_chunk_db_walk
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        This should be set to TRUE if the client requires that during resync
    the mirror subsystem should process this table completely and not
    suspend in the middle. This should be used judiciously. 

    This is only relevant during resync operation.


    Callback functions:
    ^^^^^^^^^^^^^^^^^^^^


    5. mirror_data_lock_func (mandatory)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        This is a function pointer that the mirroring api uses to callback in 
    order to hold a lock to the data node.

    Function declaration:
        void mirror_data_lock_func (const mirror_data_node *mirror_node)


    6. mirror_data_unlock_func (mandatory)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        This is a function pointer that the mirroring api uses to callback
    into the client to unlock the data node.

    Function declaration:
        void mirror_data_unlock_func (const mirror_data_node *mirror_node)


    7. mirror_data_encode_func (mandatory)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        The mirroring api uses this function to callback into the client when
    the data referenced by the mirror node enqueued is ready to be sent to the 
    remote RE. The client can now encode the data referenced by the mirror_node
    in a TLV format. The tlv types must be defined by the client.

    Function declaration:
        int mirror_data_encode_func (const mirror_data_node *mir_data, 
                                     byte *buf,
                                     u_int32 bytes_left);

        mir_data: Data node for the data structure to be sent
        buf: Buffer to fill
        bytes_left:  Number of bytes left in the buffer

        Return values:
        a. length of the data packet (success)
        b. 0 if the data doesn't fit in the buffer (incomplete)
        c. -1 if the client decides not to send the data (abort)

               
     
    8. mirror_data_decode_func (mandatory)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        The client receives a callback into this function when data is received
    on the remote RE for this database through the mirroring api.

    Function declaration:
        void mirror_data_decode_func (const mirror_recvd_data *recvd_data)

        Pointer to data: recvd_data->mrd_data_ptr
        Length of data: recvd_data->mrd_recvd_len
 
    This tlvs in the recvd_data can then be extracted using
    rpc_proto_buffer_parse_tlvs(). 

    The operation code on the mirror data node is stored in 
    recvd_data->mrd_mirror_op. It can be accessed directly or by using the
    api: mirror_recvd_data_cur_op(recvd_data)

    Mirror data operation codes:
    a. MIRROR_OP_INIT: data node mirror auto resync operation.
    b. MIRROR_OP_ADD: data node mirror add operation
    c. MIRROR_OP_MOD: data node mirror update operation
    d. MIRROR_OP_DEL: data node mirror delete operation


    9. mirror_data_get_next_func (mandatory if auto resync enabled)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        When auto resync is enabled and if the backup restarts, the master RE 
    refreshes the backup with all the data in the database. The mirroring
    api uses this callback to access the next node in the database to mirror.
    This is a mandatory function in the register call if auto resync is not
    disabled.

    Function declaration:
        mirror_data_node *mirror_data_get_next_func(mirror_data_node *mir_data)

        Return the first node in the database if input mir_data is NULL.
        If mir_data != NULL, return the next node
        If mir_data is the last entry in the database, return NULL.


    10. mirror_recvd_data_clear_func
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        The mirroring api issues this call when the remote peer restarts. On 
    receiving this callback, the client should clear all the information it
    received for this database over the mirroring api. If no callback function 
    is registered, the client is not informed.

    Function declaration:
        void mirror_recvd_data_clear_func(void)


    11. mirror_connection_status_change_func
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        The mirroring api uses this callback to inform the client about changes
    in the connection state between the 2 REs. If no callback function is 
    registered, the client is not informed.

    Function declaration:
    void mirror_connection_status_change_func(mirror_connection_status status)

        status: Connection status

    Connection status types:
    a. MIRROR_CONN_DOWN: Connection went down
    b. MIRROR_CONN_READY: Connection came up
    c. MIRROR_CONN_NO_STANDBY: Looks like no standby (for now)


    12. mirror_data_ack_func
    ~~~~~~~~~~~~~~~~~~~~~~~~~
        The client should provide this callback function pointer in the
    register call if it is interested in receiving notification when the 
    remote peer receives the mirrored data.

    Function declaration:
        void mirror_data_ack_func (const mirror_data_node *mir_data,
                         	   mirror_ack_reason ack_reason)

        mir_data: Mirror entry acknowledged
        ack_reason: Reason for callback:
                    a. MIRROR_ACK ==> Real acknowledgement from far end
                    b. MIRROR_SHUTDOWN ==> Mirror pipe closed


    13. mirror_init_sync_done_func
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        The client should provide this callback function pointer in the 
    register call if it is interested in receiving notification when the auto
    resync operation is completed. 

    Function declaration:
	void mirror_init_sync_done_func(u_int32 resync_count, 
					boolean receive_side)

	resync_count: Number of entries synced
	receive_side: Callback for receive side or send side.


****************************************************************************

3.3 Mirror operations:
----------------------

The client may enqueue add, update and delete operations for the data nodes.

The mirror subsystem queues the request and locks the data node through
the registered callback for the database. When the mirror subsystem is
ready to process this request, the encode callback is invoked. The client
is responsible for encoding the data to be replicated as referenced by this
data node. The mirror subsystem takes the encoded packet and sends it 
across to the remote RE. If no acknowledgement was desired for this 
operation, the data node is dequeued and unlocked (using the registered 
callback). If the acknowledgement is requested, the data node is dequeued
and unlocked after the acknowledgement is received from the remote RE.

The infrastructure treats all operations the same as seen above. The 
add/update/del functions only matter to clients. The op code is provided to 
the client in the decode function callback parameter.

Client may repeatedly call add/update/delete on a node. If node is already
enqueued, the new call resets the entry to the new op code and moves it to
the end of queue. Hence, it follows that the remote peer should not expect
delete to always follow an add, for example.

Before any of the operations can be performed, the data node must be 
initialized.


3.3.1. Init operation: mirror_data_node_init()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This call initializes the mirror node and sets the database type 
    for this node. This needs to be done only once when the data node 
    is created.

    Function declaration:
	void mirror_data_node_init (mirror_data_node *node_ptr, byte data_id)

	node_ptr: Pointer to data node
	data_id: Database identifier to which the node belongs.



3.3.2. Add operation: mirror_add ()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       	The client uses this call to request a mirror add operation for the 
    data node. Since the data is encoded at send time, the replicated data 
    is always most recent.

    The remote peer receives this data node with the mirror operation code:
    MIRROR_OP_ADD

    Function declaration:
	mirror_op_result mirror_add(mirror_data_node *mir_data, 
				    boolean ack_request)

	mir_data: Data node to be replicated
	ack_request: TRUE if ack is desired 
	mirror_op_result: Result of this operation. Values listed below

    


3.3.3. Update operation: mirror_update()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       	The client uses this call to request an update operation for the
    data node.

    The remote peer receives this data node with the mirror operation code:
    MIRROR_OP_MOD

    Function declaration:
	mirror_op_result mirror_update (mirror_data_node *mir_data, 
					boolean ack_request)

	mir_data: Data node to be replicated
	ack_request: TRUE if ack is desired 
        mirror_op_result: Result of this operation. Values listed below



3.3.4. Delete operation: mirror_del()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	The client uses this call to request a delete operation for the
    data node.

    The remote peer receives this data node with the mirror operation code:
    MIRROR_OP_DEL

    Function declaration:
	mirror_op_result mirror_del(mirror_data_node *mir_data, 
				    boolean ack_request)

	mir_data: Data node to be replicated
	ack_request: TRUE if ack is desired 
        mirror_op_result: Result of this operation. Values listed below



3.3.5. Mirror operation result codes: mirror_op_result
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    The return value from the mirror add/delete/update routines.

    mirror_op_result values:
    a. MIR_RES_FAILURE ==> Operation failed
    b. MIR_RES_SUCCESS ==> Operation succeeded
    c. MIR_RES_ACK_PENDING ==> Operation succeeded, ack pending




For an example, look at src/juniper/usr.sbin/rpd/ldp/ldp_mirror.c


