- if configs are different on the Primary and Standby, Standby state
  can be maintained as follows:
    * one way is standby needs to hold on to everything snooped on the 
      wire and reconcile after switchover. standby doesn't look at its config
      prior switchover. bgp has scale issues doing this.
    * other way is to process config, and drop unwanted data. This has
      race conditions as Primary could be ahead. Standby would need to
      internaly "refresh" data from the Primary on every commit.
- there are many other race conditions to solve. Standby and Primary's config
  may not overlap at all.
- rt infra data structures (rib) cannot be used in standby to insert routes
  for which standby doesn't have instance configs due to mismatch.

- approach chosen is two fold:
    * make commit synchronize as mandatory
    * internal synchronization mechanism between primary and standby
      to synchronize bgp/rt infra data structures.

- what needs to be synchronized:
    * new instance addition: Standby needs to create instance and rib
      (rtt) data structures 
    * when new route-targets get added (addition of vrf instances or
      adding import route-targets to existing vrf instances) standby needs
      to update its route-target tree

    All the above needs to be done on the Standby before:
        - Primary sends out a route-refresh to build new rib-in state
        - Primary sends out updates from vrf tables to PE peers (builds
          rib-out state)

   Otherwise Standby will drop snooped rib-in and rib-out state

    * AUTO rd instances: rd-values are now constructed as : rdi + kernel-id
      For l2vpn instances (non-forwarding) that don't have a kernel table,
      Primary assigns a sync instance-id from an itable. This instance-id
      is mirrored to the Standby. Standby constructs the rd-value using this.
    * one advantage of using kernel-id is that it doesn't change during
      rpd restart (after crash). When GR is enabled, its helpful since 
      there's no change in PE routes send after the restart.

Handling multiple commits:
- There's no "ack" to the mgd from the applications telling they've processed
  a commit. During back-to-back commits we run into many race conditions
  due to Primary and Standby procesing commits at various speeds.
- A simple sequence-number check has been put in place such that rpd -c
  waits until the previous commit has been complete before returning to mgd.

Commit sequence:

    1. Primary process SIGHUP first. It process delete of instances. It also
       adds instances and marks the new RIBs as OUT_SYNC. Instance changes are
       also processed the same way as it is currently.
    2. sync instance-id is assigned for l2vpn instances and is mirrored to
       Standby.
    3. BGP defers processing route-target addition. It also defers adding
       the instance RIBs to PE peer-groups (other words, defers sending
       updates from the newly added instance RIBs to PE peers).
    4. Send primary_commit_done message to Standby.
    5. Standby waits for this message and SIGHUP before proceeding to process
       config.
    6. Standby processes the commit in the regular manner.
    7. Standby waits until kernel-id's are learnt for vrf auto-rd instances 
       to assign rd-values for those instances.
    8. Standby assigns rd-values from sync instance-id to l2vpn auto-rd
       instances.
    9. Sends Standby_commit_done message to Active.
    10. Primary resets the OUT-SYNC bit in the ribs.
    11. Primary rt-infra notifies registered applications about RIB becoming
        ready (rd-value is resolved and standby data structures created)
    12. BGP also processes route-target additions. It registers this rib for
        all PE peer-groups. We've deferred registering PE groups until 
        Standby has also created the RIB and hence deferred sending PE 
        updates automatically until the Standby is ready to snoop and insert 
        those updates into instance ribs.
    13. BGP route-refreshes if needed are sent out.
    14. L2vpn is also a registered application. Based on l2vpn/vpls instance
        becoming ready, it kick starts its state machine.
    15. Route-refresh messages are internally "acked" by the Standby. The
        Primary tracks the "ack" and sends a "route-refresh done" message to
        the Standby. Based on this, the Standby can figure out if a 
        route-refresh needs to be sent after a RE Switchover.

Other interesting notes

- When a instance gets deleted, the Standby also deletes the instance (node 
  is deleted from the instance tree). When Primary sends out withdraws, 
  Standby's RD-lookup fails. Thus, deleted instance needs to be tracked
  separately so that RD-lookup on the Standby succeeds and rib-out state can
  be updated.

- When all the PE peers flap (or deconfigured), l2vpn/vpls state on the
  Standby needs to be cleaned up as well. The state is built using snooped
  bgp advertisements. There won't be any withdraws in this case. To facilitate
  cleanup, bgp simulates "fake withdraws" by invoking the l2vpn callback.
  Thus l2vpn cleans up the label state and withdraws prefixes from the
  Standby instance ribs.

tracing
- enable hidden flag "commit synchronize" under "routing options" and
  "protocols bgp"
