$Id: ldp-nsr-implementation.txt,v 1.1 2007/03/13 01:29:52 shivania Exp $

	Design and Implementation specification for LDP support of NSR
	===============================================================
		Shivani Aggarwal (shivania@juniper.net)
		
		Copyright (C) 2005-2007, Juniper Networks, Inc.


NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.

DO NOT document the implementation details or share them with the
customer.

* Standby and secondary will be used interchangeably throughout the document.
* Primary and master will be used interchangeably throughout the document.

___________________________________________________________________________


INTRODUCTION:
=============
This feature is part of the NSR project. The LDP functionality is
tracked under 8.1 RLI 3168 tracking PR 65909 and 8.2 RLI 2721 (PR 73179). 

Before reading this document, it is recommended to read ldp functional 
specification [LDP_FUNCSPEC] and the documents referenced in it.

This document contains all the design and implementation details for the LDP
nsr design.

_____________________________________________________________________
 

TOPICS:
=======
1.  Overview
2.  Mirroring API
3.  Internal Routing Socket (IRS)
4.  JUNOS Replicated Socket (JSR)
5.  Next Hop Address Management
6.  Label Database Management
7.  Route Management
8.  Switchover
9.  Miscellaneous
10. Caveats
11. Troubleshooting
12. Appendix


______________________________________________________________________


1. Overview:
==============

There are 3 channels over which the secondary RE receives information from
the primary RE. 
1. Mirroring API:
   Mainly used to sync:
   a. adjacency information for the sessions;
   b. informing the secondary about operational ready-to-sync sessions 
   c. self-ids for the ingress and transit routes associated with an out label
2. Internal Routing Socket (IRS):
   Mainly used for initial sync of the sessions
3. Junos Replicated Socket (JSR) per session.
   Used to snoop on the inbound and outbound control traffic on the socket.

The secondary uses the information that it receives over these 3 channels
along with the IGP routes to create LDP routes on the secondary.

The following sections describe in detail:
1. Sending sync information from the primary to the secondary
2. Processing of the above information on the secondary
3. Switchover

_______________________________________________________________________

1. Mirroring API: 
==================

The primary via the mirroring api keeps the secondary updated on what 
adjacencies and sessions are up on  the primary via the adjacency database 
and session database. Primary also informs the secondary about the self-ids
associated with each outgoing label. This is useful for getting statistics 
from the kernel. There is a single database per information type (adj, 
session and label) for all instances.


a. Adjacency database
~~~~~~~~~~~~~~~~~~~~~        
The primary always keeps the secondary informed about it's active adjacencies.
Each entry in the database is of type ldp_mirror_adj. This structure contains
the instance kernel routing table index, interface information (index and 
name), neighbor address, last hello packet, as well as how long this adjacency
has been up on the primary (primary_adj_uptime). The instance routing table 
index, interface index and the neighbor address form the key for the lookup.

When the secondary receives this adjacency add notification, it records the 
time when it received this notification. This, along with the 
primary_adj_uptime information, is useful in determining how long this 
adjacency has been up on the primary.  

It then tries to activate the adjacency on the secondary LDP as well.

The secondary might not be able to do so if the interface is not yet available
or belongs to a different instance than the one on the primary [Note this can 
happen if the secondary is a little behind in processing interface instance 
change notification or the primary has not updated the database with the right
instance for the adjacency].

If the adjacency cannot be established at this time because the interface is 
unavailable, the adjacency will be activated when the interface becomes 
available.

If the adjacency is successfully activated, the ldp_adj structure is created
and linked to the ldp_mirror_adj structure. The ldp_session structure is also
created at this time. At this time, session mirror database (discussed below)
is consulted to see if we have received notification about this session being
ready for sync. If so, this session is marked ready for sync by adding it to
the request sync thread. [Processing of this thread is discussed later]


b. Session database
~~~~~~~~~~~~~~~~~~~~
The primary keeps the secondary informed about the sessions that are in 
operational mode [Established] via the mirror session database. Each entry
in the database is of type ldp_mirror_session. This structure contains 
the instance routing table index, remote end's ldp identifier 
(session_rmt_identifier), session uptime, primary's JSR handle 
[More details on this later] and the initialization message received from 
the peer. The instance routing table index and the session identifier form
the key for the lookup.

Note if the primary is not able to allocate the JSR handle or if the session
is in graceful restart, this session will not be added to the mirror database
and the secondary will not know about this session.

When the secondary receives this session add notification, it records the time
when it received this notification. This, along with the session uptime, is 
useful in determining how long this session has been up on the primary.  

The secondary then looks for a corresponding ldp_session structure for this 
mirrored session. If it exists, the session is ready for sync. In other words,
the secondary can now request the session sync from the primary. The 
secondary, at this point, enqueues the session to the request sync list 
maintained on the secondary. [Processing of this list will be discussed under
section: TCP connection over the IRS].

If the corresponding ldp_session structure is not found, this implies that no
adjacency is currently active on the session. When the first adjacency for 
this session gets activated, the session is enqueued onto the request sync 
list. [Details on adjacency activation in the earlier sub-section].


c. Nexus database
~~~~~~~~~~~~~~~~
The primary also sends the label to self-id (ingress and transit) mapping to 
the secondary over the mirroring api. This is useful on the secondary to be 
able to gather next hop statistics for the ingress and transit route 
associated with the nexus for this outgoing label. Each entry in the database
is of type ldp_mirror_nexus. This structure contains the instance routing 
table index, label, ingress selfID and transit selfID. The instance and the 
label form the key for the lookup. 

When a nexus is removed from the database, the secondary is updated.

The secondary looks for a nexus that matches the label for this mirror'ed
entry and it exists, it associates itself with the nexus and the routes 
associated with the nexus are updated.


__________________________________________________________________________


2. Internal Routing Socket (IRS):
=================================

Once the secondary is up, the LDP protocol on the secondary establishes a TCP
connection with the LDP protocol on the primary over the internal routing
socket. This TCP connection is mainly used to relay initial sync information
per session from the primary to the secondary.

Initial sync:
-------------------
Since the secondary may come up at a later time than the primary, the secondary
needs to be informed about all the earlier state (labels and nexthop addresses)
that the primary has received or sent before the secondary was up. This is
because the LDP session is a TCP based session and the next hop addresses and
labels exchanged over the session will not be sent on the session again. This
is the initial sync period for the session when the primary tells the secondary
about all the information already exchanged on the session.

After the initial sync period is done, no information for this session needs to
be relayed over this TCP connection on the IRS. Note there is only one TCP 
connection set up over the internal routing socket for all instances. 

If and when the TCP connection between the LDP protocol on the primary and 
secondary is established, the request sync list is processed. [Refer to section
"Mirroring API: Session Database" for details on when the sessions are enqueued
on request sync list].

LDP Sync Messages
~~~~~~~~~~~~~~~~~
Following are the messages exchanged over the IRS for a session during the 
session's initial sync phase.
  i.   Session sync request message [LDP_RSYNC_SESSION_REQ_MSG]
  ii.  Session start message  [LDP_RSYNC_SESSION_START_MSG]
  iii. Session local nexthop address message [LDP_RSYNC_SESSION_ADDR_IN_MSG]
  iv.  Session remote nexthop address message [LDP_RSYNC_SESSION_ADDR_OUT_MSG]
  v.   Session inlib label  information message [LDP_RSYNC_SESSION_INLIB_MSG]
  vi.  Session outlib label information message [LDP_RSYNC_SESSION_OUTLIB_MSG]
  vii. Session complete message [LDP_RSYNC_SESSION_COMPLETE_MSG]
  viii.Session error message [LDP_RSYNC_SESSION_ERROR_MSG]

Please refer to the Appendix for the message formats.


Session Initial Sync preparation:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The secondary asks for initial sync for sessions on this list, _one_ session
at a time. The top of the queue will be the session that the secondary will
try to sync. 

The secondary will now create the ldp_connection structure and link it to the 
session. The ldp connection structure handles the inbound traffic on the 
session on the replicated socket. It will also create the ldp_standby_session
structure and link it to the session. The ldp_standby_session structure handles
the outbound traffic on the session over the replicated socket.

Secondary will then try to create the secondary JSR handle (jsr_split) using 
the primary's JSR handle for this session received over the mirroring api. 
This secondary handle is needed on the primary to be able to replicate the 
TCP socket associated with the session [More details on this later]. Creating
the secondary JSR handle provides the secondary with 2 file descriptors.  
Once the socket is successfully replicated on the primary [when this happens 
will be discussed later], one file descriptor will point to the socket that
gets the replicated inbound traffic on this session and the second file 
descriptor will point to the socket that gets the replicated outbound traffic
on this session.

The secondary now processes the initialization message, present in the mirror
session entry, and marks the session operational.

If, for any reason, the above initialization of the session fails, the session
will be removed from the request sync list and will be added onto the unsync
list. The sessions on the unsync list will be added to the request sync list
after a short wait (10secs), to be retried again for initial sync.

If the initialization is successful, the secondary sends the session sync
request message to the primary for this session. The session sync request 
message also contains the secondary's JSR handle. This session is now in 
initial sync mode on the secondary.

Primary receives Session sync request message:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The primary on receiving this message makes sure that it doesn't have any 
other session sync request pending. If it does, it will terminate initial
sync on the previous session, send an error for the previous session and
process this latest request.

Primary then tries to replicate the TCP socket associated with this session.
[More details below in the sub-section: TCP replication]. If, the 
TCP replication fails, the primary sends back an error message to the 
secondary. Details on the api used to achieve socket replication is in the
document [SOCK_REPL_API].

If the TCP replication is successful, the secondary will now start receiving 
data (inbound and outbound traffic) on the 2 sockets that it created earlier.
The primary will also start sending initial sync data to the secondary over 
the IRS. The secondary at this point will receive label and next hop data for
this session over the JSR and the IRS. [Rules for processing these messages 
received simultaneously over the JSR and IRS will be discussed later].

Once the primary is done sending all the information over the secondary, it 
indicates this to the secondary by sending the session sync complete message.
The secondary on receiving this message will quit initial sync mode and enter
into ongoing sync. This means that the session will now receive label and 
nexthop information only over the JSR. At this point, the primary and the
secondary must be in sync with respect to the labels and next-hop addresses 
received and sent over the session. Any new label/next-hop exchange, withdraw
will be seen by the secondary over the 2 replicated sockets. The session will 
now be taken off the request sync queue and the next session in the queue will
be tried for initial sync. 

If the primary or the secondary, at any point, during initial sync encounters
an error with respect to the session being sync'ed, or if the session closes,
the session error message will be sent from the entity that encountered the 
error and the initial sync for that session will be aborted. This will also
result in all the state for that session on the secondary to be flushed.
The session will be put onto the unsync queue if this session can be sync'ed
[adjacency and the mirror_session for this session exists]. Secondary starts
the sync timer if there are more sessions enqueued on the sync request list. 
This timer on timeout (50ms) processes the sync request list and sends a 
request to the primary for the next session in queue.

After receiving the session sync request message, the following messages 
are sent to the secondary in the following order:
i.  Session start message  [LDP_RSYNC_SESSION_START_MSG]
    This is the first message sent by the primary to the secondary when it
    receives the session sync request message. The secondary on receiving
    this message knows now that the initial sync for this session is starting.

ii. Session local nexthop address message [LDP_RSYNC_SESSION_ADDR_IN_MSG]
    The primary then tells the secondary about the next hop addresses that
    it has advertised to the secondary. The secondary will only receive
    address that are active on the peer. The rest of the address messages,
    such as new addresses added or old addresses withdrawn, the secondary
    will read on the replicated socket.

iii.Session remote nexthop address message [LDP_RSYNC_SESSION_ADDR_OUT_MSG]
    The primary then tells the secondary about the next hop addresses that it
    has received from the peer. Again the secondary will only receive
    addresses active on the primary.  

iv. Session inlib label  information message [LDP_RSYNC_SESSION_INLIB_MSG]

    The primary then tells the secondary about the label map messages that
    it has received from the peer. 

    Since some of the bindings might be in RELSEND state becuae of withdraw
    messages received before the socket was replicated, and we don't want
    the secondary to see these releases, the socket is replicated only after
    we are done sending these pending releases.

    Now it can be guaranteed that the secondary will see withdraw messages
    on the replicated socket for any inlib bindings that the primary will
    send a release for. This is necessary for determining when the binding
    is no longer active and can be released on the secondary. [More details
    on this later].

    The primary will send label map messages for any binding in ACTIVE or
    RELSEND state (since the secondary will see a withdraw for this binding). 


v.  Session outlib label information message [LDP_RSYNC_SESSION_OUTLIB_MSG]

    The primary then tells the secondary about the label map messages that
    it has sent to the peer. Any binding in ACTIVE or WDSEND state will be
    sent as a label map to the secondary. When the primary finally sends the 
    withdraw, the secondary will receive it over the replicated socket.

    The primary also informs the standby about bindings in RELRCV state or
    RELRCV_RESEND state. This is so that if switchover occurs, the standby
    knows to expect these releases and not get confused.


vi. Session complete message [LDP_RSYNC_SESSION_COMPLETE_MSG]

    The primary finally marks the session sync done and sends the sync 
    complete message to the secondary. 
   
    The secondary on seeing this message, walks all the relevant data
    structures on the session and removes negative state maintained during 
    initial sync. It then marks the session as out of initial sync and expects
    to receive data only over the JSR. 

    The secondary will close the session if it receives data over the IRS for
    this session after initial sync is complete.
  
    The secondary then restarts the sync timer (50ms) that processes the 
    sync request list.


TCP replication:
~~~~~~~~~~~~~~~~~~~
Before the socket may be replicated, the primary needs to do 2 things:
1. It needs to make sure that the socket is at a record boundary for both 
read and write buffers. This is because the kernel will replicate all the 
data on the read and write buffer and if only part of the message was read
or written, then the secondary might end up reading the outbound or inbound
traffic in the middle of a message which may confuse the secondary. 
2. The primary also sends out all the pending release messages on the inlib
before the replicating the socket. Why this is done will be discussed later.
If the primary is not able to send all the release messages enqueued on the
session within 10secs, the initial sync for the session is aborted and an 
error message sent to the secondary.



___________________________________________________________________________


3. JUNOS Replication Socket:
============================

a. Inbound
    On the inbound socket, the secondary receives all data that the neighbor
has sent over this session. The LDP messages that the secondary is interested
in is: LDP address messages, LDP label messages and notification messages.

b. Outbound
   On the outbound socket, the secondary receives all data that the primary
has sent over this session. The LDP messages that the secondary is interested
in is: LDP address messages, LDP label messages and notification messages.

The secondary after finishing initial sync for a session will receive data
for that session only over the JSR. 

During initial sync mode, we receive address messages over the IRS and the
JSR. Messages received over the JSR will be considered most recent and will
override any messages received over the IRS. If a message is received over 
the JSR and then over the IRS, the message over the IRS will be ignored.
During initial sync mode, the standby maintains negative information. This
means that if a message over the JSR results in the data structure having 
to be released, the release of the data structure is postponed till the 
initial sync for the session is over. This is to ensure that any message for
this data structure over the IRS can be ignored. 

After initial sync for a session is complete, the label and the next hop
data structures are inspected and released if there are in deleted state.


___________________________________________________________________________


4. Next hop Address Management:
=================================

The secondary will receive inbound and outbound next hop address messages for
this session over the IRS (during initial sync) and over the JSR. These
messages are encoded as standard LDP Address messages.

The inbound next hop addresses informs the secondary the next hop addresses
that the neighbor has advertised over this session.

The outbound next hop addresses informs the secondary the next hop addresses
that the primary has advertised to the neighbor over this session.

During initial sync mode, we receive address messages over the IRS and the
JSR. Only address adds will be received over the IRS. On the JSR, we may
receive address add and address withdraw messages.

A. Inbound next hop address management:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

a. Address Add message
   This message may be received over the JSR or the IRS. The message will be
   processed the same way as it is done on the primary. The new session next
   hop is add to the session next hop list and the relevant routes updated.

b. Address Withdraw message
   This message will only be received over the JSR. This message will be 
   processed the same way as it is done on the primary. The session next 
   hop is removed from the session reference and the relevant routes updated.


B. Outbound next hop address management:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The outbound next hop addresses add and withdraw to be sent were maintained
on a thread on the session (ldp_ses_addr_xmit_thread). This thread has been
changed to a tree (hbt) for faster lookups on the standby.

The standby session structure keeps a tree (lss_addr_xmit_queue) of all 
addresses that the primary has sent to the peer.

a. Address add message
   This adds the address to the tree.

b. Address withdraw message
   Removes the address from the tree.


__________________________________________________________________________


5. Label Database Management: 
==================================

The secondary will receive inbound and outbound label messages for this 
session over the IRS (during initial sync) and over the JSR. Over the IRS,
the secondary will receive only the label map message type.

The inbound label messages are the messages received from the neighbor over
this session.

The outbound label messages are the messages that the primary has sent to 
the neighbor over this session.

These inbound and outbound messages help the secondary in creating the inlib
and outlib for the session. The inlib and outlib contains all the bindings
(label->FEC mappings) and the state of these bindings. 

Inbound label map, inbound label withdraw and outbound label release help the
secondary in manipulating the inlib of the session to keep it current with
the primary.

Outbound label map, outbound label withdraw and inbound label release help the
secondary in manipulating the outlib of the session to keep it current with 
the primary.


A. InLIB management:
~~~~~~~~~~~~~~~~~~~~~~~

The neighbor sends a label map message when it wants to advertise "label->FEC"
mappings. It sends a label withdraw message when it wants to withdraw the 
advertised mapping. The primary on receiving the withdraw message for a 
mapping sends a release to the neighbor for this mapping. This informs the 
neighbor that this mapping is no longer in use. 

It can be determined that a withdraw message will always follow a map message.
A release message may be sent in response to a map message 
(unsolicited release) or in response to a withdraw message 
(solicited release). For now, ignoring unsolicited releases since Juniper LDP
implementation sends unsolicited releases in only a few easily identified
cases. Unsolicited releases, inbound and outbound, will be discussed in a 
separate section later.

So for a binding, the messages are always in the following order:
inbound map ---> inbound withdraw ---> outbound release

On the secondary we may not read these messages in the same order since the
secondary reads the inbound map and the inbound withdraw on the inbound socket
and the outbound release on the outbound socket. This implies that the 
withdraw will always follow the map message since it is read from the same
socket. However, the secondary may read the release before the map and/or
withdraw message for the binding. 

So for a binding, the messages might be read in the following orders:
i.   outbound release, inbound map, inbound withdraw
ii.  inbound map, outbound release, inbound withdraw
iii. inbound map, inbound withdraw, outbound release   (correct order)

The secondary will need to determine the final correct state of the binding
when these messages are received out of order. 

In order to determine the final state of the binding, a ldp_standby_binding
structure is associated with the binding on the secondary. This structure
maintains a count of map (map_c) and release messages (rel_c) received for
a binding. For every inbound map received, the map_c counter is incremented
and for every outbound release received for this binding, the rel_c counter
is incremented. For every inbound withdraw message received for this binding,
the map_c and rel_c counter is decremented. When the number of inbound map 
and outbound release messages become zero, this binding is no longer 
functional and can be removed from the inlib of this session. Details on 
how these label messages are processed on the secondary are described
below.

There may be multiple bindings associated with a prefix. The secondary may
have read multiple map, withdraw messages for the same prefix but haven't
read the releases on the outbound socket for these bindings yet. Hence these
bindings haven't been released yet. But only one active binding should be 
present on the prefix. 


Q. Why do we need to send all the pending outbound releases before the 
socket can be replicated?
When the socket is replicated, the primary may have some outbound release
messages enqueued to be sent due to withdraws that it had learnt earlier.
So the secondary may end up seeing only releases for this binding over the 
JSR but no map/withdraw message for this binding over the IRS or JSR. This
will result in the count of the release message for this binding to be off by
one. We rely on this counter to determine when the binding can be finally
released. In order to get around this issue, before the socket for a session
is replicated, the primary stops reading from the socket when it reaches a 
record boundary on the read socket and then sends out all releases enqueued
for this session. This guarantees that the secondary will not see these stray
releases.


Processing Inbound Label Map Message:
-------------------------------------
If a label map is received and the secondary doesn't have a binding for this
map yet, a new binding is created and the state of this binding is set to 
ACTIVE. Note, this must be the only active binding on the prefix since we 
don't support non-merging mode. [The primary responds to such a label map
where there is already an active binding for the prefix with a different label
by sending an unsolicited release for the binding].

A binding for this label map may already exist. The binding may be in 
ACTIVE or RELSEND state or NEW state. 

If the binding already exists and this label map was received over the IRS,
this label map message is ignored since we have already received more 
up-to-date information over the JSR for this binding.

If the binding is in ACTIVE state, this label map is an update to the 
previous map.
If the binding is in RELSEND state, the last message on the inbound socket
was a withdraw message and this binding is yet to be released 
[The binding may not have been released either because the secondary hasn't
read the sufficient number of release messages for this binding on the 
inbound socket (map_c > rel_c) or the secondary has read too many release
messages for this binding (rel_c > map_c)].
If the binding is in NEW state, the secondary has only read releases for 
this binding.

The secondary moves this binding to the head of the prefix binding list and
sets the state of the binding to ACTIVE. The map_c counter for this binding
is incremented.
 
A inbound label map message signifies a potential nexthop label for a FEC.
[Potential because some sessions may advertise labels for FECs that is not
the best IGP next-hop for that FEC]. The route associated with this binding
needs to now be updated with this new label if this is a nexthop for this 
FEC. [More details later on how this is done].


Procesing Inbound Label Withdraw Message:
-----------------------------------------
The processing of inbound label withdraw message differs when the session is
in initial sync mode and when it is in ongoing sync.

When the session is in ongoing sync mode:
If a label withdraw is received, the secondary must have an ACTIVE binding 
for this prefix. The binding must be in ACTIVE state since a withdraw message
always follows a map message. The state of the binding is set to RELSEND and
the map_c and rel_c counters are decremented. If (map_c == rel_c == 0), this 
binding can now be released.

The route associated with this FEC has to be updated since this label is no
longer the next hop for this FEC. [More details later on how this is done].


When the session is in initial sync mode:
The secondary may see withdraw for bindings on the replicated socket 
that it hasn't learnt about during initial sync. This can happen because
the secondary may have read the withdraw over the JSR before the primary
was able to send the map message for this binding over the IRS.  When the
secondary sees a withdraw for a binding for which it hasn't seen a map 
message yet during initial sync mode, it assumes that the map message was 
already received for this binding and processes the withdraw by first faking
a receipt of a map message and then processing this withdraw. 

The state of the binding is set to RELSEND and the map_c and rel_c counters
are decremented. When (map_c == rel_c == 0), this binding is not released
during initial sync. This is to prevent accepting any label map messages over
the IRS for this binding.
 
Once the initial sync for the session is over, all the inlib bindings for
this session are revisited and any bindings with (map_c == rel_c == 0) are
finally released.


Wildcard withdraws:
___________________
Wildcard withdraws may be received on the replicated socket for inlib bindings.
For now, we will close the session on the secondary when the primary receives 
wildcard withdraws.



Processing Outbound Label Release Message:
-------------------------------------------
If a label release message is received for a binding that doesn't exist, a 
new binding is created and the rel_c counter incremented. The state of this
binding is set to NEW.

If the binding already exists, it may be in ACTIVE, RELSEND or NEW state.
If the binding is in ACTIVE state, the last message read on the inbound
socket for this binding was a map message. The secondary simply increments
the rel_c counter in this case.
If the binding is in RELSEND state, the last message read on the inbound
socket for this binding was a withdraw message. The secondary increments
the rel_c counter. If (map_c == rel_c == 0), the binding is released if the
session is not in initial sync mode. [Why we do this is explained in the 
earlier section: processing inbound label withdraw message].

If the binding is in NEW state, the secondary hasn't read any message for
this binding on the inbound socket but it has read a release message on 
the outbound socket for this binding. The secondary again in this case 
simply increments the rel_c counter.

Unsolicited Releases:
_____________________
The above algorithm doesn't take into account unsolicited releases.
[Please see Caveats: 1]


B. OutLIB management:
~~~~~~~~~~~~~~~~~~~~~~~~~~~
The primary sends a label map message to the neighbor when it wants to 
advertise "label->FEC" mappings. It sends a label withdraw message when it
wants to withdraw the advertised mapping. The neighbor on receiving the 
withdraw message for a mapping sends a release to the primary for this 
mapping. This informs the primary that this mapping is no longer in use. 

It can be determined that a withdraw message will always follow a map message.
A release message may be sent in response to a map message (unsolicited 
release) or in response to a withdraw message (solicited release).

So for a binding, the messages are always in the following order:
outbound map ---> outbound withdraw ---> inbound release

The secondary may not read these messages in the same order as they have 
been sent since the secondary reads the outbound map and the outbound 
withdraw on the outbound socket and the inbound release on the inbound 
socket. This implies that the withdraw will always follow the map message
since it is read from the same socket. However, the secondary may read the
release before the map and/or withdraw message. 

Also the primary may receive unsolicited releases. Hence a withdraw message
will not be seen by the secondary for a binding at all. The secondary needs
to deal with these unsolicited releases for the outlib since sending the 
unsolicited release cannot be controlled by the primary.

So for a binding, the messages might be read in the following orders:
Solicited release:
inbound release, outbound map, outbound withdraw
outbound map, inbound release, outbound withdraw
outbound map, outbound withdraw, inbound release   (correct order)

Unsolicited release:
inbound release, outbound map
outbound map, inbound release (correct order)

The secondary will need to determine the final state of the binding when 
these messages are received out of order. 

The secondary will ignore all releases seen on the inbound socket. 
If the last message received on the outbound socket is a map message, the
state of the binding will be assumed to be ACTIVE. However, the neighbor may
have sent an unsolicited release that the secondary has ignored, so the
binding may not really be ACTIVE on the primary. This is important only 
after switchover and will be dealt with at that point.

If the last message received on the outbound socket is a withdraw message,
the state of the binding will be RELRCV. However, the neighbor may have 
already sent the solicited release that the secondary has ignored, so the
binding on the primary might already have been released while on the
secondary this binding would be in RELRCV state.

The time when the last message was received for a binding is stored in the 
ldp_standby_binding structure.

Processing Outbound Label Map Message:
---------------------------------------
The secondary on seeing an outbound label map message creates a binding
if it doesn't exist. If it exists and this message is seen over the IRS,
the label map is ignored. Else the binding state it set to ACTIVE and the
binding activated [See route management for more details on this]. The map
counter on the binding is incremented.

The primary will never send a new map message for a FEC unless it has 
received an unsolicited release for the earlier map on the FEC. The 
secondary, therefore, on seeing a new map message for a FEC (new binding)
on the outbound socket, can safely assume that an unsolicited release was
received for the previous bindings in ACTIVE state for this FEC and hence
can release the previous bindings that are in ACTIVE state. Note the bindings
in RELRCV mode cannot be released since we might not have received the 
releases from the neighbor for these bindings.


Processing Outbound Label Withdraw Message:
--------------------------------------------
The secondary on seeing an outbound label withdraw message sets the state
of the binding to RELRCV and deactivates the binding. [See route management
for more details].


Processing Inbound Label Release Message:
------------------------------------------
The release counter on the binding is incremented. This is useful during
switchover. Other than that, the release messages have no impact.

Since the Release messages are being ignored on the standby for the outlib
bindings, these outlib bindings in RELRCV mode cannot be released unless
we know for sure that the primary has indeed received a release for these
bindings. This is needed for after switchover, since we may need to wait on 
some releases. However, since the releases are ignored, this database
of RELRCV bindings is not cleared and can potentially grow out of bounds.
For this reason, the bindings are instead timed out on the standby. Any 
binding in RELRCV mode for more than 60secs are timed out and released.
This helps to keep the database within bounds.

__________________________________________________________________________

6. ROUTE MANAGEMENT: 
============================


ldp_standby_ data structures:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For every inet FEC that we receive an outbound label map, a ldp_standby_route
structure is created. This helps in keeping track of what FECs the primary
has advertised an out-label for.

Since we may be reading out-labels for a FEC on different sessions at 
different times, we might hear of multiple different out labels for the same
FEC. In order to keep track of these different labels, ldp_standby_nexus_ref
is created for each out-label learnt for this FEC. These ldp_standby_nexus_ref
structures are threaded onto the ldp_standby_route structure.

Each of these ldp_standby_nexus_ref point to a ldp_standby_nexus structure.
The ldp_standby_nexus structure embeds within it the ldp_nexus structure
which contains details about the global label, transit route associated
with this nexus, ingress and transit selfids, ldp_mirror_nexus and the 
tree of out-labels identifying the sessions that are advertising this 
out-label.

If a ldp_route_entry for this FEC exists in the shadow routing table, 
it can be linked with this ldp_nexus structure if:
1.  the ldp_nexus is attached to the ldp_nexus_mirror_nexus received 
    over the mirroring api 
2.  the ldp_label_vector can be created if this route is not egress.

Multiple routes, ldp_route_entry structures, may be attached to the same 
ldp_nexus since we may send the same label for multiple FECs that share 
the same nexthop, ldp_label_vector structure.

In the current implementation, ldp_nexus structure supports only one 
ldp_label_vector. On the standby we would need multiple ldp_label_vector 
to be supported. This is because, reading data in different order may result
in having a need to associate different ldp_label_vector structures with the
same ldp_nexus. 

For example, we just read the withdraw for a label map before we read the 
new out-label for this FEC. The withdraw for this label-map may result in 
a new ldp_label_vector for the old outgoing label. But we cannot create a 
new nexus since we have not read the new outgoing label and the old nexus 
cannot yet be changed since there might other FECs associated with the old
label vector and the old outgoing label.

To support this, ldp_standby_nexus structure is introduced.
All routes pointing to the same label use the same label_vector set. If a 
route's nxref is removed from a nexus, the nexus's inlib vector is revisited
at this point and updated if necessary using the route at the head of 
it's nxref tree.

On switchover, all the routes will be re-evaluated and new labels will be 
allocated for routes that don't match the inlib set for the nexus they are 
attached to.


Events that manipulate these structures:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Before a route (ldp_route_entry) can be linked with a nexus (ldp_nexus via 
the ldp_nexus_ref), the following conditions must be met. Once the route is 
successfully linked with a nexus, the ingress and transit route for that 
prefix can be installed. One transit route is installed for all routes 
associated with the nexus and is maintained off the ldp_nexus structure. 
There is one ingress route installed for each ldp_route_entry associated with
the nexus. This ingress route is stored in the ldp_nexus_ref structure.

The conditions to be met on the standby before route can be associated with
the nexus:
1. There must be a route for this prefix in the shadow routing table 
   (ldp_route_entry must exist)
2. There must be a standby_route structure for this prefix 
   (outgoing label exists)
3. If not egress, then there must be a ldp_label_vector for this prefix
   (inlib labels exist)
4. The nexus for the outgoing label must be associated with it's mirror
   (ldp_mirror_nexus).


The following different events alters the state machine:
a. new outlib binding
This implies a new label for this prefix. The new label is added to the 
standby_nxref thread on the standby_route (create it if not present) and
the route re-evaluated and bound to this label if possible.

b. new inlib binding
This implies a new next hop for this prefix. If the standby_route exists 
for this prefix, the route is re-evaluated and updated with the new next 
hop label vector (if it is different).

Since many routes may be associated with the same nexus (same outgoing label),
the next hop label vector may be different for each route. However, the plan
is to update the nexus inlib label reference with the last change to any 
route in it's nexus ref tree.

c. outlib binding withdrawn:
This implies that the previous advertised label for this prefix is withdrawn.
This is no longer the label for this prefix (at least on the current session).
The reference count on the standby_nexus_ref is decremented. If this goes to
zero, no session is advertising this label for this prefix. The nexus can now
be disassociated/unbound from this prefix.

d. inlib binding withdrawn:
This implies next hop delete for this prefix. If the standby_route exists, 
the route is re-evaluated and updated with the new next hop label vector (if
it is different). If the new label vector is NULL, the route currently has no
label next hops. The route is then removed/unbound from the nexus.

e. mirror nexus add
When a mirror nexus is  added and there is a nexus that it can be associated 
with, then all the standby_routes associated with the standby_nexus for this
nexus need to be re-evaluated and the routes installed. 

f. mirror nexus delete
When a mirror nexus is deleted and there is a nexus associated with it, then 
all the routes associated with the nexus need to be unbound. This ends up 
freeing up all the nodes on the nexus ref tree of the nexus, basically 
unbinding all the routes from this nexus.

g. session next hop address add
This binds a next hop for a route to a session. All the routes that are bound
to this next hop potentially have a new label next hop. All these routes next
hop label vector has changed as a consequence and need to be re-evaluated.

h. session next hop address delete
This unbinds a next hop for a route from the session. All the routes that are
bound to this next hop now no longer have a session and hence the label 
associated with this next hop is no longer available to this route. All these
routes needs to be re-evaluated since their next hop label vector might have
changed.

i. route add
When a new route is added, the route is evaluated to see if there is a 
ldp_standby_route for this route. If there is, there was atleast one label
advertised for this route to the neighbors. We walk the list of 
ldp_standby_nexus_refs associated with the ldp_standby_pfx and install the 
routes if possible.

j. route change 
The next hop for the route has changed. If the standby_route exists for this
 route, the route is re-evaluated and updated with the new next hop label 
vector (if it is different). If the new label vector is NULL, the route 
currently has no label next hops. The route is then unbound from the nexus.

k. route delete
When a route is deleted, walk is done on the route's nexus_ref thread and 
the route is deleted/unbound from the nexus.

g. session close
In addition to freeing up all the resources and re-evaluating the routes, 
the standby_route database needs to be updated as well.


___________________________________________________________________________

7. SWITCHOVER:
===================

When switchover happens, the secondary's switchover function gets called.
At this point, the function vectors still point to the secondary's list.
The following functions are performed to fix up the data structures:
1. adj and mirror_adj
2. session and mirror_session
3. mirror_nexus database
4. Per session tasks:
    a. Inbound next hop address list
    b. Outbound next hop address list
    c. OutLIB
    d. InLIB
5. Per instance tasks:
    a. standby_route database 
    b. standby nexus database 
    c. shadow routing table

All the above will be re-evaluated in the above order.

1. adj and mirror_adj
   On switchover, all mirror_adjs for which we do not have a corresponding
   adjacency will be removed. For all other adjacencies, ppmd will be 
   programmed.

2. session and mirror_session
   All sessions not in operational mode and initial sync done mode will 
   be closed. 

   For all other sessions, the inbound and outbound socket needs to be merged
   on the secondary. Before this is done first the outbound socket on each 
   session is drained. Then the number of bytes left on the inbound socket
   read.

   The outbound socket needs to be drained before the socket is merged since
   the secondary will otherwise lose this data. 

   The inbound socket needs to be read at least upto the point where the 
   primary has already read this buffer so that the secondary when it becomes
   primary doesn't re-read these messages. Also, this helps in determining the 
   final state of the inlib and outlib bindings after switchover [More details
   under switchover for inlib and outlib bindings respectively]. Since it is
   hard to determine where the primary left off after switchover, the 
   secondary just reads the number of bytes left on the inbound socket after
   switchover.

   The TCP socket is now merged and the session can send and receive packets
   over this socket.

   The mirror session associated with this session is released. It will be 
   recreated when the session is ready for sync. More on that later.


3. mirror nexus database
-------------------------
   All the mirror nexii that don't have a nexus association are now removed.


4. Per Session tasks:
----------------------

   a. Inbound next hop address list
   Nothing needs to be done for this. The correct state already exists on the
   session.

   b. Outbound next hop address list
   
   The outbound next hop address list maintained on the standby session
   structure is compared against the intfaddr table and address added and
   withdrawn as needed.

   c. OutLIB 
    On switchover, all the bindings in the outlib of the session are 
   re-evaluated. These bindings contain the standby state 
   (ldp_standby_label_binding structure).

    The bindings will either be in ACTIVE or RELRCV state. Since we have been
   ignoring inbound releases for these outlib bindings, there is ambiguity 
   whether a release was received for these bindings (solicited for RELRCV 
   bindings and unsolicited for ACTIVE bindings). 

    If the release counter on a binding is zero, release message was not
   received for this binding. Nothing more needs to be done. The binding
   is already in it's final state.

    If the release counter is non-zero, it is ambiguous if the release
   received was for this incarnation of the binding or the previous. 

   In this case, for bindings in:
   a. ACTIVE state: A map message is enqueued and the state is changed to 
		    MAPSEND_SW. 
   b. RELRCV state: The state of the bindings is changed to RELRCV_SW.
  
    The session also maintains a counter of the number of outlib bindings in
   switchover state. As the bindings move out of switchover state, the counter
   is decremented. Once the counter reaches zero, the session is out of
   switchover and can only be sync'ed with the backup.

   Bindings in switchover state:
   a. For bindings in MAPSEND_SW state:  once the map gets sent out, 
      the state of this binding is moved to ACTIVE. This outlib binding is 
      now out of switchover state.
   b. For bindings in RELRCV_SW state: these bindings were enqueued on a
      thread for expiry after 60 seconds from the time the binding was first
      moved to RELRCV state when the RE was standby. As the binding expires,
      the binding is released and is now out of switchover.

   For more details on state machine for these bindings, please refer to
   Appendix Ba.     

   d. InLIB
   
    On switchover, all the binding in the inlib of the session are evaluated.
   These bindings contain the standby state (ldp_standby_label_binding 
   structure). 

    For bindings that don't have an outstanding release (rel_c == 0), the 
   standby structure may be released.

    For bindings that don't have an outstanding release but are in RELSEND
   mode, the primary crashed before it could send out the release message for
   this binding. The release message for this binding is enqueued and the 
   standby structure released.

    Since the inbound socket is also drained at least upto the point where
   the primary may have already read from the socket, there must be no 
   outstandings releases on the binding. There might be unsolicited releases
   sent by the primary on some of the bindings in which case (rel_c = 1 and
   map_c = 1), this binding will be released.

    Note, the inlib must be processed after the outlib for the session has
   been processed for switchover.


5. Per instance tasks: 

    a. standby_route database

    On switchover, the standby prefix database is re-evaluated. This database
    contains all prefixes for which there is an outgoing label. Each prefix 
    may be in several following states:

    i. no route in shadow routing table:
    For standby prefixes for which there is no shadow route, send a withdraw 
    message for this prefix to all sessions. The labels associated with this 
    prefix can be found by walking the standby_nxref_thread on the 
    standby_route. 
    There may be multiple labels associated with this prefix since the 
    primary might have been in the middle of changing the label on this 
    prefix. To identify the sessions that are advertising a particular label,
    walk the out_label tree on the nexus associated with the standby_nexus_ref.

    ii. multiple out labels for the prefix:
    There is a route in the shadow routing table. However, there are multiple
    labels associated with this prefix. This can happen if the primary was in
    the middle of changing the label on this prefix and hence sessions may end
    up with different labels. 
    If there are multiple standby_nxrefs threaded to the standby_route, there
    are multiple labels associated with this prefix. 
    A withdraw message has to be sent for all sessions for this prefix similar
    to what we do above. In addition, since there is route in the shadow 
    routing table, we may need to enqueue a new map message for this prefix. 
    However this can also be done in step (7) when all the routes in the 
    shadow routing table are re-evaluated (preferred since we will anyways 
    again evaluate all routes).
 
    iii. no inlib entries:
    These prefixes have a single label associated with them and there is a 
    route in the shadow routing table. However, there is no longer an inlib 
    entry for these routes. Again enqueue a withdraw message on all the 
    sessions for this prefix.

    All the above will result in removing the standby_route from the database.
    This will also result in deleting any standby_nexus structure that 
    doesn't have any standby_routes associated with it. This basically means
    that this label is no longer active on any session for any prefix.


    b. standby_nexus database
    
    On switchover, the standby_nexus table needs to be re-evaluated. This 
    database contains all the outgoing labels in this instance. 

    By the time, we get here, only standby_routes with (1) route in the 
    shadow routing table (2) single out label (3) next hop label vector exists
    in the standby_route database. 

    At this point, we look at the standby nexii that doesn't have a mirror 
    nexus associated with it's nexus. 

    Basically the absence of a mirror nexus indicates that the self ids for 
    the ingress and transit routes from the primary are not known and hence 
    we can no longer retrieve statistics from the kernel for these routes. 
    We don't need to withdraw this label. Simply allocate new self ids for the 
    ingress and transit routes. We will lose the statistics but that's about
    it. Create a new mirror_nexus structure for  the nexus associated with 
    this standby_nexus. Walk the standby_nxref tree on the standby_nexus and
    bind all routes in the shadow routing table for these standby_routes 
    with the nexus on the standby_nexus via the nexus_ref. The standby_nexus
    can now be disassociated from the nexus.  
    
    All the standby_routes associated with the standby_nexus can also be 
    released. 

    After this step all the standby state, standby prefixes and standby nexii,
    must have been removed. The standby prefix database and the standby nexus
    database must be empty.
   
    Make sure the label associated with the nexus is advertised to all active
    sessions for all the routes associated with this nexus. 

    c. shadow routing table routes

    Finally the routes in the shadow routing table need to be re-evaluated.
    If the route is not associated with a nexus, the route is deleted from
    the shadow routing table. The flash routine will re-add these routes
    to the shadow routing table.

 
Q When is the session ready for sync after switchover?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Session on the new primary will be marked ready for sync when none of the 
bindings in the outlib are in _SW state. 

___________________________________________________________________________

8. MISCELLANEOUS:
=====================

   a. L2circuit FECs

   The l2circuit inlib bindings will be stored in the inlib of the session. 
   The l2circuit outlib bindings will be stored in the outlib of the session.
   However, on switchover, the new primary will send a withdraw for these 
   outlib bindings on the sessions. [PR 74116]

   b. Error handling of tag allocate fail
   If tag_allocate fails on an outlib during initial/ongoing sync, set a flag
   in the standby_nexus as such. On switchover, try to re-allocate the tag
   and if it fails, send a withdraw out on all prefixes using that tag
   and send a new label.

   c. Graceful restart:
   If the session is in graceful restart mode (helper/restarting), on the
   secondary, this session will appear to be down on the secondary. The 
   primary will remove the mirror entry associated with this session from the
   secondary. Only after the session quits graceful restart, will the primary
   inform the secondary about this session.

___________________________________________________________________________

9. CAVEATS:
================

1. Unsolicited releases:

Inbound unsolicited release (OUTLIB):
We ignore all inbound releases on the standby during initial/ongoing sync. 

Outbound unsolicited release (INLIB):
In JUNOS software, unsolicited releases are only sent when we receive a
label map for a FEC on a session that already has another active binding
with a different label. That can happen in non-merging mode which is not
currently supported. 

It is not straightforward to determine if this is an unsolicited release on
the secondary reliably especially during initial sync. For now, whenever the 
primary ends up sending an unsolicited release, the primary will mark the
session on the secondary as out of sync and send an error message back to the
secondary.

We will need to treat this more gracefully in the future.

2. Wildcard Withdraws
   Currently not handling wildcard withdraws. JUNOS never sends wildcard 
   withdraws. For inlib bindings, this may be an issue during initial sync
   since it is not clear which bindings to withdraw.

   For now, the primary will close the session on the secondary when a 
   wildcard withdraw is received. This can be narrowed down to only when
   a session is in initial sync.


3. Label request messages

Label request messages are not processed on the secondary. If switchover
happens where there is an outstanding label request message, that label
request message will be lost.


4.  Notification messages

On the secondary, we want to keep track of notification messages sent and 
received by the primary. 

Notification messages sent by the primary:
Some of these notification messages that the primary sends to the peer are 
not fatal and hence when switchover occurs, the secondary should be able to
send them out in case the primary wasn't able to. 

We don't need to care about notification messages sent out by the primary
before the session is established (during initialization for example). This
is because this session will not be present on the secondary and the 
secondary will not see these notification messages.

After the session is operational, primary sends out notification messages in
response to label request messages that it doesn't have a route for. 

Currently, secondary is ignoring label request messages so notification 
messages sent by the primary are irrelevant as of now. 

We may need to care about fatal notification messages sent out by the primary
to the peer, since the primary may crash before informing us about this 
session close event. However, this might not be an issue since the secondary
might run into the same error that the primary did (cannot be guaranteed 
since primary and secondary may be running different software). Also, the
peer on receiving this notification will bring the session down and any 
attempt to read from this socket would result in an error on the secondary
after switchover. But it might still be good to read this notification and
close the session on the secondary.


Notification messages received by the primary:
We may need to process fatal notification messages received by the primary.
Again the primary may crash before informing us about this session close 
event. However, this might not be an issue since the peer after sending the 
notification will bring the session down and any attempt to read from this
socket would result in an error on the secondary after switchover. But it 
might still be good to read this notification and close the session on the 
secondary.

Non-fatal notification messages might be received by the primary in response
to a label request message. Today we ignore label request messages on the
secondary. Also label request messages are received by the primary for
l2circuit FECs only.  

In the current code, notification and label request messages are not being 
processed.


5. L2circuit
   Since Cisco uses conservative label retention for l2circuit FECs, we will
   receive unsolicited releases and label requests from Cisco for these FECs.
   Today, these unsolicited releases are ignored on the standby. However,
   this only means that on switchover we might have some bindings in ACTIVE
   state while they have been released on the neighbor. To account for this,
   today we readvertise all bindings in ACTIVE state to our peer.
   We might also need to keep track of any outstanding label requests mainly 
   to be able to send notification messages in case we don't a l2circuit 
   route for the l2circuit FEc being requested.
  
   Note, the above discussion applies for any FEC type that we receive
   unsolicited releases and/or label requests for.

____________________________________________________________________________

10. TROUBLESHOOTING:

1. new show commands:

   shivania@pro6-f> show ldp replication ?  
   Possible completions:
  	neighbor             Show LDP neighbor replication database
  	path                 Show LDP path replication database
  	session              Show LDP session replication database
        standby-path         Show LDP standby path database
        standby-route        Show LDP standby route database

   a. adjacency replication:
	
	shivania@pro6-f> show ldp replication neighbor 
	Instance        Address                 Interface         State
	0               10.255.168.66           lo0.0             Established
	0               192.168.38.50           so-1/0/0.0        Established
	0               192.168.38.58           so-1/0/3.0        Established


	shivania@pro6-f> show ldp replication neighbor detail 
	Instance        Address                 Interface         State
	0               10.255.168.66           lo0.0             Established
	    Interface Index: 64  Age: 00:01:39
	    Reference count: 1
	0               192.168.38.50           so-1/0/0.0        Established
	    Interface Index: 66  Age: 00:01:52
	    Reference count: 1
	0               192.168.38.58           so-1/0/3.0        Established
	    Interface Index: 67  Age: 00:01:50
	    Reference count: 1

	    State: "Established" if mirror_adj is associated with ldp_adj
		    structure
		   "Down" otherwise
	    Age: How long has it been since we received this adj from primary

   b. session replication:

	shivania@pro6-f> show ldp replication session            
	Instance        Address                 State
	0               10.255.168.64:0         Not in sync
	0               10.255.168.66:0         Not in sync


	shivania@pro6-f> show ldp replication session detail 
	Instance        Address                 State
	0               10.255.168.64:0         Not in sync
	   Age: 00:03:04      Reference count: 1
	0               10.255.168.66:0         Not in sync
	   Age: 00:03:11      Reference count: 1

      State: "Established" if mirror_ses associated with operational 
             ldp_session struct and initial sync complete on session
             "Initial Sync in Progress" if mirror_ses associated with
             ldp_session struct and initial sync in progress
             "Not in sync" If mirror_ses associated with ldp_session
             "Down" otherwise 
      Age: How long has it been since we received this session 
		 from primary


   c. nexus replication:

	shivania@pro6-f> show ldp replication path              
	Instance    Label       Ingress Self ID     Transit Self ID     State
	0           3           805310464           805310465           Sync
	0           100000      805310468           805310469           Sync
	0           100016      805310470           805310471           Sync

	shivania@pro6-f> show ldp replication path detail 
	Instance    Label       Ingress Self ID     Transit Self ID     State
	0           3           805310464           805310465           Sync
	    Reference count: 1
	0           100000      805310468           805310469           Sync
	    Reference count: 1
	0           100016      805310470           805310471           Sync
	    Reference count: 1
   

    d. ldp_standby_route database: 

      shivania@pro6-f> show ldp replication standby-route
      10.255.168.59/32               (Route in shadow routing table)
	 Label: 3        Reference Count: 2
      10.255.168.64/32               (Route in shadow routing table)
         Label: 100112   Reference Count: 2
      10.255.168.66/32               (Route in shadow routing table)
         Label: 100000   Reference Count: 2


    e. ldp_standby_nexus database: 
      shivania@pro6-f> show ldp replication standby-path
      Label: 3           Reference Count:    2
         Prefix:  10.255.168.59/32           Prefix reference count: 2
	 Prefix:  10.22.1.1/32		     Prefix reference count: 2
      Label: 100112      Reference Count:    1
         Prefix:  10.255.168.64/32           Prefix reference count: 2
      Label: 100000      Reference Count:    1
         Prefix:  10.255.168.66/32           Prefix reference count: 2


2. Extension to existing show command 

a. "show ldp database"

"show ldp database detail" shows the state of the standby binding
structure for the input database.

{backup}
shivania@pro6-f1> show ldp database detail
Input label database, 10.255.168.59:0--10.255.168.64:0
  Label     Prefix
 100240     10.255.168.59/32
            State: Active
            Age: 11:05
            Standby binding state:     <====
                Map messages: 1
                Release messages: 0

b. "show ldp session detail/extensive"

-- added a new line to the output to display the state of nonstop routing
for this session:

shivania@pro6-f> show ldp session detail    
Address: 10.255.168.66, State: Operational, Connection: Open, Hold time: 23
  Session ID: 10.255.168.59:0--10.255.168.66:0
  Next keepalive in 3 seconds
  Passive, Maximum PDU: 4096, Hold time: 30, Neighbor count: 2
  Keepalive interval: 10, Connect retry interval: 1
  Local address: 10.255.168.59, Remote address: 10.255.168.66
  Up for 00:00:27
  Local - Restart: disabled, Helper mode: enabled
  Remote - Restart: disabled, Helper mode: enabled
  Local maximum recovery time: 240000 msec
  Nonstop routing state: In sync   <===== added
  Next-hop addresses received:
    so-1/0/0.0
    so-1/0/2.0
    10.255.168.66


_________________________________________________________________________

12. References:
================

[SOCK_REPL_API] - Juniper socket replication API, 
sw-projects/os/nsr/kernel/socket_replication_api.txt

[LDP_FUNCSPEC]: Functional spec for LDP support of NSR
sw-projects/os/nsr/ldp_software_spec.txt


_________________________________________________________________________


13.  Appendix:
================

A. Message Formats for LDP_RSYNC messages over the IRS:
--------------------------------------------------------

a. LDP_RSYNC_OPEN:
~~~~~~~~~~~~~~~~~~  

   Negotiation of the version of the messages used on the socket. Must
   be done before any messages are exchanged on the socket. Allows interop
   between different versions of code on primary and secondary.

	0	       15		31
        +-------+-------+-------+-------+
        | Type  = 1     | Length        |
        +-------+-------+-------+-------+
        | vers  |
        +-------+


b. LDP_RSYNC_SESSION_REQ_MSG:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Request from secondary for sync with one peer. Sent by the secondary
   whenever it is ready to receive data for a session that was previously
   sent over by the primary as a candidate.

	0	       15		31
        +-------+-------+-------+-------+
        | Type = 2      | Length        |
        +-------+-------+-------+-------+
        | Instance ID   		|  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session 1 info
	+               +-------+-------+
	|		|      Pad	|
	+-------+-------+-------+-------+               
	|				|
	~	Secondary JSR handle	~
	|				|
	+-------------------------------+

Secondary jsr handle: size of jsr_handle_t
This is the handle returned from the call to jsr_split on the secondary.
The primary uses this handle to start replication of the TCP socket.
	      



c. LDP_RSYNC_SESSION_*_MSG:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   All the LDP_RSYNC_SESSION_*_MSG used to relay initial sync information
   for the session are encoded as follows:

	0	       15		31
        +-------+-------+-------+-------+
        | Type          | Length        |
        +-------+-------+-------+-------+
        | Instance ID                   |  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session info
	+		+-------+-------+
	|		|  Pad		|
        +-------+-------+-------+-------+
	|				|
	~	   LDP_MSG		~	
	|				|
	+-------+-------+-------+-------+

LDP_MSG will be absent for START and complete messages


i. LDP_RSYNC_SESSION_START_MSG: 

   Sent from the primary to the secondary. Message to inform the secondary 
   that initial sync for the session is starting in response to the
   LDP_RSYNC_SESSION_REQ_MSG.

	0	       15		31
        +-------+-------+-------+-------+
        |   Type = 3    | Length        |
        +-------+-------+-------+-------+
        | Instance ID                   |  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session info
	+		+-------+-------+
	|		|  Pad		|
        +-------+-------+-------+-------+


ii. LDP_RSYNC_SESSION_ADDR_IN_MSG:

   Sent from the primary to the secondary, during the initial sync. This
   contains all the addresses that the primary has received on this session.
   These are encoded as standard LDP protocol address messages.

   If the primary has not learnt any addresses over this session, this 
   message will not be sent. Contains only address adds.


	0	       15		31
	+-------+-------+-------+-------+
        | Type = 4      | Length        |
        +-------+-------+-------+-------+
        | Instance ID   		|  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <-- session info
	+               +-------+-------+
	|		|	Pad     |
        +-------+-------+-------+-------+
	|	   LDP_MSG		|	
	|	   ....			|
	+-------+-------+-------+-------+


iii. LDP_RSYNC_SESSION_ADDR_OUT_MSG:

   Sent from the primary to the secondary, during the initial sync. This
   contains all the addresses that the primary has sent on this session.
   These are encoded as standard LDP protocol address messages.

   If the primary has not sent any addresses over this session, this 
   message will not be sent. Contains only address adds.

	+-------+-------+-------+-------+
        | Type  = 5     | Length        |
        +-------+-------+-------+-------+
        | Instance ID   		|  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session info
	+               +-------+-------+
	|		|	Pad     |
        +-------+-------+-------+-------+
	|	   LDP_ADDR_MSG     	|
	|	      ....		|
	+-------+-------+-------+-------+


iv. LDP_RSYNC_SESSION_INLIB_MSG:

   Sent from the primary to the secondary, during the initial sync. This
   contains the label state that the primary has received on this session.
   These are encoded as standard LDP protocol label messages. Note, there may
   be multiple label messages sent as part of this message.

   If the primary has not received any labels over this session, this 
   message will not be sent.


	+-------+-------+-------+-------+
        | Type  = 6     | Length        |
        +-------+-------+-------+-------+
        | Instance ID   		|  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session info
	+               +-------+-------+
	|		|	Pad     |
        +-------+-------+-------+-------+
	|      LDP_LABEL_MSG     	|  <--- std LDP_label_MSG starts
	|	......			|
	+-------+-------+-------+-------+


v. LDP_RSYNC_SESSION_OUTLIB_MSG:

   Sent from the primary to the secondary, during the initial sync. This
   contains the label state that the primary has sent on this session.
   These are encoded as standard LDP protocol label messages. Note, there may
   be multiple label messages sent as part of this message.

   If the primary has not sent any labels over this session, this 
   message will not be sent.

	+-------+-------+-------+-------+
        | Type  = 7     | Length        |
        +-------+-------+-------+-------+
        | Instance ID   		|  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session info
	+               +-------+-------+
	|		|	Pad     |
        +-------+-------+-------+-------+
	|      LDP_LABEL_MSG     	|  <--- std LDP_label_MSG starts
	|				|
	+-------+-------+-------+-------+


vi. LDP_RSYNC_SESSION_COMPLETE_MSG message:

   Sent by primary after sending all the initial sync state (after doing
   one pass on the in/outlib, addresses, etc). This message marks the end
   of initial sync for the session. The secondary should not ask
   for sync again for a session until receiving the "complete". 

	0	       15		31
        +-------+-------+-------+-------+
        | Type  = 8     | Length        |
        +-------+-------+-------+-------+
        | Instance ID   		|  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session info
	+               +-------+-------+
	|		|  Pad		|	        
	+-------+-------+-------+-------+            
  


e. LDP_RSYNC_SESSION_ERROR_MSG:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Error message sent between primary and secondary whenever an error is 
  encountered during initial sync. It may also sent from the primary if
  initial sync for the session was completed but there were some errors
  due to which the session may need to be resync'ed.

        +-------+-------+-------+-------+
        | Type          | Length        |
        +-------+-------+-------+-------+
        | Instance ID   		|  <-- instance info
        +-------+-------+-------+-------+
        | Session Identifier remote id  |  <--- session info
	+               +-------+-------+
	|		| Error code    |	        
	+-------+-------+-------+-------+

Different Error Codes:
   LDP_RSYNC_ERR_SESSION_NOTESTABLISH = 1, /* Session not in ESTAB state */
   - Sent from primary to secondary when secondary requests sync for a
     session not operational on the primary.

   LDP_RSYNC_ERR_SESSION_INPROGRESS = 2, /* Request processing in progress */
   - Sent from primary to secondary or from secondary to primary if 
     session encountered an error during initial sync which caused it to
     abort initial sync.

   LDP_RSYNC_ERR_SESSION_UNKNOWN  = 3,   /* Request for unknown session */
   - Sent from primary to secondary or from secondary to primary if 
     session being sync'ed is unknown.

   LDP_RSYNC_ERR_SESSION_ABORT = 4,      /* Abort session sync request */
   - Sent from primary to secondary or from secondary to primary if 
     it chooses to abort initial sync for this session.

   LDP_RSYNC_ERR_SESSION_REPLICATION_FAILED = 5, /* Replication failed */
    - Sent from primary to secondary if the socket replication failed
      for the session that the secondary wants to sync.

   LDP_RSYNC_ERR_SESSION_PENDING_REL = 6, /* All pending releases not sent */
    - Sent from primary to secondary if primary was not able to send all
      the releases out before the timeout during initial sync.

   LDP_RSYNC_ERR_SESSION_UNSOL_REL = 7, /* Unsolicited release sent */
    - Sent from primary to secondary if primary received an unsolicited 
      release during initial or ongoing sync for the session.



B. STATE MACHINE FOR OUTLIB BINDINGS DURING SWITCHOVER
------------------------------------------------------


a. INET BINDINGS


                  +---------------+  switchover && +----------+
      rel rcvd    |               |  release rcvd  |          |<----+
    +<------------|  MAPSEND_SW   |<---------------|  ACTIVE  |---->+
    |             |               |--------------->|          | switchover &&
    |             +---------------+  map sent      +----------+ no release
    |             enqueue| ^                            ^
    |              wd msg| |                            |
    |                    | |enqueue                     |
    |                    | |map msg                     |
    V                    V |                            | map sent
+---------+         +-------------+                +----------+
| DELETED |         |  WDSEND_SW  |                |  MAPSEND |
+---------+         +-------------+                +----------+
    ^  ^                   |                           ^
    |  |  rel rcvd         |withdraw                   |
 rel|  +<-------------+    |sent                       |release rcvd/
rcvd|                 |    V                           |switchover timeout
+--------+ switchover+-----------+ enqueue map   +----------------+
| RELRCV |---------->| RELRCV_SW |-------------->|RELRCV_RESEND_SW|
|        |&& release |           |<--------------|                |
+--------+   recvd   +-----------+  enqueue wd   +----------------+
  |  ^
  |  |
  V  | switchover
  +->+ && no release



b. L2CIRCUIT BINDINGS

                                     switchover &&
                  +---------------+  release rcvd  +----------+
       rel rcvd   |               |  && l2ckt rt   |          |<----+
    +<------------|  MAPSEND_SW   |<---------------|  ACTIVE  |---->+
    |             |               |--------------->|          | switchover &&
    |             +---------------+  map sent      +----------+ no release &&
    |             enqueue| ^                         |  ^       l2ckt rt
    |              wd msg| |           switchover && |  |
    |                    | |            no l2ckt rt  V  |
    |                    | |enqueue    +<------------+  |
    |                    | |map msg    |                |
    V                    V |           |                | map sent
+---------+         +-------------+                +----------+
| DELETED |         |  WDSEND_SW  |                |  MAPSEND |
+---------+         +-------------+                +----------+
    ^  ^                   |                           ^
    |  |  rel rcvd         |withdraw                   |
 rel|  +<-------------+    |sent                       |release rcvd/
rcvd|                 |    V                           |switchover timeout
+--------+ switchover+-----------+ enqueue map   +----------------+
| RELRCV |---------->| RELRCV_SW |-------------->|RELRCV_RESEND_SW|
|        |&& release |           |<--------------|                |
+--------+   recvd   +-----------+  enqueue wd   +----------------+
  |  ^
  |  |
  V  | switchover
  +->+ && no release


In 8.1, it will be assumed that a release was received for all outlib bindings
before switchover.
