            Mirroring subsystem API
	 ============================

1. Client needs a data-id to be assingned for each mirrorred data structure.
   mirrored data id's should be added in(../rpd/os/mirror_data.h)

   typedef enum {
    MIRROR_DATA_START,
    MIRROR_DATA_TEST,
    MIRROR_DATA_LAST
   } mirror_data_id;

2. Each mirrorred data entry should embed mirror_data_node in it.

   typedef struct _mirror_data_node {
    byte data_id;
    byte mirror_op;
    mirror_q_entry *queue_entry;
   } mirror_data_node;

3. Need to register the data encode/decode, lock/unlock, find-next/compare callback 
   functions for each mirrored data structure

  (a) These functions are for getting reference count for queued mirrored data and
      releasing the reference count after dequeueing. Typically these would be the
      existing lock/unlock functions for the strucutre that consists mirror-data
      node. Clients may have define these if they are not reference couting the 
      mirrored data structure before.

      /* Function to reference count the mirrored data */
      typedef void (*mirror_data_lock_func_t)(const mirror_data_node*);
      typedef void (*mirror_data_unlock_func_t)(const mirror_data_node*);

  (b) These functions are for encoding the mirrored data and decoding the mirrored 
      data.
      Note: These functions are not called automatically, these are called when
            clients call mirror_xxx functions or when mirroring subsystem is 
	    initializing/resyncing the DB.

      o The mirror_data_decode_func_t is called on the passive side of the database.
        If a DB is mirrored from master to standby, master is active side and standby
	is passive and viceversa. If a database is mirrored from both sides then both the
	sides are considered to be active/passive. The boolean returned by the decode 
	function is delete flag, TRUE will release/delete the mirror_recvd_data immediatly, 
	FALSE will let client to keep it untill it needs it. Its the responsibility of client 
	to call mirror_free_recv_data to free this buffer.

     o  The mirror_data_encode_func_t is called on the active side of the database.
        The arguments for encode are mirrored data node, buffer(allocated by
	mirroring subsystem) and length of the buffer passed in. The return value
        of this function should be length of data encoded(>0) when successfully encoded 
	data, (<0) if client wants to cancel the encode and (==0) if the provided buffer is 
	not enough for encode, the mirroring subsystem will flush its buffers and will call 
	encode again for this last case.

      /* Functions to wrap/unwrap mirrored data */
      typedef int (*mirror_data_encode_func_t)(const mirror_data_node*, byte*, u_int32);
      typedef boolean (*mirror_data_decode_func_t)(const mirror_recvd_data *);

  (c) These functions are for background consitency check that needs to be done for 
      mirrored database. 
      o The mirror_data_get_next_func_t is a itearation function. If the passed in argument
        is null client should return first entry otherwise next entry.
	
      o The mirror_data_compare_recvd_data_func_t function should decode the received data
      	(first arguement) and return TRUE/FALSE accordingly if the database has the 
	corresponding entry or not. If the entry is found but recvd data doesn't math with 
	the entry the second argument for mirror_data_compare_recvd_data_func_t
	(mirror_data_node**) should be set to mirror_data_node of found entry(return value). 
	
      o The mirror_data_compare_nodes_func_t is a function to find out if mirror_data_node1
        (first arg) is lexically next to(during regular iteration) mirror_data_node2(second
	arg. If the client does not require database walk chunking it may not define this 
	function. Currently this function is used in the case of db walk chunking only.

      /* Functions to iterate the mirrored database for resync/consitensy-checking */
      typedef mirror_data_node* (*mirror_data_get_next_func_t)(mirror_data_node*);
      typedef boolean (*mirror_data_compare_recvd_data_func_t)(const mirror_recvd_data*,
							       mirror_data_node**);
      typedef int (*mirror_data_compare_nodes_func_t)(mirror_data_node*, mirror_data_node*);

  (d) This function is to reset the database on receive(passive) side of the mirrored 
      base when the active/standby RE restarts
   
      /* Function to reset the recvd database*/
      typedef void (*mirror_clear_recvd_data_func_t)(void);


  (d) Client needs to fill in the callback functions mentioned above and the following things:
      
      o data_id, A data_id needs to be added for each DB client is mirroring in(os/mirror_data.h)
        typedef enum {
	 MIRROR_DATA_START,
	 MIRROR_DATA_TEST,
         MIRROR_DATA_RT_INSTANCE,
	 MIRROR_DATA_OSPF_INTF,
	 MIRROR_DATA_OSPF_NBR,
	 MIRROR_DATA_ISIS_SYSTEMID,
	 MIRROR_DATA_ISIS_ADJ,
	 MIRROR_DATA_LAST
        } mirror_data_id;
	
	NOTE: Please add the description of the database in mirror_data_ids(os/mirror_data.h)
	static const bits mirror_data_ids[] = {
              {MIRROR_DATA_TEST, "Mirror-Test-Bed"},
	      {MIRROR_DATA_OSPF_INTF, "OSPF interface"},
	      {MIRROR_DATA_OSPF_NBR, "OSPF neighbor"},
	      {MIRROR_DATA_RT_INSTANCE, "Routing-Instance"},
	      {MIRROR_DATA_ISIS_SYSTEMID, "ISIS system-id"},
	      {MIRROR_DATA_ISIS_ADJ, "ISIS adjacency"},
	      {0,                    NULL}
	};

      o The enum mirror_db_type indicates which direction the client is mirroring the DB.
        typedef enum {
	  MIRROR_DB_MASTER_TO_STANDBY,
	  MIRROR_DB_STANDBY_TO_MASTER,
	  MIRROR_DB_BOTH
	} mirror_dbase_type;
            
     o The flag mirror_donot_chunk_db_walk should be FALSE only if client's DB is not too 
       big(>1000) (this is just a convinience for clients whose DB is a simple list and 
       don't want to build trees etc.just for mirror DB walk, assumption is that if client 
       is maitaining a list for his DB probably DB itself is not so big).

      typedef struct _mirror_registry_entry {
       mirror_data_lock_func_t mirror_data_lock_func;
       mirror_data_unlock_func_t mirror_data_unlock_func;
       mirror_data_encode_func_t mirror_data_encode_func;
       mirror_data_decode_func_t mirror_data_decode_func;
       mirror_data_get_next_func_t mirror_data_get_next_func;
       mirror_data_compare_nodes_func_t mirror_data_compare_nodes_func;
       mirror_data_compare_recvd_data_func_t mirror_data_compare_recvd_data_func;
       mirror_clear_recvd_data_func_t mirror_recvd_data_clear_func;
       byte data_id;
       mirror_dbase_type mirror_db_type;
       boolean mirror_donot_chunk_db_walk;
      } mirror_registry_entry;

4. APIs to register, add, delete and change mirrored data.

   void mirror_register_data(mirror_registry_entry*)
   void mirror_add(mirror_data_node*)
   void mirror_del(mirror_data_node*)
   void mirror_update(mirror_data_node*)

5. API to free the mirror_recv_data(rx buffer) if its not freed immediatly after
   decode.

   void mirror_free_recvd_data(mirror_recvd_data*) 

6. APIs to request a DB resync(request is made from passive side of database when its
   ready to accept the data)
   void mirror_request_db_resync(mirror_data_id)