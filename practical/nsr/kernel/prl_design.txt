$Id: prl_design.txt,v 1.6 2005/11/15 02:01:55 dsw Exp $
Packet Replication Layer Design

Copyright (C) 2005, Juniper Networks, Inc.

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.

Table of Contents
-----------------

1.	Introduction
2.	Definitions
3.	Goals
4.	Assumptions/Dependencies
	4.1.	Assumptions
	4.2.	Dependencies
5.	Context chart
6.	High-level design
	6.1.	Description
	6.2.	Top-level modules
	6.3.	Initialization and failover
7.	Detailed design
	7.1.	Messages
	7.2.	Upcalls
	7.3.	Pseudocode
8.	Performance and Scalability
9.	Other approaches
10.	Outstanding issues
11.	Future optimizations
12.	Design issues
	12.1.	Common receive buffer space
A.	References

1.	Introduction
--------------------

This document will cover the design of the packet replication layer for 
socket replication/Non-Stop Routing.  High-level and detailed design will be 
discussed.  Other approaches that we considered will also be listed, with 
their advantages and the reason(s) that they were ultimately rejected.

The packet replication layer is one part of socket replication (see [1]).  
Its main job is to replicate incoming traffic from the peer to both the 
primary and secondary sockets consistently and without significant performance 
penalty.

2.	Definitions
-------------------

    * Packet Replication Layer subsystem (PRL) - The subsystem described 
	in this document.  It is responsible for replicating incoming 
	traffic to both primary and secondary sockets.

    * Master RE - The RE that the active application is running on.  It can 
	theoretically be the same RE as the backup RE.

    * Backup RE - The platform that the inactive (snooping) application is 
	running on.  It can theoretically be the same RE as the master RE.

    * Primary socket - The socket that the active application is running on.
	This will normally be running on the master RE.  The exception is 
	during a failover, after the REs have switched mastership but before 
	NSR has finished its own state changes.

    * Secondary socket - The socket that the inactive (snooping) application 
	is running on.  This will normally be running on the backup RE.  The 
	exception is during a failover, after the REs have switched mastership 
	but before NSR has finished its own state changes.

    * Socket Data Replication Layer subsystem (SDRL) - The subsystem 
	responsible for replicating socket data between the primary and 
	secondary sockets.

    * Kernel-Kernel Communication Module (KKCM) - The module responsible for 
	transport of NSR messages between the REs.

    * Synchronous failover - A failover that is synchronously conducted on a 
	per-socket basis.  The application prompts the kernel to start this.

    * Asynchronous failover - A failover that is asynchrously conducted.  This 
	will be as a result of a system-wide action, a per-socket timeout, or 
	some other asynchronous trigger.  

3.	Goals
-------------

The primary goals of this subsystem are twofold:

    * To propagate incoming traffic reliably and consistently from the 
      external peer, through the master RE to the backup RE.
      This ensures that all data received by the primary socket is also 
      available on the secondary socket.

Secondary goals include:

    * Performance
      Incoming packets should not be delayed significantly by PRL processing.  
      The difference should not be noticeable to the peer.

    * Scalability
      The PRL could take a noticeably greater amount of CPU, memory, and 
      other resources due to the fact that it has to buffer unacked data from 
      the other RE.  However, the extra resourcing should not be so 
      significant as to affect general scalability of the RE.

      Host traffic from the PFE should not significantly degrade in 
      performance (latency or effective bandwidth) when the number of 
      connections is increased.

    * Reliability
      JUNOS as a whole should not exhibit significantly more problems with 
      PRL implemented than it currently does.

    * Modularity
      The PRL should be a internally-cohesive module in the kernel, that is 
      as independent as possible from other areas of code while still 
      providing the required functionality.

Non-goals include:

    * Portability
      The PRL will be deeply embedded into the JUNOS kernel, and will not be 
      easily portable to other platforms.

4.	Assumptions/Dependencies
--------------------------------

4.1.	Assumptions
-------------------

The following assumptions are made for the design of the packet replication 
layer:

    a.  A failover (either synchronous due to the application, or 
	asynchronous due to RE or other system failure) could occur at any time.
    b.  Either the master or backup RE could failover at any time.
    c.	It is OK to lose some incoming packets during an asynchronous failover.  
	However, it is not OK for the primary socket to receive a packet, and 
	for the secondary socket to not receive that packet, and vice versa.
    d.	There should be no packet loss during a synchronous failover.
    e.  The master and backup REs do not need to be running the same 
        version of software.  However, both must be running releases that 
	support Non-Stop Routing, and specifically socket replication.
    f.  Incoming packets should be pushed up the L4 layers in the order in 
	which they had come in from the external peer. The replication process 
	should not cause this order to change for either the primary or 
	secondary sockets.

4.2.	Dependencies
--------------------

The packet replication layer is dependent on the following:
  
    a.  The existence of a handle <-> inpcb database.  Passing handles instead 
	of inpcb tuples will save us anywhere from 8 (IPv4) - 20 (IPv6) 
	bytes of extra bandwidth between the REs per incoming packet, for the 
	replicate and acknowledgement messages.  This is assuming an 8 byte 
	handle.
    b.  A few parts of the PRL will be run from a kernel thread.  The main 
        advantage here is that the PRL will have a context to send and listen 
	for data from the other PRL.
    c.  The PRL will have to do a pcblookup, and then pass the result onto the 
	L4 input routine, to avoid doing a pcblookup twice for each incoming 
	packet.  This will require minor changes in the supported L4 functions.
    d.  The use of a reliable, in-sequence transport facility to communicate 
	between the PRLs.
    e.  The kernel thread socket on either RE will only pass whole IPC messages 
	to/from the PRL.  Specifically, PRL will not have to deal with partial 
	IPC messages due to TCP segmentation on the transport pipe.

5.	Context chart
---------------------

The packet replication layer subsystem sits on both the primary and 
secondary REs.  Diagram 1 illustrates its location relative to the other 
subsystems in socket replication.

	|----------------|			|----------------|
	| Application    |			| Application    |
	|----------------|			|----------------|
		|	|				|	|
		|	|	user space		|	|
	----------------------------------------------------------
		|	|	kernel space		|	|
		|	|				|	|
		|	|---------|			|	|---------|
		|	| IFM     |			|	| IFM     |
		|	|---------|			|	|---------|
		|					| 
	|----------------|			|----------------|
	| SDRL           |			| SDRL           |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	| Layer 4        |			| Layer 4        |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	| **PRL**        | <==================>	| **PRL**        |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	| Layer 3        |			| Layer 3        |
	|----------------|			|----------------|
		|					|
		|					|

	Diagram 1: Context Chart for packet replication layer subsystem

The PRL receives input from the following areas:

    * On primary socket only: the L3 input function, for incoming traffic 
      from the external peer on the primary RE.
    * On both sockets: the kernel thread receive socket's incoming IPC message 
      handler function, for all other traffic.
    * On both sockets: the kernel thread's callback that PRL installs during 
      initialization, for functionality that should be periodically run.

The PRL outputs to the following areas:

    * On both sockets: the kernel thread's sending socket (which may be the 
      same as the receiving socket), for sending traffic to the other RE.
    * On both sockets: the L4 input functions, for pushing incoming data up 
      the stack.  

6.	High-level design
-------------------------

6.1.	Description
-------------------

The major tasks for the primary RE's PRL include (in this order):

    a.  handler for incoming traffic from L3 input function
    b.  send replicate message to secondary RE's PRL
    c.  enqueue of incoming packet into buffer, along with pointer to inpcb
    d.  receipt of ACK message from secondary RE's PRL
    e.  dequeue of packet from buffer and call to L4 input function

The major tasks for the secondary RE's PRL include (in this order):

    f.  receipt of replicate message from primary RE's PRL
    g.  inpcb lookup
    h.  check socket buffer for space
    i.  send ACK message to primary RE's PRL
    j.  call L4 input function

Therefore:

On the primary RE, the PRL consists of code to:

    * look up an inpcb given a packet
    * buffer unacked replicate messages, so we can pass them up after they 
      are acked
    * send replicate messages for incoming packets from the peer
    * receive ACKs/NACKs from the peer
    * buffer data until replication is fully setup on the socket

On the secondary RE, the PRL consists of code to:

    * receive replication messages from the primary RE
    * send ACKs/NACKs to the primary RE
    * check socket buffer space

In addition, the PRL has functionality related to initialization and failover, 
covered in section 6.3.  

The primary and secondary socket's PRL have different tasks.  However, there is
nothing keeping the same RE from performing both theoretically, though of
course in different contexts.

6.2.	Top-level modules
-------------------------

Given these tasks, the PRL subsystem can be broken down into the following 
top-level modules:

    Primary socket's PRL:
    a.  Primary PRL peer message handler
	Input:
	    * Incoming packet, complete with L3 and L4 headers
	Output:
	    * Success/failure indication, call to replicate message send 
	      function.
	Behavior:
	    Given an incoming packet, this module will look up the 
	    corresponding socket.  If the socket is enabled for replication, 
	    then send a replicate message to the secondary socket, and 
	    enqueue the packet.  Otherwise, return and let the caller call 
	    the L4 input function.

    b.  Primary PRL send replicate message handler
	Inputs:
	    * Payload from incoming packet, socket
	Outputs:
	    * Replication message to secondary socket
	Behavior:
	    This module is responsible for sending messages to the secondary 
	    socket.  The module will take the packet from the peer, put the 
	    handle corresponding to the socket into the packet, assign a 
	    sequence number to it, and send it to the secondary socket via 
	    KKCM.

	    The PRL can only operate on whole messages.  The kernel thread will 
	    take care of ensuring that only whole messages will be seen by 
	    the PRL.  A timeout mechanism for PRL messages will be needed in 
	    case the other side dies, however.

    c.  Primary PRL receive acknowledgement message handler
	Inputs:
	    * ACK message from secondary socket
        Outputs:
	    * Sequence number from ACK message, call to L4 input function
	Behavior:
	    This module is responsible for receiving acknowledgement messages 
	    from the secondary socket.  If the received message is an ACK with 
	    an EOK reason field, this module will take out the sequence number 
	    from it, and call the appropriate L4 function with the corresponding 
	    queued packet.

	    If the primary socket receives a NACK from the secondary, it will
	    check the reason field in the NACK:

		* If the reason is because of lack of buffer space on the
		  secondary, it will update its notion of the secondary socket's
		  buffer space.

		* If the reason is because of an invalid handle, then it will
		  raise a replication error, causing the error-handling
		  mechanism to eventually clean up this socket.

		* If the reason is because the socket is not currently active
		  for replication, then it will also raise a replication error,
		  causing the error-handling mechanism to eventually clean up
		  this socket.

	    In either case, the buffered packet corresponding to this NACK will
	    be dropped.

    d.  Primary PRL packet enqueue/dequeue
	Inputs:
	    * Packet to enqueue, pointer to PRL state, sequence number from 
	      replication message (for enqueue)
	    * PRL state, sequence number (for dequeue)
	Outputs:
	    * Success/failure indication (for enqueue)
	    * Pointer to queue entry (for dequeue)
	Behavior:
	    Each replicated socket will have associated PRL state, that will 
	    contain a queue of unACKed packets in order of reception.  Each 
	    queue entry will contain the sequence number of the packet, in 
	    addition to the actual packet.

	    This module is responsible for managing the PRL queue of 
	    unACKed packets.  It will enqueue packets that are sent to 
	    the secondary RE for replication, and dequeue them when 
	    the primary RE receives an ACK for the replicated packet from 
	    the secondary RE.  Keeping unACKed packets around is necessary 
	    because of the requirement that the primary and secondary REs 
	    see the same traffic; we need to wait for the ACK from the 
	    secondary RE before we can pass up the packet to L4, so the 
	    packet has to stay somewhere in the meantime.

	    This module will also be responsible for queuing packets that 
	    arrive after the socket has been selected for replication, but 
	    before replication is fully initialized.  These packets will 
	    then be released to undergo the replication process.

    e.  Primary PRL timeout handler
	Inputs:
	    * Call from kernel thread
        Outputs:
	    * Changes to replicated sockets
        Behavior:
	    This module is responsible for detecting communication failure
	    between the primary and secondary sockets.  It will run 
	    periodically when scheduled by the kernel thread.  When run, it 
	    detects whether or not PRL messages have been received recently 
	    for the secondary socket on the transport pipe between the REs.  
	    If not, the handler will dequeue any pending packets and push 
	    them to the L4 input routine, and post a replication error by 
	    calling a generic kernel replication error-handling routine 
	    indicating replication problems.

	    In order to distinguish between the case where the other side 
	    goes offline, and the case where there is just no replicated 
	    traffic for a while, the timeout handlers on both sides will only 
	    start if there are unACKed replication requests outstanding.

	    If the primary RE's PRL runs out of buffer space while waiting for 
	    currently-buffered data to be ACKed/NACKed, then it will drop any 
	    subsequent incoming packets from the peer.  This is consistent with 
	    the store-and-forward philosophy that Internet routing uses, and is 
	    simpler to implement.

    Secondary RE's PRL:
    f.  Secondary PRL receive replicate message handler
        Inputs:
            * Replication message from primary socket
        Outputs:
            * Success or failure indication, call to L4 input function
        Behavior:
            This module is responsible for receiving messages from the 
	    primary socket.  The module will check if the secondary socket's 
	    receive buffer has enough space to accept the packet.  If so, 
	    it will call the L4 input function for that socket and packet, 
	    and send an ACK with an EOK reason field back to the primary 
	    socket.  If not, then it will send an ACK with an appropriate 
	    reason field back to the primary socket.

    g.  Secondary PRL send acknowledgement message handler
	Inputs:
	    * Indication to send ACK message, with replication handle, 
	      sequence number, and reason
	Outputs:
	    * ACK message to primary socket
	Behavior:
	    This module is responsible for sending acknowledgement messages 
	    to the primary socket.  The module will take all the arguments, 
	    create an ACK message from that, and send it to the primary socket.

	    A NACK will be sent if any of the following occur:

		* The receive buffer on the secondary socket does not have 
		  enough space for the incoming packet.  In this case, the 
		  current buffer space is sent with the NACK.

		* The handle from the replication message is invalid.

		* The handle corresponds to a socket that is not currently 
		  active for replication.

	    In either case, the reason field in the NACK will be filled out 
	    appropriatetly.

	    The PRL can only operate on whole messages.  The kernel thread will
	    take care of ensuring that only whole messages will be seen by
	    the PRL.

Diagram 2 outlines how these modules interact.

	Primary RE				Secondary RE

  packet from	|				       /|\ packet to L4 
  peer		|					|  input handler
	       \|/					|
	|----------------|  replication msg	|----------------|
	| Send Repl.     |  ----------------->	| Recv. Repl.    |
	| Msg. Handler   |  			| Msg. Handler   |
	|----------------|			|----------------|
		|      					|
	packet	|     					|
	       \|/    					|
     	|----------------|				|
     	| Packet         |				|
     	| En-/de-queue   |				|
     	|----------------|				|
	packet	|					|
	       \|/				       \|/
	|----------------|  ACK msg		|----------------|
	| Recv. ACK      |  <-----------------	| Send ACK       |
	| Msg. Handler   | 			| Msg. Handler   |
	|----------------|			|----------------|
		|
	       \|/

	packet to L4 input handler

	|----------------|
	| Timeout        |
	| Handler        |
	|----------------|


	Diagram 2: TCP Replication Layer top-level module interaction

6.3.	Initialization and failover
-----------------------------------

The PRL is not heavily involved in initialization and failover.  It is 
event-driven, and only a couple bits of state affect its behavior.  These 
two bits are:

    * "replication setup in progress" flag - turned on during initialization
    * "replication active" flag - turned on after initialization is complete, 
      turned off when failover occurs

Both of these bits are found in the inpcb, and are controlled by the 
application.  Refer to [1] for details.

When a packet comes in from the peer for an inpcb on the primary socket, the 
PRL layer will check the flags and do the following:

    * If the "replication setup in progress" flag is on, and the "replication 
      active" flag is off, that means replication setup is in progress, but 
      not completed yet.  The PRL will then queue these packets, but not pass 
      them up or replicate them to the other socket.  These packets will be 
      marked as pending in the per-inpcb queue.  The inpcb will also be marked 
      as pending.

    * Otherwise, if the "replication active" flag is on, that means 
      replication setup is done, and replication is now active on the inpcb.  
      It will then replicate the incoming packet to the secondary socket.

    * When the socket goes from "replication setup in progress" to     
      "replication active", IFM will explicitly call a PRL routine
      for the socket asking it to replicate all buffered packets that
      were received from the peer.  PRL will provide an API function that 
      IFM can call.

The secondary socket is only concerned with the "replication active" flag.  
When a replication packet comes in from the primary socket, it checks the flag 
first.  If it is on, then replication may proceed.  Otherwise, the packet is 
discarded and a NACK sent to the primary with the reason being "socket not 
being currently replicated".

When the other RE does crash, we will see it as a replication failure.  The 
way this affects PRL is that the transport between the two PRLs will be 
broken.  Since the transport is just a TCP connection, when the other RE dies, 
our traffic will stall, and TCP will retransmit all the way until the RE 
comes back up, at which point the connection will die (and presumably the 
socket as well).  

In order to avoid having to wait until the other RE comes back up, we will 
need some sort of timeout mechanism for PRL messages to detect connection 
failure.  We only really need this for replication messages, as ACK messages 
do not need to be reliably replicated.  The timeout handler is on a 
per-socket basis.  When triggered, it will dequeue and push any packets to the 
L4 input function, disable replication on that socket, and post a replication 
error.

7.	Detailed design
-----------------------

7.1.	Messages
----------------

What needs to be replicated?  The following needs to be replicated:

    * sequence number
    * replication handle
    * incoming packet from peer, from the L3 header onwards

This is the common header format for all PRL messages:

    01234567 89012345 67890123 45678901
    |---------------------------------|
    | common IPC header               |
    |---------------------------------|
    | replication handle              |
    |---------------------------------|
    | sequence number                 |
    |---------------------------------|

    Common IPC Header	- (64 bits) - Common IPC header for all NSR messages.

    Replication Handle	- (32 bits) - Replication handle corresponding
				      to the inpcb that this message
				      came in on.

    Sequence Number     - (32 bits) - Sequence number of this message.
				      This is here so that the secondary can 
				      combine multiple ACKs into one ACK, i.e.:

					primary sends packets 1, 2
					secondary can just send one ACK for 2

For replicate messages, the rest of the packet is just the incoming packet 
from the peer, from the L3 header onwards.  For acknowledgement messages, 
an ACK reason field and secondary receive buffer space field are included 
instead:

    01234567 89012345 67890123 45678901
    |---------------------------------|
    | receive buffer space            |
    |---------------------------------|
    | reason| unused                  |
    |---------------------------------|

    Receive Buffer Space - (32 bits) - Buffer space available on secondary 
				       socket's receive buffer.

    ACK Reason		- (8 bits)  - Reason associated with this ACK.

    Unused		- (24 bits) - Not used, here for padding.

7.2.     Upcalls
---------------

XXX - we are not currently using this, instead using a kernel thread to 
handle message passing between the REs.  However, I will leave this 
section in in case we decide that the kernel thread approach does not 
provide enough scalability.

A majority of the PRL will be implemented using the upcall facility in
JUNOS/FreeBSD.

so_upcall will be called on any socket buffer that has SB_UPCALL set on it,
when processes waiting on a socket buffer are woken up due to data arriving
on the socket.  It gets called after the data has been added to the receive
buffer.  It gets invoked via sowakeup(), which is called from any of the L4
input routines right after data gets shoved onto the buffer.

There will be some inefficiency because of the extra data copy into the socket
buffer before the upcall is called.  We can hack around that, but perhaps we
should try to stay within the existing infrastructure for now, and optimize
later if necessary.

The benefit of an upcall is just that we don't need to context switch
into the kernel thread, saving us latency.


7.3.	Pseudocode
------------------

    Primary's RE PRL:
    a.  Primary PRL peer message handler

    * called from incoming packet's L3 input function, in interrupt context
    prl_peer_msg_handler(packet)
    {
	extract L3 protocol from packet
	extract source, destination addresses from packet
	extract L4 protocol from packet
	extract source, destination ports from packet
	figure out routing instance from incoming interface index (iif)
	lookup inpcb given above data
	if (inpcb needs replication) {
	    mark packet for replication
	    sequence_number = prl_primary_message_send(packet, inpcb)
	    call prl_packet_message_enqueue(packet, inpcb, sequence number)
	} else {
	    call pr_input[ip->p]
	}
    }

    b.  Primary PRL send replicate message handler

    * upcalled from peer incoming packet's message handler
    prl_send_repl_msg(packet, socket)
    {
	if (primary socket has enough receive socket buffer space) {
	    make copy of packet
	    translate socket into handle
	    assign sequence number to copy of packet
	    prepend extra space for PRL header onto copy of packet
	    fill out PRL header in copy of packet, including iif from packet
	    send to secondary RE's PRL
	    return sequence number
	} else {
	    drop packet
	    return
	}
    }

    c.  Primary PRL receive ACK message handler

    * called from secondary RE incoming packet's interrupt context
    * This function depends on the KKCM returning only complete messages 
      from the secondary RE.
    prl_primary_message_receive(packet)
    {
	translate handle from packet into socket
	if (message is ACK) {
	    if (first entry from PRL queue in inpcb's 
	        sequence number is same as ACK) {
		dequeue first entry from PRL queue and push it into L4 input
	    }
	} else {
	    switch (drop reason) {
	    case "socket buffer is full on secondary RE":
	        adjust our idea of what secondary's socket buffer is
		requeue packet to try again later
		break
	    case "handle is invalid":
	    case "socket not currently being replicated":
		post replication error and log this event
		dequeue and push all packets in PRL queue in inpcb into
		L4 input
		break
	    }
	}
	return
    }

    d.  Primary PRL packet enqueue/dequeue

    * upcalled from peer incoming packet's interrupt context
    prl_message_enqueue(packet, socket, sequence number)   
    {
        /* iif is already in packet's mbuf hdr */
	create header for queue entry (contains packet,
	sequence number, and backpointer to socket)
	enqueue packet onto inpcb's PRL queue
    }       

    * upcalled from secondary RE incoming packet's interrupt context
    prl_message_dequeue_by_sequence_number(sequence number)
    {
	find first packet less than or equal to sequence number
	dequeue packet
	return packet
    }

    * upcalled from primary RE incoming packet's interrupt context, 
	or called from per-socket PRL state cleanup function
    prl_message_dequeue_first(socket)
    {
        find first packet on queue
        dequeue packet
        return packet
    }

    * upcalled from primary RE incoming packet's interrupt context, 
	or called from per-socket PRL state cleanup function
    prl_message_free(queue entry)
    {
	deallocate memory for queue entry
    }

    e.  Primary PRL timeout handler

    * called from kernel thread timeout callback
    prl_primary_timeout_handler()
    {
	if (haven't received PRL packets from other RE 
	    in the last X second(s)) {
	    loop through all replicated inpcbs {
		dequeue all pending packets and call L4 input routine
		post replication error
	    }
	}
    }

    Secondary RE's PRL:

    f.  Secondary PRL receive replicate message handler

    * upcalled from secondary PRL's incoming packet's interrupt context
    prl_secondary_receive_repl_msg(packet)
    {
	if (packet does not complete a message from primary RE) {
	    return
	} else {
	    dequeue all packets from kernel thread's socket receive buffer
	    reassemble packets into message
	}
	grab handle from packet
	if (handle is invalid) {
	    post replication error and log this event
	    return
	}
	translate handle into inpcb
	if (message is replicate) {
	    grab sequence number from packet
	    if (prl_secondary_socket_buffer_check(packet) == OK) {
	        call prl_secondary_message_send(handle, sequence number, ACK)
	    } else {
		call prl_secondary_message_send(handle, sequence number, NACK)
	    }
	    call L4 input function
        } else {
	    log error if verbose
        }
        return
    }

    g.  Secondary PRL send ACK message handler

    * upcalled from secondary PRL receive replicate message handler
    prl_secondary_send_ack_msg(handle, sequence number, type)
    {
	create message with handle, sequence number, type
        send to primary RE's PRL
    }

8.	Other approaches
------------------------

Some other approaches that we considered:

    * We decided on per-inpcb queues for PRL traffic, instead of a single 
      queue that intermixed all of the incoming data.  The original idea 
      behind using a single queue is that ACKs/NACKs can only have the 
      sequence number in them, and always acknowledge the top of the queue, 
      due to the in-sequence, reliable nature of the TCP transport connection 
      between the PRLs.  Specifically, no handle -> inpcb translation would 
      be needed, as the queue entries will already contain a pointer to the 
      inpcb.  However, we determined that the per-inpcb queues will sacrifice 
      a little performance in the common case for potentially great gains 
      when doing any inpcb-specific operation, such as flushing the queue 
      (when replication fails or when replication initialization is done) or 
      going through the queue when retransmits are needed.

9.	Outstanding issues
--------------------------

Some currently outstanding issues:

    * What should the incoming ifl index be for mbufs that are replicated on 
      the secondary RE?
	+ May be able to infer this from the handle(?)

    * Will we be spending too long a time in the interrupt contexts for 
      incoming packets?  Since they're not preemptible.
	* We're currently trying out the kernel thread context in KKCM, and 
	  will switch to an interrupt thread context if necessary.

    * TCP out of order packets:
	TCP maintains a queue for out-of-order segments for each connection.  
	We can potentially encounter deadlock issues when handling these 
	packets, depending on how PRL handles drop decisions and receive 
	buffer space calculations.

	We think that _not_ considering the incoming packet as automatically 
	counting against the available receive buffer space, and counting 
	the current amount of packets in the out-of-order queue against the 
	available receive buffer space, will avoid the problems here.  But 
	more thinking and experimentation needs to be done.

10.	Future Optimizations
----------------------------

Some possible future optimizations:

    * Don't pass L3 header from primary to secondary RE in replicate message, 
      to save some bandwidth between the REs.  Currently, we only need to pass 
      the L3 header so that L4 input functions can recalculate the checksum.  
      We can probably infer the checksum from the inpcb info.

    * Don't do binary drop at PRL; update primary socket with secondary 
      socket's buffer size when the secondary app reads off of the buffer, and 
      make decision at the primary socket.  Saves having to replicate data to 
      secondary socket needlessly.  No need to send proactively (no timers); 
      just send back buffer size in ACK/NACK, since we'll always have a 
      pessimistic view.  Worst comes to worst, we do binary drop on secondary 
      just like now.

    * Change messages to be in a Type-Length-Value (TLV) format.  This avoids 
      having to use version numbers for messages, and allows for greater 
      compatibility between different versions of software on the primary and 
      secondary RE (different versions won't automatically result in failure 
      to communicate).

      Messages to/from the PRL layer are regular IPC formats and not TLV.
      Before they are sent out on the transport socket, they are converted from
      IPC to TLV and the reverse happens when they are received on the transport
      socket.

12.	Design Issues
---------------------

This section will discuss design issues not covered by the other sections.

12.1	Common Receive Buffer Space
-----------------------------------

The primary and secondary must share a common idea of their receive buffer 
space.  Reasons for this include:

    * Staying in sync with each other re: dropping packets from the peer or 
      queuing them onto the receive buffer for the application.

    * Presenting a unified idea of what the advertised window should be to 
      the peer, for TCP.

    * Figuring out what is in-window for received packets from the peer.

The formula for determining this common value is quite simply:

	MIN(primary socket's receive buffer space, 
	    secondary socket's receive buffer space)

The complications occur when determining when to update this value, and when 
to use it.

After some discussion, we determined that this value should represent the 
snapshot of the minimum of the two socket's receive buffer space at the time 
the packet from the peer is replicated.  This value needs to be the same on 
both sides (let's call it common_rcvbufspc), and should be kept by both sides 
in their PRL state blocks.

This value can be decreased when packets come in from the peer, and can be 
increased when applications read off of the receive buffers for the sockets.
These two types of events are not synchronous to each other, so we need two 
messaging mechanisms, one for each type of event.

a.  Packets from peer

When a packet comes in from the peer into the primary, we replicate it to the 
secondary, and wait for an ACK.  The replicate message sent to the secondary 
contains the primary's receive buffer space.  When the secondary receives the 
replicate message, it takes the primary's receive buffer space, compares it 
with its own receive buffer space, records the minimum of the two in its 
common_rcvbufspc, and sends that value back to the primary in the ACK.  When 
the primary receives the ACK, it updates its own common_rcvbufspc, and either 
pushes the packet up to L4 or drops it, depending on the response from the 
secondary.  Later on, the L4 input function will key off of common_rcvbufspc 
instead of sbspace(&so->so_rcv) when determining whether to append the data 
to the receive socket buffer, or drop it.

This works because packets are replicated in-order, one at a time, and the 
ACKs come back one at a time (they are not coalesced).  We are not in strict 
lockstep as far as replicate and ACK messages for each packet are concerned, 
but we are guaranteed that the replicate message for packet 1 will be 
processed before the replicate message for packet 2, and therefore the ACK for 
packet 1 will come back before the ACK for packet 2.  We are also guaranteed 
that the L4 input happens right after the packets are processed on each side, 
so that no other packets can be processed before the L4 input completes.  
This guarantees that common_rcvbufspc is the same for each packet during the 
course of its processing.

b.  Reads from application

When the secondary application reads off of its receive buffer, the receive 
buffer space increases.  We send a flow control message to the primary socket, 
with our receive buffer space.  The primary updates its common_rcvbufspc with 
the minimum of this value and its own receive buffer space.  When the primary 
needs to calculate the advertised window for TCP sends, it will use 
common_rcvbufspc instead of sbspace(&so->so_rcv) in the calculation.

We need to do this so that the advertised window for TCP can be increased.  
Otherwise we may be in a deadlock situation if the advertised window goes 
down to 0, as the primary will never figure out that the common receive buffer 
space has increased, and so will never send window updates to the peer.

We don't need to update the secondary's common_rcvbufspc in this case, 
because it is only used when receiving packets from the peer, and at that 
time it will be updated before use anyway.  Conversely, it is OK to update 
the primary's common_rcvbufspc like this for the same reason: it will be 
updated anyway before use when packets come in from the peer.

We think that these two mechanisms will ensure that both sockets adhere to a 
common idea of the receive buffer space that is available at any given time.

A.	References
------------------

[1]	Kernel Replication software specification
	sw-projects/os/nsr/kernel_replication.txt

[2]	Non-Stop Routing software specification
	sw-projects/os/nsr/software_spec.txt
