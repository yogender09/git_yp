$Id: kkcm_design.txt,v 1.11 2007/05/17 21:10:50 mguglani Exp $

		Kernel-to-Kernel Communication Module Design
		
		Copyright (C) 2005, Juniper Networks, Inc.

                Author: Shine Wang, May 2005

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.

Table of Contents
-----------------

1.	Introduction
2.	Definitions
3.	Goals
4.	Assumptions/Dependencies
	4.1.	Assumptions
	4.2.	Dependencies
5.	Context Dhart
6.	High-Level Design
	6.1.	Description
	6.2.	Initialization and failover
        6.2.1   Triggers for KKCM Shutdown 
7.	Detailed Design
	7.1.	KKCM Client Data Structure
	7.2.	KKCM Sub-Modules
8.	Alternative Approaches Considered
9.	Outstanding Issues
10.	Future Optimizations
A.	References

1.	Introduction
--------------------

This document will cover the design of the Kernel-to-Kernel Communication
Module (KKCM) for socket replication/Non-Stop Routing (NSR).  High-level 
and detailed design will be discussed.  Other approaches that we considered
will also be listed, with their advantages and the reason(s) that they were
ultimately rejected.

The Kernel-to-Kernel Communication Module (KKCM) is one of the kernel
components of socket replication (see [1]).  Its main job is to manage the
kernel-to-kernel communication channels between two RE peers which are
involved in socket replication.  KKCM provides APIs for sending and receiving
socket replication traffic to/from the other RE kernel.  These APIs will be
used by other subsystems of socket replication (e.g., IHA, PSRM, SDRL, PRL)
to communicate with their peer on the other RE. In release 8.5 KKCM has been
extended to support NSR on voyager cluster. With this support kernel
replication peers may be on two different chassis rather than two REs on the
same chassis.
 

2.	Definitions
-------------------

    * Kernel-to-Kernel Communication Module (KKCM) - The subsystem described 
	in this document.  It is responsible for managing the communication 
	channels for sending and receiving socket replication traffic between
        two RE kernels.

    * Primary RE - The RE that the active application is running on.  It can 
	theoretically be the same RE as the secondary RE.

    * Secondary RE - The RE that the inactive (snooping) application is 
	running on.  It can theoretically be the same RE as the primary RE.

    * Cluster Primary - Primary chassis in a cluster.

    * Cluster Secondary - Secondary chassis in a cluster.

    * Protocol Master - The RE/chassis that produces global routing state.

    * Protocol Backup - The RE/chassis that can produce global routing state
      after switchover.

    * Initialization, Handle Mgmt and Async Notification Module (IHA) - The
      subsystem that is involved in initial interaction between the protocol
      master and protocol backup kernels to help setup socket replication.

    * Socket Data Replication Layer subsystem (SDRL) - The subsystem 
	responsible for replicating socket data between the protocol master 
	and the protocol backup.

    * Protocol State Replication Module (PSRM) - The subsystem responsible for
        replicating L4 protocol state between the protocol master 
	and the protocol backup.

    * Packet Replication Layer subsystem (PRL) - The subsystem responsible for
        replicating incoming traffic to both the protocol master 
	and the protocol backup.

    * Graceful Routing Engine Switchover (GRES) - A JUNOS feature which
        facilitates a graceful switchover from the primary RE to the secondary
        RE with minimal impact on the forwarding traffic.

3.	Goals
-------------

The primary goals of the KKCM subsystem are:

    * To establish and manage socket connections between the protocol master
      and protocol backup.  These socket connections allow other socket
      replication subsystems to communicate with their peer running on the
      peer system. 

    * To provide APIs to other socket replication subsystems (e.g., IHA, SDRL,
      PSRM, PRL, etc.) for sending and receiving socket replication traffic
      to/from their peer running on the other socket replication system. 

    * In the event that the protocol master or protocol backup goes offline, or
      a manual switchover has taken place, the KKCM on the peer system will
      invoke a cleanup handler for each socket replication subsystem so that
      they can clean up their own state as appropriate.

    * To provide a periodic timer service to other socket replication
      subsystems for handling tasks that need to be run periodically (e.g.,
      stats).

Secondary goals include:

    * Performance
      Incoming and outgoing packets should not be delayed significantly by
      KKCM processing.  

    * Scalability
      The KKCM could take a greater amount of CPU.  When sending/receiving
      data to/from a KKCM communication socket, additional code paths involving
      KKCM will be executed.  However, the extra overhead should not be so
      significant as to affect general scalability of the RE kernel.

      Host traffic from the PFE should not significantly degrade in 
      performance (latency or effective bandwidth) when the number of 
      replicated sockets is increased.

    * Reliability
      JUNOS as a whole should not exhibit significantly more problems with 
      KKCM implemented than it currently does.

    * Modularity
      The KKCM should be a internally-cohesive module in the kernel, that is 
      as independent as possible from other areas of code while still 
      providing the required functionality.

Non-goals include:

    * Portability
      The KKCM will be deeply embedded into the JUNOS kernel, and will not be 
      easily portable to other platforms.

4.	Assumptions/Dependencies
--------------------------------

4.1.	Assumptions
-------------------

The following assumptions are made for the design of KKCM:

    a.  A failover (either synchronous due to the application, or asynchronous
        due to RE or other system failure) could occur at any time.

    b.  Either the protocol master or the protocol backup could failover (as 
        described above) at any time.

    c.  It is OK to lose some incoming packets during an asynchronous failover.
        However, it is not OK for the protocol master to receive a packet, and 
        for the protocol backup to not receive that packet, and vice versa.

    d.  The protocol master and backup do not need to be running the same 
        version of software.  However, both must be running releases that 
	support Non-Stop Routing, and specifically socket replication.

4.2.	Dependencies
--------------------

The KKCM layer is dependent on the following:
  
    a.  After the user configures NSR on a router, MGD will send a notification
        to the kernel via a sysctl.  On receipt of such a notification, the
        kernel will initialize and activate the KKCM module.  Likewise, when
        NSR is deconfigured by the user, the kernel will receive a notification
        and KKCM will be deactivated.

    b.  The use of a reliable, in-sequence transport facility to communicate 
	between the two KKCMs running on the protocol master or protocol
        backup.

    c.  GRES maintains mechanisms which allow the primary RE and backup RE to
        detect the situation when the other RE has gone offline, or when a
        manual mastership switch has taken place.  The same mechanisms will
        also be employeed by KKCM for detecting the disappearance/death of the
        other RE or a controlled mastership switchover. In a cluster setup the
        mechanism used to update the cluster membership will be used for
        detecting the disappearance/death of the cluster members.


5.	Context Chart
---------------------

KKCM manages the kernel-to-kernel communication channel which is used by the
other subsystems of socket replication to talk to their counterpart running
on the other RE/other chassis.  Diagram 1 illustrates the location of KKCM
relative to the other subsystems in socket replication.

	|----------------|			|----------------|
	| Application    |			| Application    |
	|----------------|			|----------------|
	     |   |		                        |   |
	     |   |	       user space               |   |
	----------------------------------------------------------
	     |   |	      kernel space              |   |
	     |   |			                |   |
	     |   |-----|    |-----|    |-----|    |-----|   |
	     |   | IHA |<==>| ... |<==>| ... |<==>| IHA |   |
	     |   |-----|    |     |    |     |    |-----|   |
	     |              |     |    |     |              | 
	|--------------|    |     |    |     |    |--------------|
	| SDRL         |<==>| ... |<==>| ... |<==>| SDRL         |
	|--------------|    |     |    |     |    |--------------|
		|           |     |    |     |		    |
		|           |     |    |     |		    |
        |--------------|    |     |    |     |    |--------------| 
        | PSRM         |<==>| ... |<==>| ... |<==>| PSRM         |
        |              |    |     |    |     |    |              | 
	|--------------|    |     |    |     |    |--------------|
	| Layer 4      |    | KKCM|    | KKCM|    | Layer 4      |
	|--------------|    |     |    |     |    |--------------|
		|           |     |    |     |    	    |
		|           |     |    |     |              |
	|--------------|    |     |    |     |    |--------------|
	| PRL          |<==>| ... |<==>| ... |<==>| PRL          |
	|--------------|    |     |    |     |    |--------------|
		|           |     |    |     |              |
		|           |-----|    |-----|              |
	|--------------|                          |--------------|
	| Layer 3      |                          | Layer 3      |
	|--------------|                          |--------------|
		|                                           |
		|                                           |

	Diagram 1: Context Chart for KKCM

The KKCM receives input from the following areas:
                
    * On protocol master and protocol backup: incoming packets are passed
      to KKCM by a L4 input routine (e.g., tcp_input()), which appends the 
      incoming packets to the receive buffer of a KKCM communication socket.

The KKCM outputs to the following areas:
        
    * On protocol master and protocol backup: the send buffer of the 
      communication sockets managed by KKCM, for sending data and control
      packets to the KKCM on the other system.

    * On both protocol master and protocol backup: the message handlers 
      registered by the clients of KKCM, for processing incoming packets sent 
      by their peer on the other RE/chassis.


6.	High-Level Design
-------------------------

6.1.	Description
-------------------

The major tasks of the KKCM include:

    a. Establish and manage two TCP socket connections with the KKCM running
       on the other RE/chassis.  One socket connection will be used to 
       send/receive socket replication traffic to/from the other RE/chassis on 
       behalf of IHA, SDRL and PSRM.  The other connection will be used to 
       communicate socket replication traffic between the two REs/chassis for 
       PRL.  In other words, one of the connections will be used for control 
       and data traffic pertinent to the "send" side of replicated sockets, 
       whereas the other connection will be used for traffic pertinent to the 
       "receive" side.

    b. Provide output service to other socket replication subsystems in
       sending control and data packets to their peer on the other RE/chassis.

    c. Receive incoming packets sent by the KKCM on the other RE/chassis and 
       dispatch the packets to proper message handlers owned by the other socket
       replication subsystems.

    d. When receiving incoming packets,  KKCM will wait for all packets which
       make up a whole message to arrive before passing that whole message
       to the proper message handler.  The message handler will not have to
       deal with partial messages due to TCP segmentation on the transport
       pipe.

    e. In the event that the protocol master or the protocol backup goes 
       offline, the KKCM running on the other RE/system will invoke a cleanup 
       handler for each client of the KKCM.  Similarly, when a manual protocol
       mastership switchover takes place or when NSR is deconfigured, the KKCMs
       on both REs/chassis will invoke a cleanup handler for each socket 
       replication subsystem.

    f. Maintain a periodic timer and invoke a periodic timeout handler for
       each subsystem of socket replication.  These timeout functions handle
       tasks which need to be run periodically.

    g. Support a tracing facility which can be used to trace the messages
       exchanged between the protocol master and the protocol backup in support
       of socket replication.


6.2.	Initialization and Shutdown
---------------------------------------

The KKCM is involved in initializing and shutting down the kernel's support for
socket replication.  When the NSR feature is configured by the user, MGD will
notify the kernel via a sysctl.  Upon receiving such a notification, the kernel
will call KKCM's initialization routine to activate KKCM.  KKCM in turn invokes
an initialization routine for each subsystem of socket replication.  Likewise,
when NSR is deconfigured by the user, the kernel will receive a notification
from MGD and KKCM will be deactivated.  Additionally, a cleanup handler will
be invoked by KKCM for each of its clients.

6.2.1   Triggers for KKCM Shutdown 
----------------------------------

The triggers for shutting down the KKCM and other subsystems of socket
replication include the following:

    a. NSR being deconfigured - 

       When the user deconfigures NSR, MGD will notify the kernel via a sysctl.
       This sysctl will be a trigger for the kernel to shut down the KKCM
       and call the cleanup handler for each client of the KKCM.

    a. Protocol master going offline - 

       If the protocol master has gone offline, the chassisd/jsrpd on the 
       protocol backup will detect this condition and initiate a mastership 
       switchover via a sysctl.  This sysctl will additionally serve as a 
       trigger for the kernel on the protocol backup to shut down the KKCM.

    b. Protocol backup going offline - 

       When the protocol backup goes offline, the pfeman peer module in the
       kernel will detect that the peer connection from the protocol backup 
       has gone down.  The pfeman module will then invoke a callback routine
       to inform the KKCM that the protocol backup has gone offline.  
       Consequently, the KKCM will be shutdown.

    c. Manual protocol mastership switchover -

       When the user initiates a manual mastership switchover from cli,
       the chassisd running on the primary RE will be notified and it will
       issue a sysctl to relinquish mastership.  As for the chassisd on the
       secondary RE, it will invoke a sysctl to acquire mastership.  These
       sysctl calls will also serve as the triggers for the primary RE kernel
       and secondary RE kernel to shut down their KKCM respectively.


7.	Detailed Design
-----------------------

7.1.	KKCM Client Data Structure
----------------------------------

The various subsystems of socket replication, including IHA, SDRL, PSRM and
PRL, are all clients of KKCM.  During the NSR initialization phase in the
kernel, each client of KKCM will register itself with KKCM via a
'jsr_kkcm_client_info_t' structure, which is defined as follows:


typedef enum {
        JSR_KKCM_CLIENT_UNKNOWN = 0,
        JSR_KKCM_CLIENT_IHA,
        JSR_KKCM_CLIENT_SDRL,
        JSR_KKCM_CLIENT_PSRM,
        JSR_KKCM_CLIENT_PRL,
        JSR_KKCM_CLIENT_MAX_TYPES
} jsr_kkcm_client_type_t;

typedef enum {
        JSR_CLEANUP_SWITCHOVER = 0,  /* cleanup after mastership switchover */
        JSR_CLEANUP_ORE_DOWN,        /* cleanup after ore is offline */
        JSR_CLEANUP_NSR_DECONFIG,    /* cleanup after NSR is deconfigured */
        JSR_CLEANUP_NSR_IO_ERR       /* cleanup after kkcm socket I/O error */
} jsr_cleanup_reason_t;

/*
 * Each client of KKCM has a corresponding jsr_kkcm_client_info_t structure
 * which contains pointers to various callback functions that will be invoked
 * by KKCM on its behalf.
 *
 * cliient_msg_handler - pointer to the function for processing incoming
 *                       messages, which returns 0 on success and errno
 *                       otherwise.
 * client_periodic - pointer to the periodic handler
 * client_cleanup - pointer to the cleanup handler
 * 
 */
struct jsr_kkcm_client_info_ {
	int (*client_msg_handler) __P((struct mbuf *m, jsr_ipc_type_t type,
                                       jsr_ipc_subtype_t subtyp,
                                       jsr_ipc_length_t length));
	void (*client_periodic) __P((void));
	void (*client_cleanup) __P((jsr_cleanup_reason_t reason));
} jsr_kkcm_client_info_t;


jsr_kkcm_client_info_t *jsr_kkcm_clients[JSR_KKCM_CLIENT_MAX_TYPES];

/*
 * jsr_kkcm_client_register()
 *    Register a client with KKCM.
 *
 *    Return 0 on success, 1 on failure.
 */
int
jsr_kkcm_client_register(jsr_kkcm_client_type_t type, 
                         jsr_kkcm_client_info_t *info)
{
	if (type >= JSR_KKCM_CLIENT_MAX_TYPES ||
            type >= JSR_KKCM_CLIENT_MAX_TYPES ||
            jsr_kkcm_clients[type]) {
		log(LOG_ERR,
                    "%s: invalid client type %d\n", __FUNCTION__, type);
		return 1;
	}
	jsr_kkcm_clients[type] = info;

	return 0;
}

/*
 * jsr_kkcm_client_unregister()
 *    Unregister a client with KKCM.
 */
void
jsr_kkcm_client_unregister(jsr_kkcm_client_type_t type)
{
	jsr_kkcm_clients[type] = NULL;
}


/*
 * jsr_kkcm_init() is invoked from the sysctl which enables NSR.  
 * It creates the KKCM thread which will in turn call an initialization
 * routine for each subsystem of socket replication.
 */
int
jsr_kkcm_init(void)
{
	int error;
	
	/*
	 * Creates the KKCM thread, which will in turn call the following:
         *     jsr_iha_init();
         *     jsr_sdrl_init();
         *     jsr_psrm_init();
         *     jsr_prl_init();
         */
	error = jsr_kkcm_thread_create();
	
	return error;
}


The following is an example of how a KKCM client (e.g., PRL) would register
with KKCM.

static void prl_periodic __P((void));
static void prl_cleanup __P((jsr_cleanup_reason_t reason));
static int prl_msg_handler __P((struct mbuf *m, jsr_ipc_type_t type,
                                jsr_ipc_subtype_t subtype,
                                jsr_ipc_length_t length));

static jsr_kkcm_client_info_t prl_info = {
	prl_msg_handler,
	prl_periodic,
	prl_cleanup
};

/*
 * jsr_prl_init() is called by jsr_init(), which is invoked from the
 * sysctl which enables NSR.  jsr_prl_init() performs initialization tasks
 * for the PRL, including registering PRL as a client of KKCM.
 */
void
jsr_prl_init()
{
	jsr_kkcm_client_register(JSR_KKCM_CLIENT_PRL, &prl_info);

	/* Perform other initialization tasks as appropriate */
}


/*
 * jsr_prl_cleanup() is called by the KKCM after either ths primary RE or
 * secondary RE has gone offline, or a manual switchover has taken place.
 */
void
jsr_prl_cleanup(jsr_cleanup_reason_t reason)
{
	/* Perform other cleanup tasks as appropriate */

	/* Then unregister this module with KKCM. */
	jsr_kkcm_client_unregister(JSR_KKCM_CLIENT_PRL);
}


7.2.	KKCM Sub-Modules
-------------------------

The KKCM subsystem can be broken down into the following sub-modules:

    a.  KKCM Initialization

        void
        jsr_kkcm_init(void)

	Input Parameters:
	    None
	Output Parameters:
	    None
        Return Value:
	    0 - success
            non-zero - errno

	Behavior:
            This module is invoked by the sysctl function which enables NSR.
            It creates a kernel thread for KKCM.

    b.  KKCM Kernel Thread

	void
        jsr_kkcm_thread(void)

	Input Parameter:
	    None
	Output Parameter:
	    None
        Return Value:
	    None

	Behavior:
            The KKCM kernel thread performs the following tasks:
               1. Sleep if NSR is not configured or the other RE/chassis is 
                  offline.

	       2. Establish two TCP socket connections with the KKCM running
                  on the other RE/chassis.  In establishing the connections,
                  RE0 will act as the server and RE1 will be the client. On
                  voyager cluster protocol master chassis will act as the server
                  and protocol backup chassis will act as a client. 

                  Note:

                  Due to the TNP ARP mechanism used in the RE-RE TCP/IP
                  implementation, an EHOSTUNREACH would be returned right away
                  by  soconnect() in the event that the other RE is offline.
                  In other words, we don't need to worry about the effect of
                  the exponential backoff time associated with the standard
                  TCP/IP connections here.  Such backoff time does not apply
                  to RE-RE TCP/IP connections. This is only applicable to RE-RE
                  TCP/IP. The behavior for cluster may or may not be same.

               3. Call the init routine for other JSR modules who will become
                  the clients of KKCM.

               4. If no input and output work to do, go to sleep.

               5. Process input and output pending in the KKCM sockets.

               6. After waking up from sleep, check whether KKCM has been
                  marked for cleanup.  If so, call the cleanup handler.


    c.  KKCM Output Service API Used By Its Clients

        int
        jsr_ipc_msg_send(struct mbuf *m, jsr_ipc_type_t type,
                         jsr_ipc_subtype_t subtyp, jsr_ipc_length_t length,
                         int wait_ok)

	Input Parameters:
            m -       pointer to an mbuf chain which contains a fully crafted
                      JSR IPC message (including the JSR IPC message header)
                      that is to be sent to the other RE.  The message is in
                      network byte order.
            type -    type of JSR IPC message that is to be sent to the other
                      RE/chassis.
            subtype - subtype of JSR IPC message that is to be sent to the
                      other RE/chassis.
            length -  length of JSR IPC message, including the JSR IPC header
            wait_ok - flag indicating whether it's ok to block
	Output Parameters:
            None
        Return Value:
            0 - success
            non-zero - error number indicating failure
            >0 - errno of other failures

            Note:  The mbuf will be freed as the result of this call,
                   regardless of whether the send actually succeeds or not.

	Behavior:
            This routine is called by the clients of KKCM to send a JSR IPC
            message to the other RE/chassis. Based on the message type, it 
            determines which of the two KKCM communication sockets will be used
            to send the message.  It then enqueues a JSR IPC message to the
            corresponding KKCM output queue for later processing by
            jsr_kkcm_output().

            A tracing facility is supported for tracing the output messages


    d.  KKCM Output Handler

        int
        jsr_kkcm_output (int so_type)

        Input Parameter:
            so_type - socket type
        Output Parameter:
            None
        Return Value:   
            0 - success
            non-zero - errno on failure  
     
        Behavior:
            Process output pending on the output queue and send it out via the
            KKCM socket.


    e.  KKCM Input Handler

        int
        jsr_kkcm_input(struct socket *so)

	Input Parameter:
            so - socket whose receive buffer contains the incoming JSR IPC
                 message
	Output Parameter:
	    None
        Return Value:
            0 - success
            1 - failure, KKCM should reset its socket connections

	Behavior:
            This routine is responsible for receiving incoming packets which
            were sent by the KKCM running on the other RE/chassis, and 
            forwarding them to the proper message handlers based on the message
            type.  These messages will be delivered as mbufs or mbuf chains and
            the data format used is the JSR IPC message format.

            When receiving incoming packets, this routine will wait for all
            packets which make up a whole message to arrive before passing
            that whole message to its client's message handler.  The message
            handler will not have to deal with partial messages due to TCP
            segmentation on the transport pipe.

            A tracing facility will be supported for tracing the incoming
            messages received.

    f.  KKCM Periodic Timeout Handler

        void
        jsr_kkcm_periodic_handler(void *arg __unused)

	Input Parameter:
	    arg - unused
        Output Parameter:
	    None
        Return Value:
            None

        Behavior:
            This handler invokes a separate timeout handler for each client
            of the KKCM.  It then reinstalls the periodic timer.

    g.  KKCM Cleanup

        void
        jsr_kkcm_cleanup(jsr_cleanup_reason_t reason)

	Input Parameter:
	    reason - reason for the cleanup
        Output Parameter:
	    None
        Return Value:
            None

        Behavior:
            This module shuts down KKCM by performing the following tasks:
               1. Stopping the periodic timer.
               2. Invoking a cleanup handler for each socket replication
                  subsystem which is a client of KKCM.
	       3. Closing KKCM's socket connections.


8.	Alternative Approaches Considered
-----------------------------------------

Some other approaches that we considered:

8.1. Processing incoming packets in the interrupt context instead of in the
     context of the KKCM thread.  The idea is to make use of the SB_UPCALL
     facility provided by the socket layer and have the L4 input routine (e.g.
     tcp_input()) invoke an upcall function to receive and forward the
     incoming KKCM packets directly from the interrupt context
     (tcp_input() => sowakeup() => upcall function).

     Pros: Avoid the overhead associated with context switches, which
           would occur if incoming packets are processed in the context of
           the KKCM thread.

     Cons: a. This alternative would lengthen the interrupt path in the kernel.
              Having long running paths in the kernel would cause scheduling
              delays for userland daemons (e.g., RPD scheduler slips).

           b. A preliminary examination of the soreceive() code found that
              it is not safe to be called in the interrupt path.  There is
              at least one case where soreceive() could end up blocking
              even if it is called with the MSG_DONTWAIT flag.  This looks
              like a bug which originated from FreeBSD.  It is not clear
              whether there are other bugs like this in the soreceive() path.

     Current Plan:  
           To reduce the stability risk which may impact our JSR bringup
           efforts, we plan to first implement the approach of processing
           incoming packets in the context of the KKCM thread, and take some
           measurements to understand the impact of the context switch
           overheads.  If it turns out that such overheads would have an
           unacceptable impact on the performance of socket replication, we
           will reconsider the approach of processing incoming packets in the
           interrupt context.

8.2. Sending outbound packets (i.e., calling sosend()) in the context of
     the KKCM client which generates the message, instead of in the
     context of the KKCM thread.  

     Pros: Avoid the overhead associated with context switches, which
           would occur if output packets are processed in the context of
           the KKCM thread.

     Cons: A KKCM client may call jsr_ipc_msg_send() from an interrupt
           context or a process context.  It is not clear whether the sosend()
           path can be safely executed from the interrupt context.  Even if
           it is safe to do so, calling sosend() with the no-wait flag
           may increase the possibility of getting an error return (e.g.,
           memory allocation failure or running out of space in the socket's
           send buffer).  This would result in socket replication errors.

     Current Plan:  
           To minimize the risks of our JSR bringup efforts, we plan to first
           implement the approach of processing output packets in the context
           of the KKCM thread, and make some measurements to understand the
           impact of the context switch overheads.  If it turns out that such
           overheads would slow down the performance of socket replication
           significantly, we will reconsider the approach of processing
           output packets in the message originator's own context.

8.3. Implementing a heartbeat mechanism in the KKCM for monitoring the health
     of the other RE -

     Pros: Decoupling KKCM/NSR support from GRES

     Cons: GRES is a prerequisite for NSR, and GRES already has mechanisms
           for detecting the situation when the other RE goes offline.
           It would be redundant for the KKCM to implement its own heartbeat
           mechanism for monitoring the health of the other RE.

     Current Plan:  
           The KKCM will employ existing mechanisms already supported
           by GRES for detecting whether the other RE has gone offline.
           For voyager cluster JSRPD will detect cluster primary/cluster
           secondary going offline or becoming unreachable.

8.4. Instead of using jsr_ipc message type to determine which KKCM socket
     should be used to send the message, provide an API that can be used
     to set the policy for load balancing among the KKCM sockets.

     Current Plan:
           The first implementation of KKCM uses a static mapping between
           jsr_ipc message types and the KKCM sockets.  When we get to the
           performance tuning phase of the JSR project, we will consider
           more flexible load-balancing policies for the KKCM sockets.


9.	Outstanding Issues
--------------------------

Some currently outstanding issues:

    * What should be the timeout interval used for the periodic handlers?


10.	Future Optimizations
----------------------------

TBD

A.	References
------------------

[1]	TCP/Socket Replication for Non Stop Routing (NSR)
	sw-projects/os/nsr/kernel/kernel_replication_spec.txt

[2]	Non-Stop Routing (NSR) Functional Specification
	sw-projects/os/nsr/software_spec.txt

[3]     Juniper Socket Replication Initialization, Handle Management and
        Async Notification Module (IHA)
        sw-projects/os/nsr/kernel/iha_design.txt

[4]     Packet Replication Layer Design
        sw-projects/os/nsr/kernel/prl_design.txt

[5]     Socket Data Replication Layer Design
        sw-projects/os/nsr/kernel/sdrl_design.txt

[6]     Protocol State Replication Module Design
        sw-projects/os/nsr/kernel/psrm_design.txt

[7]     Juniper Socket Replication IPC Message Formats
        sw-projects/os/nsr/kernel/jsr_ipc_msg.txt

[8]     Voyager High Availability --- Functional Specification
        sw-projects/usp/specs/funcspecs/ha.txt
=========================================

