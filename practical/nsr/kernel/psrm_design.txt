$Id: psrm_design.txt,v 1.3 2005/08/09 02:17:23 dsw Exp $

Protocol State Replication Module Design

Copyright (C) 2005, Juniper Networks, Inc.

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.

Table of Contents
-----------------

1.	Introduction
2.	Definitions
3.	Goals
4.	Assumptions/Dependencies
	4.1.	Assumptions
	4.2.	Dependencies
5.	Context chart
6.	High-level design
	6.1.	Description
	6.2.	Top-level modules
	6.3.	Initialization and failover
7.	Detailed design
	7.1.	Messages
	7.2.	Upcalls
	7.3.	Pseudocode
8.	Other approaches
9.	Outstanding issues
10.	Future optimizations
A.	References

1.	Introduction
--------------------

This document will cover the design of the protocol state replication module 
for socket replication/Non-Stop Routing.  High-level and detailed design will 
be discussed.  Other approaches that we considered will also be listed, with 
their advantages and the reason(s) that they were ultimately rejected.

The protocol state replication module is one part of socket replication (see 
[1]).  Its main job is to replicate protocol state between the primary and 
secondary REs consistently and without significant performance penalty.

2.	Definitions
-------------------

    * Protocol State Replication Module (PSRM) - The subsystem described 
	in this document.  It is responsible for replicating L4 protocol 
	state between the primary and secondary REs.

    * Master RE - The RE that the active application is running on.  It can 
	theoretically be the same RE as the backup RE.

    * Backup RE - The platform that the inactive (snooping) application is 
	running on.  It can theoretically be the same RE as the master RE.

    * Primary socket - The socket that the active application is running on.
	This will normally be running on the master RE.  The exception is
	during a failover, after the REs have switched mastership but before
	NSR has finished its own state changes.

    * Secondary socket - The socket that the inactive (snooping) application
	is running on.  This will normally be running on the backup RE.  The
	exception is during a failover, after the REs have switched mastership
	but before NSR has finished its own state changes.

    * Socket Data Replication Layer subsystem (SDRL) - The subsystem 
	responsible for replicating socket data between the primary
	and the secondary REs.

    * Initialization, Handle Management and Async Notification Module (IHA) - 
	The subsystem responsible for coordinating initialization and 
	failover activities amongst the various kernel replication components.

    * Kernel-Kernel Communication Module (KKCM) - The module responsible for 
	transport of NSR messages between the REs.

    * Synchronous failover - A failover that is synchronously conducted on a 
	per-socket basis.  The application prompts the kernel to start this.

    * Asynchronous failover - A failover that is asynchrously conducted.  This 
	will be as a result of a system-wide action, a per-socket timeout, or 
	some other asynchronous trigger.

3.	Goals
-------------

The primary goal of this subsystem is:

    * To replicate protocol state between the primary and secondary sockets 
      consistently and without significant performance penalty.  The 
      protocol state on both sockets should remain in synchronization with 
      each other throughout the replication process.

      Protocols supported include:

      * Layer 4: TCP, UDP, raw IP
      * Layer 3: IPv4, IPv6, ISO

Secondary goals include:

    * Performance
      Packets should not be delayed significantly by PSRM processing.  
      The difference should not be noticeable to the peer.

    * Scalability
      The PSRM should not consume a noticeably greater amount of CPU, memory, 
      and other resources.  The extra resourcing required for PSRM should not 
      be so significant as to affect general scalability of the RE.

      Host traffic to/from the PFE should not significantly degrade in 
      performance (latency or effective bandwidth) when the number of 
      replicated sockets is increased.

    * Reliability
      JUNOS as a whole should not exhibit significantly more problems with 
      PSRM implemented than it currently does.

    * Modularity
      The PSRM should be a internally-cohesive module in the kernel, that is 
      as independent as possible from other areas of code while still 
      providing the required functionality.

Non-goals include:

    * Portability
      The PSRM will be deeply embedded into the JUNOS kernel, and will not be 
      easily portable to other platforms.

4.	Assumptions/Dependencies
--------------------------------

4.1.	Assumptions
-------------------

The following assumptions are made for the design of the protocol state 
replication module:

    a.  A failover (either synchronous due to the application, or 
        asynchronous due to RE or other system failure) could occur at any time.
    b.  Either the primary or the secondary RE could failover (as described      
        above) at any time.
    c.  It is OK to lose some incoming packets during an asynchronous failover.  
	However, it is not OK for the primary RE to receive a packet, and for 
	the secondary RE to not receive that packet, and vice versa.
    d.  There should be no packet loss during a synchronous failover.
    e.  The primary and secondary REs do not need to be running the same 
        version of software.  However, both must be running releases that 
	support Non-Stop Routing, and specifically socket replication.
    f.  The send-side and receive-side protocol state are not dependent on 
	each other in any way (i.e. the tcpcb's rcv_nxt and snd_nxt fields do 
	not rely on each other in any way).  Kernel replication relies on this 
	assumption to simplify its design, since send-side and receive-side 
	protocol state processing are not coupled.  If this assumption is not 
	true, then the whole design could fall apart, depending on the state 
	involved.
    g.  The PSRM will not replicate bind() calls, connect() calls, or socket 
	option settings after replication is active.

4.2.	Dependencies
--------------------

The protocol state replication module is dependent on the following:
  
    a.  The PSRM will be dependent on the kernel-kernel communication module 
	(KKCM) to call some of its functions.
    b.  The use of a reliable, in-sequence transport facility to communicate
	between the PSRMs during initialization and failover.
    c.  The kernel thread socket will only pass whole messages to/from the
	PSRM.  Specifically, PSRM will not have to deal with partial messages
	due to TCP segmentation on the transport pipe.

5.	Context chart
---------------------

The protocol state replication module sits on both the primary and 
secondary REs.  Diagram 1 illustrates its location relative to the other 
subsystems in socket replication.

	|----------------|			|----------------|
	| Application    |			| Application    |
	|----------------|			|----------------|
		|	|				|	|
		|	|	user space		|	|
	----------------------------------------------------------
		|	|	kernel space		|	|
		|	|				|	|
		|	|---------|			|	|---------|
		|	| IHA     |			|	| IHA     |
		|	|---------|			|	|---------|
		|					| 
	|----------------|--------|	|-------|----------------|
	| SDRL           | *PSRM* | <=>	| *PSRM*| SDRL           |
	|----------------|--------|	|-------|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	| Layer 4        |			| Layer 4        |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	| PRL            |			| PRL            |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	| Layer 3        |			| Layer 3        |
	|----------------|			|----------------|
		|					|
		|					|

	Diagram 1: Context Chart for protocol state replication module

The PSRM receives input from the following areas:

    * The secondary RE's SDRL, for protocol state information replicated 
      from the primary RE.
    * The IHA, for information about initialization and failover state.

The PSRM outputs to the following areas:

    * The kernel thread's sending socket (which may be the same as the 
      receiving socket), for sending traffic to the other RE.
    * The secondary socket's tcpcb, to push state into it from the primary RE.
    * The primary socket's tcpcb, to accept window updates from the secondary.
    * The IHA, to let it know that it's job is done during initialization 
      and failover.

6.	High-level design
-------------------------

6.1.	Description
-------------------

The PSRM is primarily concerned with protocol state replication.  The 
state for the supported protocols are all encapsulated within the inpcb 
and tcpcb (for TCP) associated with the socket.  This makes life significantly 
easier for the PSRM in terms of ease of update and simplicity.

The PSRM on either the primary or secondary RE can be in one of three states:

    * Initialization
    * Bulk data flow
    * Failover

The starting state is the Initialization state.  The goal of the PSRM in this 
state is to get the initial protocol state replicated from the primary to the 
secondary RE.  PSRM will be called from the IHA after the inpcb (and tcpcb if 
TCP) are created, to initialize the secondary tcpcb with the replicated state.

After the Initialization state is complete, the PSRM switches over to the 
Bulk data flow state.  In this state, protocol state updates are replicated 
via the SDRL.  The SDRL will then call a handler in the PSRM with the update 
data, and the PSRM will take care of replicating the change into the right 
place.

The Failover state can only be transitioned into from the Bulk data flow 
state, when the IHA calls a PSRM handler to indicate that the socket is 
undergoing a change from being an inactive secondary socket to being an 
active primary socket.  In this state, the PSRM will initialize any fields 
in the protocol state that need to be initialized, such as TCP timers.

Most of the functionality for the PSRM occurs on the secondary RE, since that is 
where the replication target tcpcb is.

The major tasks for the primary RE's PSRM include (in this order):

    Initialization:

    a.  Deriving and applying parameters to be replicated from the primary 
	socket's tcpcb.
    b.  Replicate message creation.
    c.  Send replicate message to secondary RE's PSRM.
    d.  Receipt of ACK for replicate message from secondary RE's PSRM.

    Bulk data flow (TCP):

    e.  Applying window updates from the secondary RE's PSRM.

The major tasks for the secondary RE's PSRM include (in this order):

    Initialization:

    f.  Receipt of replicate message from primary RE's PSRM.
    g.  Inactive tcpcb initialization.
    h.  Write of parameters from replicate message into tcpcb.
    i.  Send ACK message back to primary RE's PSRM.

    Bulk data flow (TCP):

    j.  Deriving TCP parameters from socket data.
    k.  Applying TCP parameters to tcpcb.
    l.  Sending flow control messages to primary when application reads off
	of its receive snoop buffer.  SDRL will call a PSRM function to do this.

    Failover:

    m.  Make tcpcb active on replicated socket, when socket becomes 
	primary.  This is currently a no-op, as explained above.

Therefore:

On the primary RE, the PSRM consists of code to:

    * (Initialization) Send replicate messages for the tcpcb to the secondary 
	socket.
    * (Initialization) Receive ACKs/NACKs from the secondary socket.
    * (Bulk data flow) Receive and apply TCP window updates from the secondary 
	socket.

On the secondary RE, the PSRM consists of code to:

    * (Initialization) Receive replication messages from the primary socket.
    * (Initialization) Send ACKs/NACKs to the primary socket.
    * (Bulk data flow) Derive and apply TCP parameters to tcpcb.
    * (Bulk data flow) Propagate TCP window updates from secondary to
	primary, when secondary reads off of its receive snoop buffer.
    * (Failover) Make tcpcb active.

The primary and secondary RE's PSRM have different tasks.  However, there is
nothing keeping the same RE from performing both theoretically, though of
course in different contexts.

6.2.	Top-level modules
-------------------------

Given these tasks, the PSRM can be broken down into the following top-level 
modules:

    Primary RE's PSRM:

    (Initialization)
    a.  Primary PSRM send replicate message handler
	Inputs:
	    * socket state
	Outputs:
	    * Replication message to secondary socket
	Behavior:
            This module is responsible for creating and sending initial 
	    replication messages to the secondary socket.  The module will 
	    derive inpcb and possibly tcpcb parameters to be derived from 
	    the socket argument, create a replication message with these 
	    parameters, and send it to the secondary socket via KKCM.  This 
	    module is called when IHA determines that PSRM replication needs 
	    to happen.

            The PSRM can only operate on whole messages.  The kernel thread will
            take care of ensuring that only whole messages will be seen by
            the PSRM.  A timeout mechanism for PSRM messages will be needed in
            case the other side dies, however.

    (Initialization)
    b.  Primary PSRM receive acknowledgement message handler
	Inputs:
	    * ACK message from secondary socket
        Outputs:
            * Call to IHA function, to let it know that PSRM replication 
	      initialization is complete
        Behavior:
            This module is responsible for receiving acknowledgement messages
            from the secondary socket.  If the received message is an ACK with
            an EOK reason field, this module will call the appropriate IHA 
	    function to let it know that PSRM replication initialization is 
	    complete on this socket.  If the primary socket receives a NACK 
	    from the secondary, it will call the appropriate IHA function to 
	    let it know that PSRM replication initialization has failed on 
	    this socket.

    (Bulk data flow, TCP only)
    c.  Primary PSRM TCP window update handler
	Inputs:
	    * TCP window update message from secondary socket
	Outputs:
	    * Changes to primary socket
	Behavior:
	    Each primary socket keeps track of two receive buffer free 
	    space sizes, corresponding to the primary and secondary socket 
	    buffers.  Given a TCP window update message from the secondary 
	    socket, this handler will find the socket associated with the 
	    handle in the message, and adjust its record of the secondary 
	    receive buffer's space accordingly.  It then recalculates the 
	    TCP advertised window variable in the tcpcb associated with the 
	    socket.

    Secondary RE's PSRM:

    (Initialization)
    d.  Secondary PSRM receive replicate message handler
        Inputs:
            * Replication message from primary socket
        Outputs:
            * Success or failure indication, call to IHA function
        Behavior:
            For receiving messages from the primary socket, this module will
            take the replication message and update the secondary socket's 
	    inpcb and possibly tcpcb with the initialization values from the 
	    message.  If that is successful, this module will then call the 
	    secondary PSRM send acknowledgement message handler to send an 
	    ACK back to the primary socket.  If the update is unsuccessful, this
            module will call the secondary PSRM send acknowledgement message 
	    handler to send an NACK back to the primary socket.

    (Initialization)
    e.  Secondary PSRM send acknowledgement message handler
        Inputs:
            * Indication to send ACK message, with replication handle
              and reason
        Outputs:
            * ACK message to primary socket
        Behavior:
            This module is responsible for sending acknowledgement messages to 
	    the primary socket.  The module will take all the arguments, create 
	    an ACK message from that, and send it to the primary socket.
	    If the reason field is EOK, then the message is considered an ACK, 
	    otherwise it is considered a NACK.

            A NACK will be sent if the replication message from the primary 
	    that triggered the NACK was somehow not processed.  This could be 
	    due to an invalid handle, some internal inconsistency, etc.


    (Bulk data flow, TCP only)
    f.  Secondary PSRM TCP state derivation and application
	Inputs:
	    * replication socket data from primary socket, given via SDRL
	Outputs:
	    * changes to tcpcb
	Behavior:
	    Given data from the primary socket, this module will derive the 
	    associated send-side TCP parameters and apply them to the tcpcb 
	    associated with the secondary socket.

	    The tcpcb can be divided into the following general categories:

		* window management
		    * snd_una - updated from PRL
		    * snd_max - can be derived from snd_nxt
		    * snd_nxt - actively replicated
		    * snd_up - actively replicated
		    * snd_wl1 - updated from PRL
		    * snd_wl2 - updated from PRL
		    * rcv_nxt - updated from PRL
		    * rcv_adv - updated from PRL sometimes, can be derived in 
			output path
		    * rcv_wnd - updated from PRL
		    * rcv_up - updated from PRL
		    * snd_wnd - updated from PRL
		    * max_sndwnd - updated from PRL
				
		* timers
		    * tt_rexmt - set to default value upon failover
		    * tt_persist - set to default value upon failover
		    * tt_keep - set to default value upon failover
		    * tt_2msl - set to default value upon failover
		    * tt_delack - set to default value upon failover

		* RTT calculation and congestion control - can be set to 
		  default values upon failover
		    * snd_cwnd - set to default value upon failover
		    * snd_bwnd - set to default value upon failover
		    * snd_ssthresh - set to default value upon failover
		    * snd_bandwidth - set to default value upon failover
		    * snd_recover - set to default value upon failover
		    * snd_high - set to default value upon failover
		    * t_rcvtime - set to default value upon failover
		    * t_starttime - set to default value upon failover
		    * t_rtttime - set to default value upon failover
		    * t_rtseq - set to default value upon failover
		    * t_bw_rtttime - set to default value upon failover
		    * t_bw_rtseq - set to default value upon failover
		    * t_rxtcur - set to default value upon failover
		    * t_srtt - set to default value upon failover
		    * t_rttvar - set to default value upon failover
		    * t_rxtshift - set to default value upon failover
		    * t_rttmin - set to default value upon failover
		    * t_rttbest - set to default value upon failover
		    * t_rttupdated - set to default value upon failover
		    * ts_recent - set to default value upon failover
		    * ts_recent_age - set to current value of ticks upon 
			failover
		    * snd_cwnd_prev - set to default value upon failover
		    * snd_ssthresh_prev - set to default value upon failover
		    * snd_high_prev - set to default value upon failover
		    * t_badnxtwin - set to default value upon failover

		* reassembly queue
		    * t_segq - updated from PRL

		* initialization - replicated during Initialization state
		    * iss - replicated during Initialization state
		    * irs - replicated during Initialization state
		    * md5_key - replicated during Initialization state
		    * rtbl_iif - replicated during Initialization state
		    * record_iif - replicated during Initialization state
		    * t_maxopd - replicated during Initialization state
		    * t_maxsend - replicated during Initialization state
		    * t_mssoffer - replicated during Initialization state
		    * t_maxseg - replicated during Initialization state
		    * snd_scale - replicated during Initialization state
		    * rcv_scale - replicated during Initialization state
		    * request_r_scale - replicated during Initialization state
		    * requested_s_scale - replicated during Initialization 
			state
		    * cc_send - replicated during Initialization state
		    * cc_recv - replicated during Initialization state

		* counters
		    * t_dupacks - updated from PRL

		* miscellaneous
		    * t_inpcb - set up during Initialization phase
		    * t_state - always ESTABLISHED as far as we're 
				concerned.
		    * t_flags - set to default value upon failover
		    * t_force - set to zero upon failover
		    * t_softerror - set to zero upon failover
		    * t_oobflags - updated from PRL
		    * t_iobc - updated from PRL
		    * t_duration - unused

	    Of these variables, the only ones that may need to be replicated 
	    with each send are snd_nxt (demarcation between "sent and 
	    unacked" and "unsent" parts of the window) and snd_up (send 
	    urgent pointer) with each send.  Everything else, including 
	    snd_wnd (send window size) can be inferred from existing TCP 
	    state, or given a default value upon failover without completely
	    killing the connection.

    (Bulk data flow, TCP only)
    g.  Secondary PSRM TCP window update handler
        Inputs:
	    * Call from SDRL indicating that receive buffer space has 
	      increased.
        Outputs:
	    * Call to kernel thread to send TCP window update message to 
	      primary socket.
        Behavior:
	    When the secondary application reads off of its receive buffer, 
	    the free space on that buffer increases.  This information should 
	    be propagated to the primary socket so that its advertised TCP 
	    window can be accurate.  This handler will create and send the 
	    window update message to the primary socket when called from the 
	    SDRL.

    (Failover)
    h.  Secondary PSRM failover handler
	Input:
	    * Call from IHA with tcpcb/inpcb
	Output:
	    * Changes to tcpcb/inpcb
	Behavior:
	    Upon failover, this handler will be called from the IHA.  The 
	    handler execute any failover activities upon the tcpcb/inpcb, 
	    such as setting the timers to default values, etc.

Diagram 2 outlines how these modules interact during initialization.  The 
operation of the other stages are simple enough to not need diagrams.

        Primary RE                              Secondary RE

  call from     |                                      /|\ call to 
  IHA           |                                       |  IHA
               \|/                                      |
        |----------------|  replication msg     |----------------|
        | Send Repl.     |  ----------------->  | Recv. Repl.    |
        | Msg. Handler   |                      | Msg. Handler   |
        |----------------|                      |----------------|
                                                        |
                                                        |
                                                        |
                                                        |
                                                        |
                                                        |
                                                        |
                                                        |
                                                       \|/
        |----------------|  ACK msg             |----------------|
        | Recv. ACK      |  <-----------------  | Send ACK       |
        | Msg. Handler   |                      | Msg. Handler   |
        |----------------|                      |----------------|
                |
               \|/

        call to IHA
      
        |----------------|
        | Timeout        |
        | Handler        |
        |----------------|


	Diagram 2: Protocol State Replication Module top-level module 
		   interaction during Initialization stage

6.3.	Initialization and failover
-----------------------------------

The PSRM is heavily involved in initialization and failover.  Most of its 
functionality is related to initialization and failover, in fact. 

PSRM's job during initialization is to replicate initial tcpcb/inpcb state 
from the primary to the secondary RE.  It should be called from the IHA on the 
primary RE, and driven by the arrival of the PSRM replicate message on the 
secondary socket.

During bulk data flow, the secondary RE's PSRM will be called from the SDRL with 
appropriate parameters for tcpcb updates for TCP connections, and with 
socket option changes for all connections.  The primary RE's PSRM is not 
involved in this stage.

Very little actually changes during failover.  The secondary RE will just start 
using the tcpcb/inpcb for communication, but only a few pieces of state in 
the tcpcb/inpcb actually have to change for this to occur.  Timers need to 
be set to default values and initially scheduled.

7.	Detailed design
-----------------------

7.1.	Messages
----------------

What needs to be replicated during initialization?  The following needs to be 
replicated:

    * iss - initial send sequence number
    * irs - initial receive sequence number
    * md5_key - MD5 key
    * rtbl_iif - routing instance index
    * record_iif - should we record incoming iif
    * t_maxopd - maximum segment size plus options
    * t_maxsend - configured cap on the maximum segment size
    * t_mssoffer - offered maximum segment size from the peer's SYN
    * t_maxseg - maximum segment size
    * snd_scale - window scaling for send window
    * rcv_scale - window scaling for receive window
    * request_r_scale - pending window scaling for receive window
    * requested_s_scale - pending window scaling for send window
    * cc_send - send connection count
    * cc_recv - receive connection count

This is the common header format for all PSRM messages:

    01234567 89012345 67890123 45678901
    |---------------------------------|
    | common IPC header               |
    |---------------------------------|
    | replication handle              |
    |---------------------------------|

    Common IPC Header   - (64 bits) - Common IPC header for all NSR messages.

    Replication Handle  - (32 bits) - Replication handle corresponding
				      to the inpcb that this message
				      came in on.

Replicate messages will additionally contain selected inpcb and tcpcb fields 
to be replicated.  Acknowledgement messages will additionally contain an ACK 
reason field:
      
    01234567 89012345 67890123 45678901
    |---------------------------------|
    | receive buffer space            |
    |---------------------------------|
    | reason| unused                  |
    |---------------------------------|

    Receive Buffer Space - (32 bits) - Buffer space available on secondary
                                       socket's receive buffer.

    ACK Reason          - (8 bits)  - Reason associated with this ACK.

    Unused              - (24 bits) - Not used, here for padding.


7.2.     Upcalls
---------------

XXX - we are not currently using this, instead using a kernel thread to
handle message passing between the REs.  However, I will leave this
section in in case we decide that the kernel thread approach does not
provide enough scalability.

A majority of the PSRM will be implemented using the upcall facility in
JUNOS/FreeBSD.

so_upcall will be called on any socket buffer that has SB_UPCALL set on it,
when processes waiting on a socket buffer are woken up due to data arriving
on the socket.  It gets called after the data has been added to the receive
buffer.  It gets invoked via sowakeup(), which is called from any of the L4
input routines right after data gets shoved onto the buffer.

There will be some inefficiency because of the extra data copy into the socket
buffer before the upcall is called.  We can hack around that, but perhaps we
should try to stay within the existing infrastructure for now, and optimize
later if necessary.

The benefit of an upcall is just that we don't need to context switch
into the kernel thread, saving us latency.

In the kernel replication system, the upcall will first lead to a kernel 
thread handler which will look at the message type, and call the appropriate     
module's handler (PSRM in this case).

7.3.	Pseudocode
------------------

    Primary RE's PSRM:

    a.  Primary PSRM send replicate message handler

    * called from primary RE's IHA
    psrm_primary_send_replicate_message(socket)
    {
	get inpcb from socket
	get tcpcb from socket
	get mbuf for message
	fill out message with relevant initialization values
	send message to secondary socket via KKCM
    }

    b.  Primary PSRM receive acknowledgement message handler

    * called from primary RE's PSRM input message handler, registered with 
	KKCM
    psrm_primary_receive_acknowledgement_message(message)
    {
	look up inpcb from handle in packet
	if inpcb does not indicate that replication is in progress {
	    log error
	    return
	}
        if (packet is ACK) {
	    send PSRM success indication to IHA for this socket
	} else {
	    send PSRM failure indication to IHA for this socket
	}	
    }

    c.  Primary PSRM TCP window update handler

    * upcalled from secondary imcoming packet's interrupt context
    psrm_primary_flow_message_receive(packet)
    {
	look up inpcb from handle in packet
	if inpcb does not indicate that replication is in progress {
	    log error
	    return
	}
	find socket associated with inpcb
	update its notion of the secondary receive buffer's size
	find tcpcb associated with inpcb
	update its TCP window advertisement variable
    }

    Secondary RE's PSRM:

    d.  Secondary PSRM receive replicate message handler

    * upcalled from primary RE's PSRM's incoming packet's interrupt context
    psrm_secondary_message_receive(packet)
    {
        grab handle from packet and look up socket
        grab initialization parameters from packet
        call psrm_secondary_tcpcb_create(socket, init_params)
        if successful {
            call psrm_secondary_message_send(handle, ACK)
        } else {
            call psrm_secondary_message_send(handle, NACK)
    }

    e.  Secondary PSRM send acknowledgement message handler

    * called from secondary RE's PSRM's receive message handler
    psrm_secondary_message_send(handle, type)
    {
        allocate packet
        put handle and type into packet
        send packet to primary RE's PSRM
    }

    f.  Secondary PSRM TCP state derivation and application
     
    * called from secondary RE's PSRM's receive message handler
    psrm_secondary_tcp_state_update(handle, type) 
    {
	grab TCP variables to update from packet
	resolve handle into socket
	resolve socket into tcpcb
	update tcpcb with aforementioned values
    }

    g.  Secondary PSRM TCP window update handler

    * called from secondary RE's SDRL
    psrm_secondary_flow_message_send(socket)
    {
        look up handle from socket
        if inpcb does not indicate that replication is in progress {
            return
        }
	look up handle from socket
	create flow control message to send to primary RE's PSRM
	send message
    }

    h.  Secondary PSRM failover handler

    * called from secondary RE's IHA
    psrm_secondary_failover_handler(socket)
    {
	find tcpcb from socket
	initialize timers in tcpcb
    }

8.	Other approaches
------------------------

Some other approaches that we considered:


9.	Outstanding issues
--------------------------

Some currently outstanding issues:

    * Will we be spending too long a time in the interrupt contexts for 
      incoming packets?  Since they're not preemptible.
	* We will go with the kernel thread approach at first.  If this doesn't 
	  work out because of performance and scalability issues, we will 
	  try using an interrupt-based approach later on.

    * How do we determine when to send flow control messages?
	* use delayed ACK algorithm
	    * need to research and think about this more
	* have a timer per socket
	    - the timer may have to expire too fast to make this feasible
	* have a global timer and a handler that cycles through all of the 
	  sockets
	    - scalability issues

10.	Future Optimizations
----------------------------

Some possible future optimizations:

A.	References
------------------

[1]	Kernel Replication software specification
	sw-projects/os/nsr/kernel/kernel_replication_spec.txt

[2]	Non-Stop Routing software specification
	sw-projects/os/nsr/software_spec.txt

[3]	Packet Replication Layer design document
	sw-projects/os/nsr/kernel/prl_design.txt
