$Id: sdrl_design.txt,v 1.2 2005/06/13 18:16:53 ssandhir Exp $

                Socket Data Replication Layer Design

                Copyright (C) 2005, Juniper Networks, Inc.

                Author: Saurabh Sandhir, April 2005

NOTICE: This document contains proprietary and confidential
information of Juniper Networks, Inc. and must not be distributed
outside of the company without the permission of Juniper Networks
engineering.

Table of Contents
-----------------

1.	Introduction

2.	Definitions

3.	Functions of SDRL
        3.1 Performance and Scaling

4.	Assumptions/Dependencies
	4.1.	Assumptions
	4.2.	Dependencies

5.	Context chart

6.	High-level design
        6.1     Primary SDRL functionality
        6.2     Secondary SDRL functionality
	6.3     Initialization and failover

7.	Detailed design
        7.1     Socket Structure Extension and Socket States  
	7.2	Initialization
        7.3     Socket Data Replication 
        7.4     Failover and Teardown
        7.5     Flow Control Exchanges
        7.6     Timers

8.	Other approaches

9.	Outstanding issues

10.	Future optimizations

A.	References

1. Introduction 
---------------------- 
This document will cover the
detailed design of the Socket Data Replication Layer for socket
replication/Non-Stop Routing.

The Socket Data Replication Layer is a component of NSR (Non Stop Routing)
socket replication infrastructure (see [1]). It's main objective is to
replicate outgoing data and control information at socket level and thus
provide means to the secondary application to snoop on the data records
written (sent) by the primary application.

2. Definitions 
--------------------

    * Socket Data Replication Layer (SDRL) - The subsystem described in
this document. It is responsible for replicating outgoing data records and
control information from the primary to the secondary.

    * Primary - The RE that the active (primary) application is running
on.  It can theoretically be the same RE as the slave RE.

    * Secondary - The platform that the inactive (snooping/secondary)
application is running on.  It can theoretically be the same RE as the
master RE.

    * Protocol State Replication Module (PSRM) - The subsystem responsible
for mantaining the Layer 4 (TCP/UDP) state consistant between the primary
and the secondary.

    * Initialization and Failover State Machine (IHA)- Top level state machine
responsible for co-ordinating message exchange between primary and
secondary in order to setup NSR replication on a socket. It depends on the
API provided by SDRL to conduct socket related operations and state
modifications

    * KKCM - Kernel to Kernel Communication Module that provides an a way
for all NSR kernel modules to exchange data with the peer kernel on the
other RE. KKCM  maybe modelled as a thread or a interrupt context based 
sub-system.


3. Functions of SDRL
---------------------

Within the NSR kernel infrastructure, the SDRL is responsible for the
following tasks -

      * Initializing socket state and syncing pre-existing socket data
(send and receive buffers) at time of replication setup.

      * Providing API functions to Initialization and Failover state
machines for accessing and setting socket state at init time.

      * Buffering and Syncing data records written by a primary
application on a NSR enabled socket to the secondary kernel.

      * Providing a dual-socket interface to the secondary application in
order to snoop on the data sent/received by the primary application

      * Updating send side PSRM (mainly TCP) state on the secondary
kernel.

      * Providing TCP flow control for an NSR enabled TCP connection. The
flow control is based on socket buffer states on both primary and
secondary


3.1 Performance and Scaling
----------------------------

As compared with a plain vanilla socket write, write into a NSR socket by
the primary application involves the overhead of replicating the data to
the secondary before exposing it to Layer 4 transport for transmission.
However, the extent of this overhead is minimized by buffering the data
within the write call and doing the replication asynchronously after the
write call returns. It is expected that this buffer will make SDRL
replication transparent to the application and keep it's performance
impact minimal.

A second SDRL performance checkpoint is the initialization phase when
replication is being setup on the socket and replication handshake is in
progress. During this phase control (handle, socket options) info and
pre-existing data are exchanged between the primary and the secondary
SDRLs. While initialization is in progress, the socket is not writable and
any incoming data is bufferred at the PRL layer (see [2]). However, this
happens only at NSR setup point early in the lifecycle of a replicated
socket. Moreover, user applications would expect a delay after setting
replication "on" and before the socket can handle data.

Each NSR replicated socket on the primary has additional state to mantain.
However, the extra resourcing should not be significant as to affect
general scalability of the RE.

On the secondary RE, each NSR replicated socket corresponds to socket
pair, one socket provides send side data to the secondary application and
the other provides receive side data. This implies a doubling of socket
usage on the secondary.

This is not an immediate concern given that it is confined to NSR
replicated sockets and low utilization on the secondary. Future
Optimizations section details an approach of dealing with this and it can
be implemented if need arises in the future.


4.	Assumptions/Dependencies
--------------------------------

4.1.	Assumptions
-------------------

The following assumptions are made for the design of the socket data
replication layer:

    a. During replication establishment/initialization, the socket layer
doesnt receive any incoming data on the primary (or secondary) sockets.
All such data is buffered by the Packet Replication Layer (PRL) and
re-injected once replication has been established.
    
    b. On the receive side, Packet Replication Layer (PRL) accepts data on
primary as well as secondary only if there is enough buffer space on BOTH
primary and secondary sockets.

    c.  Either the primary or the secondary could fail at any time.

    d.  Socket options at the time of replication are sync'ed up between
the primary and the secondary. However once replication is established, it
is the responsibility of the application to set any socket options (as
needed) on the secondary replicated socket.

    e.  The primary and secondary do not need to be running the same
version of software.  However, both must be running releases that support
Non-Stop Routing, and specifically socket replication.
        
    f. PRSM (layer 4) loads its own state initial state via a message
exchange separate from SDRL handshake. However, real time changes to layer
4 send state (mainly TCP sequence updates) are provided by SDRL.


4.2.	Dependencies
--------------------

The Socket Data Replication Layer is dependent on the following:

   - The KKCM socket will only pass whole messages to/from the
     SRRL. SDRL will not have to deal with partial messages due to TCP 
     segmentation on the transport pipe

5.	Context chart
---------------------

The Socket Data Replication Layer subsystem sits on both the primary and 
secondary.  

Diagram 1 illustrates its location relative to the other subsystems in
socket replication.

	|----------------|			|----------------|
	| Application    |			| Application    |
	|----------------|			|----------------|
		|	|				|	|
		|	|	user space		|	|
	----------------------------------------------------------
		|	|	kernel space		|    |
		|	|                               |    |
		|	|--------------|                |    |--------------|
		|	| Init/Failover|		|    | Init/Failover|
		|	|--------------|		|    |--------------|
		|					| 
	|----------------|			|----------------|
	| SDRL           | <==================>	| SDRL           |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
        | PRSM           |                      | PRSM           |       
        |                |                      |                |
        ------------------                      ------------------
	| Layer 4        |			| Layer 4        |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	|   PRL          |              	|   PRL          |
	|----------------|			|----------------|
		|					|
		|					|
	|----------------|			|----------------|
	| Layer 3        |			| Layer 3        |
	|----------------|			|----------------|
		|					|
		|					|

	Diagram 1: Context Chart for SDRL subsystem


SDRL receives input from the following modules/functions/context:

        * At initialization time, initialization and failover module calls
SDRL functions (on both primary and secondary) to setup socket state,
obtain socket parameters, sync pre-existing socket data to the secondary.

        * Post-initialization, primary SDRL is invoked (to replicate data
records) everytime the applications makes a write call on a replicated
socket

        * Secondary SDRL gets invoked via a kernel thread handler (upcall)
when a data record is received from the primary.

        * Primary SDRL is invoked via a kernel thread handler (upcall)
when acknowledgement for a data record is a received from the secondary.

        * A timeout function (TBD: per socket or global) calls SDRL if a
record is not ACKed by the secondary.

        * The kernel thread's callback that SDRL installs during
initialization, for functionality that should be periodically run.


SDRL outputs to the following modules/functions -

        * SDRL on primary and secondary exchange messages by calling
kernel thread output API function

        * SDRL on secondary calls PRSM (layer 4) update routines to update
send side state (mainly TCP sequence numbers).

        * When buffer state changes on the secondary, secondary SDRL
provides flow control update to the primary SDRL so that TCP window can be
advertized accordingly.


6.	High-level design
-------------------------

6.1.	Description
-------------------

6.1.1 Primary SDRL functionality
----------------------------------

Primary SDRL has the following tasks -

During Replication Initialization:

a) Attach NSR socket extension to the socket during initialization

b) Setup initial socket replication state and associate a handle with the
socket

c) Provide socket parameters (for syncing with secondary SDRL) to
Initialization and Failover Module

d) Replicate pre-existing data records in send and rcv buffers to the
secondary.

e) Throttle any writes on the socket during initialization with an EAGAIN
error code.

Post Initialization:

i) Enforce record based writes on the replicated socket

ii-A) Buffer any written record in a nsr sockbuf and adjust
watermarks/socket space (TBD) on the socket to account for it.

ii-B) Create a record replicate message for the buffered record and send
the message (along with data) to the secondary.

ii-C) Control/Address information needs to be replicated alongside (for
UDP)

iii) Receive ACK for the replicated record from the secondary SDRL, adjust
watermark for the socket and reinject the corresponding record from nsr
sockbuf to Layer 4 pru_send() routine.

iv) Receive flow control message from the secondary SDRL and based on the
handle, update the socket buffer view for the particular replicated
socket. This view is used by TCP to advertize window size to the peer.


During Failover:

If the secondary fails, SDRL is notified via thread keepalive timeout.
SDRL has to turn off replication on all replicated sockets and clean up
replication socket state.


6.1.2 Secondary SDRL functionality 
----------------------------------

Secondary SDRL has the following tasks -

During Replication Initialization:

a) Create a "read-only" replicated socket pair, associate with the given
handle nad return two FDs (as a result of an API call from secondary
application channelled by Initization and Failover Module)

b) Setup replicated socket pair state based on the received socket
parameters from primary (via the Initialization and Failover Module)

c) Load data in the socket pair based on the pre-existing rcv and snd
buffer data received from the primary

Post Initialization:

i) Receive replicated (send side) data records from the primary and append
them to the appropriate socket buffers in the replicated socket pair.

ii) Handle control/address information from the primary (only for UDP)

iii) Acknowledge each replicated record to the primary

iv) Update PRSM (layer 4 - TCP/UDP) send side state. (per received record)

v) Send periodic flow control updates to the primary which reflect the
state of the socket on the secondary.

During Failover:

If the primary fails, secondary application causes a NSR/Replication
failover by calling an API function. At this point SDRL needs to coalsce
socket pair state into a single socket with socket buffers and other state
setup appropriately. The new single FD is returned back to the
application. SDRL also needs to call PRSM (layer 4) failover function to
activate layer 4 failover actions.

7.	Detailed design
-----------------------

NOTE: THE FUNCTIONS DEFINED BELOW ARE FOR DESIGN DESCRIPTION, THE EXACT
SEMANTICS AND SYNTAX OF THESE FUNCTIONS WILL BE PRESENT IN SDRL HEADER
FILE. THIS FUNCTION LIST IS ILLUSTRATIVE AND NOT FULLY COMPLETE.


7.1.	Socket Structure Extension and Socket States
-----------------------------------------------------

Socket replication requires additional replication specific information to
be attached to replicated sockets on primary as well as secondary. For
this purpose the generic socket structure will be modified to accomodate a
pointer to replication socket extension.

The pointer will be NULL except for replicated sockets where it will point
to an extension structure containing replication related info.


/*
 * Socket extension for replication (vis a vis Non Stop Routing)
 */
struct jsr_sock {
    jsr_handle_t    sr_handle;     /* Replication handle */
    short           sr_state;      /* State of Socket Replication */
    short           sr_init_state; /* Substate during init handshake */ 
    struct socket  *sr_parent;     /* Back pointer to parent socket */
    jsr_sock_t     *sr_pairsock;   /* Ptr to the other socket in the 
                                      pair (on secondary) */
    struct sockbuf  sr_repl;       /* Data to be replicated */
    struct proc    *sr_proc;       /* Backpointer to process */
    
    u_int32_t       sr_seq;        /* Last replicate msg sent or Recv'ed */

    u_int32_t       sr_ack;        /* Last Ack sent or recv'ed
#ifdef SDRL_DEBUG
    jsr_sock_stat_t sr_stat;       /* Record stats */
#endif 

    struct callout_handle sr_int_timer; /* timer for sdrl/socket functions */
    struct callout_handle sr_ext_timer; /* timer for other functions */

    LIST_ENTRY(jsr_sock) sr_list;	/* entry in replicated socket list */

    prl_info_t      *sr_prl;            /* PRL state */

};

struct socket {
	short	so_type;		/* generic type, see socket.h */
	short	so_options;		/* from socket call, see socket.h */
	short	so_linger;		/* time to linger while closing */
        .....
        ......

        struct sr_sock *so_nsr;    /* Extension for socket replication */
                        ^^^^^
                      <NEW FIELD FOR REPLICATION>
        ....
}
        

The replication related socket state will exist in the extension
structure. The following state bits are visualized for socket replication.
More than one state flag can be set at a time, similar to the general
purpose socket state bits.


/*
 * Socket Replication states: SR_XXXX
 */
#define SR_INIT_PRIMARY   0x0001  /* Initializing primary replication */
#define SR_INIT_SECONDARY 0x0002  /* Initializing secondary replication */
#define SR_REP_PRIMARY    0x0004  /* Replication established primary socket */
#define SR_REP_SECONDARY  0x0008  /* Replication established sec. socket */
#define SR_REP_FUNCTIONAL 0x0010  /* Replication active (no failures etc.) */

#define SR_SECONDARY_SND_SOCK 0x0020 /* Secondary Socket for snooping on 
                                        primary's send side data */
#define SR_SECONDARY_RCV_SOCK 0x0040 /* Secondary Socket for snooping on
                                        primary's receive side data */

#define SR_ACK_PENDING        0x0080 /* Ack is pending for replicate messages */

#define SR_DEBUG          0x8000     /* Debugging enabled */


/*
 * Initialization sub-states: SRI_XXXX
 */
/* Secondary specific init sub-states */
#define SRI_SETPARAMS      0x0001  /* Receiving socket/proto parameters 
                                      from primary for initialization */   
#define SRI_SETRCVDATA     0x0002  /* Receiving "INIT TIME" 
                                      rcv data from primary */    
#define SRI_SETSNDDATA     0x0004  /* Receiving "INIT TIME" 
                                      snd data from primary */

/* Primary specific init sub-states */
#define SRI_SENDPARAMS     0x0010 /* Socket/proto params sent from primary */
#define SRI_SENDRCVDATA    0x0020 /* Sending "INIT TIME" rcv buffer data */
#define SRI_SENDSNDDATA    0x0040 /* Sending "INIT TIME" snd buffer data */

/* Shared init sub-states */
#define SRI_INITINPROGRESS     0x0100  /* Init is happening ...*/
#define SRI_DONE               0x0200  /* Done with replication init */



7.2  Initialization
------------------------------

               
(A) Primary SDRL Initialization 

               jsr_get_handle()
 Primary App.  --------------- > Kernel via rtsock ---> IFM ---> SDRL

 SDRL Functions involved: jsr_sdrl_setup_primary()
                                
 Module Inputs: 
        * Handle        
        * Socket

 Module Outputs:
        * Success/Failure

 Behavior:
  Initialization is setup on the primary as a result of a
jsr_get_handle() call by the application. The call results in a invocation
of Init Module (IHA) in the kernel. The IHA allocates a new
handle and calls SDRL function to initiate socket replication. The SDRL
function allocate a socket extension, attach it to the given socket and
set the state as SR_INIT_PRIMARY and initialization state as
SRI_INITINPROGRESS.


(B) Secondary SDRL initialization

                  jsr_split()
 Secondary App.  --------------- > Kernel via rtsock ---> IFM ---> SDRL

 SDRL Functions involved: jsr_sdrl_setup_secondary()

 Module Inputs: 
        * Handle        

 Moudle Outputs:
        * Socket (File descriptor) pair
        * Success/Failure

 Behavior:
  Secondary application receives a handle out of band from the primary
application and makes a jsr_split() call to create a read-only socket pair
to snoop on primary's socket corresponding to the handle. The call leads
to IHA/rtsock which invokes SDRL to initiate replication on secondary
SDRL. The SDRL function creates 2 new sockets along with replication
socket extensions. They are linked by sr_pairsock field. The replication
state of the main socket is SR_INIT_SECONDARY and initialization state is
SRI_INITINPROGRESS.

(C) Initialization Handshake
        
        State Change
 IHA <-------------------------> SDRL
        Data/Param Exhchange


 SDRL Functions involved: jsr_sdrl_start_initialization()
                                
sr_sec_sentrequest()
                         jsr_sdrl_pri_getsockparams()
                         jsr_sdrl_sec_setsockparams() 
                         jsr_sdrl_pri_get_rcvdata()
                         jsr_sdrl_sec_set_rcvdata()
                         jsr_sdrl_pri_get_snddata()                         
                         jsr_sdrl_sec_set_snddata()  
                         jsr_sdrl_pri_repl_done()
                         jsr_sdrl_sec_repl_done()
                         jsr_sdrl_repl_functional()

 Module Inputs:
        * Handle/Socket
        * (Optionally) recv'ed data or socket parameters       

 Module Outputs:
        * Success/Failure
        * New State
        * (Optionally) data or socket parameters to be sent.


 Behaviour:
 Initialization handshake between the primary and the secondary is
co-orindated by IHA. IHA mantains the top level state machine for 
initialization handshake and calls SDRL function jsr_sdrl_start_initialization() to comence the SDRL init part. Once SDRL walks through it initialization state machine, it calls an IHA function to inform it of the success/failure of init process. Once IHA has a go ahead from all state modules, it finally calls jsr_sdrl_repl_functional() to trigger SDRL into making replication active on the socket.

The following 2 tables capture the behavior of this module.

 Secondary IFM Event           SDRL call                SDRL Action
 ------------------            ---------                -----------
 Application calls       jsr_sdrl_setup_secondary()    Allocate socket
 jsr_split()                                           pair and extn.  

 socket parameters           jsr_sdrl_sec_setsockparams()   Parameters set in socket 
 recv'ed from primary                                 pair and change state

 Pre-existing rcv buffer     jsr_sdrl_sec_set_rcvdata()     Data stored with socket
 data recv'ed from primary                            pair and change state  

 Pre-existing snd buffer     jsr_sdrl_sec_set_snddata()     Data stored with socket
 data recv'ed from primary                            pair and change state

 IHA done with init          jsr_sdrl_sec_repl_done()       change state
                             and jsr_sdrl_repl_functional()    
 
 Primary IFM Event           SDRL call                SDRL Action
 ------------------          ---------                -----------
 Application calls        jsr_sdrl_sdrl_setup_primary()    Allocate socket pair
 jsr_sdrl_get_handle()                                     and extn. 

 Application calls          jsr_sdrl_pri_getsockparams()   Return socket params
  jsr_replicate()                                          and change state

 Params ack'ed by            jsr_sdrl_pri_get_rcvdata()     Return socket rcv buffer
 secondary SDRL                                            data and change state

 RCV buffer data ack'ed      jsr_sdrl_pri_get_snddata()     Return socket snd buffer
 by secondary SDRL                                         data and change state  

 SND buffer data ack'ed      jsr_sdrl_pri_repl_done()       Change state    
 by secondary SDRL

 IHA done with init          jsr_sdrl_repl_functional()     Change state


7.3     Socket Data Replication 
--------------------------------

(A) Record Replication vis a vis Primary SDRL

                write call              if replicated
Primary App ----------------> sosend() ---------------> SDRL
                                        socket

SDRL Functions involved: jsr_sdrl_replicate()
                         jsr_sdrl_reinject()      
                         jsr_sdrl_appendrecord()
                         jsr_sdrl_send_replication_msg()
                         jsr_sdrl_appendrecord()
                         jsr_sdrl_getrecord()
                         jsr_sdrl_recv_replication_ack()
                         jsr_sdrl_send_replication_msg()
Module Inputs:
        * Handle/Socket
        * Data record written by application
        
Module Output:
        * Success/Failure
 
Behavior:
        SDRL intercepts any data (during sosend()) written by the primary
application on a replicated socket. It ensures that writes are
"record-based", that is writes are rejected if socket doesnt have enough
space to accomodate the entire data record. The intercepted record is
buffered in the new sockbuf in the replication extension socket structure.
The original socket's snd buffer space is adjusted to account for the
record.

The record is then massaged into a record replicate IPC message and sent
over to the secondary kernel using the KKCM output API. When the
secondary kernel acknowledges the record, it is moved off the replication
sockbuf and reinjected to the send path using appropriate calls to layer 4
pru_send() routines. In case of an error or a timeout on the ack from the
secondary, replication is assumed to have failed on the primary socket and
is turned off by clearing the SR_REP_FUNCTIONAL flag.

For UDP, destination address needs to be replicated to the secondary along
with each datagram (written record), this is also taken care as part of
the primary record replication module.

(B) Record Replication vis a vis Secondary SDRL
        
                Record Replicate
KKCM        --------------------> SDRL (jsr_sdrl_recv_replication_msg(), 
                 IPC                             jsr_sdrl_repl_ack())
                 


 SDRL Functions involved: jsr_sdrl_recv_replication_msg()
                          jsr_sdrl_repl_ack()
                          jsr_sdrl_send_ack_msg()

 Module Inputs:
        * Record Replicate IPC message from primary
        
 Module Output:
        * Success/Failure

 Behavior:
  When the KKCM on the secondary receives a record-replicate IPC message
from the primary, it calls the IPC type specific handler from SDRL. This
module looks up the corresponding socket pair from the given handle in the
IPC. It then extracts the record from the IPC and appends it to the rcv
buffer on the send-snoop socket of the socket pair and the snd buffer of
the read-snoop socket of the socket pair. The send-snoop socket is read by
the application, whereas the snd buffer of the read-snoop socket is used
to mantain unacked data for TCP retransmits. Thereafter SDRL calls PSRM
function to update the secondary TCP state wrt the sequence numbers.
Simultaneously, the module also sends an ack for the record back to the
primary.

7.4     Failover and Teardown
------------------------------

(A) Failure of Primary RE

                    mastership
 Sec. Application  -------------> jsr_merge() ----> IHA ----> SDRL
                    switch

 SDRL Functions involved: jsr_sdrl_merge_sock()

 Module Input:
        * socket/handle
        
 Module Output:
        * success/failure
        * merged functional socket

 Behavior: From a SDRL perspective, socket replication failover is driven
by the application via IHA. SDRL is agnostic to RE mastership.

Primary RE failure causes a Graceful RE Switchover (a pre-requisite for
socket replication). Consequently, the secondary RE takes over the
mastership and the secondary application is notified via init of this
change. At this point, the application makes a call (jsr_merge()) on each
replicated socket-pair.

This call is translated by IHA to an SDRL invocation. SDRL combines the
socket pair into a single socket. This new socket has the rcv buffer
contents of the receive snoop socket and the snd buffer corresponds to the
unack'ed data in send snoop socket. The extension data structures and
buffers are then released. SDRL also makes a call to layer 4 (TCP/UDP)
routine to activate layer 4 protocol state. At the end, SDRL module
returns the new active socket, which is passed to the application for
further use.


(B) Failure of Secondary RE
                
                Keepalive 
 Kernel Thread --------------> SDRL 
                timeout

 SDRL functions involved: sr_keepalive_timeout()
                         sr_repl_functional()      
 Behavior:
 Failure of secondary RE is detected by SDRL as a result of a KKCM
callback based on GRES state or a SDRL timeout for a response from
secondary. The SDRL timeout is covered under Replication Errors section
below. When KKCM on primary detects the failure of the other RE, it calls
a registered handler from SDRL. The SDRL handler proceeds to make
replication non-functional (~SR_REP_FUNCTIONAL) on all replicated sockets.
Any data in the replication sockbuf is reinjected by calling L4 pru_send()

(C) Graceful Teardown of Replication

 Application --------> jsr_unreplicate()  -----> SDRL
          
 OR 
      
 Unreplicate IPC msg from other RE ----> IHA ----> SDRL 

 SDRL functions involved: jsr_sdrl_teardown()
                          jsr_sdrl_unreplicate()
                                                         
 Module input:
        * Socket/handler

 Module output:
        * success/failure
        * unreplicate message to other RE

 Behaviour:
    SDRL graceful shutdown on a socket results in it's replication state
being torn down and all replication related data structures (socket
extensions, sockbuf) are released. On the primary, any data in replication
sockbuf awaiting replication to other RE is injected back by calling L4
pru_send(). In addition, a message is sent to the other RE informing it of
replication being turned off. The SDRL layer on the other RE gracefully
shuts down replication on the reception of this message

A close on the primary socket does not translate into the secondary doing a 
teardown, since the secondary needs to mantain state in case of a pending
failover

(D) Replication errors

 Any replication errors encountered by SDRL result in replication being
made non-functional on the socket in question. The application is
informed asynchronously of this change. It is the responsibility of the
application to explicitly turn off replication.

7.5 Flow Control Exchanges
--------------------------

(TBD)

7.6 Timers
----------

SDRL mantains a timer per primary socket to keep track of outstanding
replication messages that havnt been ACK'ed by secondary SDRL. If the ACK 
is not received within a timer window, replication is turned off on the 
socket in question

The timer strategy to keep track to multiple outstanding messages and 
their ACKs is as follows -

Variables per socket replication extension - sequence number sent, ack
number received, ACK_PENDING state.


When a message (replication record in this case) is sent -

1. "sequence number sent" is incremented

2. *If* the timer is not in progress it is started and state marked as
ACK_PENDING.

When an Ack is receieved -
1. "ack number recieved" is incremented
2. ACK_PENDING flag is cleared.

When the timer pops -

1. If ACK_PENDING flag is set, this implies no ack is received in this
window. Therefore we unreplicate and cleanup state on this socket

2. If ACK_PENDING flag is not set - if more acks are pending ("sequence
number sent" > "ack number recieved"), restart the timer and set state to
ACK_PENDING.

8.	Other approaches
-------------------------

* While doing data record replication from primary SDRL, it is possible to
not buffer the data record separately as part of the write system call
from the application. This requires SDRL to replicate the record by
sending an IPC to the secondary *and* waiting for an Ack before returning
to the application. However this introduces a delay in the write system
call on the replicated socket and causes implicit blocking of the
application waiting for an ack.

* Instead of using a separate replication sockbuf in replication socket
extension, keep track of replicated and unreplicated data records in the
snd sockbuf itself. and only expose the replicated data records to the
TCP/UDP layer. This approachh has the drawback of having to modify generic
socket and protocol code to take into account new state markers in socket
buffer.

9.	Outstanding issues
---------------------------

* Interaction with kernel thread ?

* Per socket timer mantainence ?

* Cumulative Acking of data records ?

10.	Future Optimizations
-----------------------------


* Socket Requirements on the Secondary: Currently 2 sockets are allocated
on the secondary RE to snoop on the activities of the primary replicated
socket. It is possible to optimize this and use a single socket on the
secondary to to track a socket on the primary. The send side data will be
stored on the snd buffer of the single socket and receive side data on the
rcv buffer. Changes will have to be made to enable the application to read
snd socket buffer.



A.	References
------------------

[1]	Kernel Replication software specification
	sw-projects/os/nsr/kernel_replication.txt

[2]     Packet Replication Layer (PRL) design specification
        sw-projects/os/nsr/prl_design.txt

[3]	Non-Stop Routing software specification
	sw-projects/os/nsr/software_spec.txt

