$Id: mpls-common-issues.txt,v 1.2 2005/12/15 19:34:23 arthi Exp $

		MPLS issues for NSR 
		===================

1.0 Introduction 
================

   For non-stop routing (NSR) functionality, the following common issues were
identified for protocols using MPLS.

2.0 Common issues  
=================

2.1 Label allocation 
--------------------

   The primary and secondary should not make independent label
allocation decisions. Instead, the same label used by the primary,
which is sent in a protocol message, should be used by the secondary as well. 

   There are two issues, discussed separately below.
   Issues:
- a) how to track the allocated labels. This is required to ensure that
once the switchover happens, the old_secondary (which is now primary)
does not attempt to allocate a label that is in use for forwarding and
was allocated by the old_primary.
- b) how to reconcile the fowarding state and the routing state with
regards to the labels used. This may be an issue if the kernel state
is different from the rpd state with regards to the label.

   Discussion:
- a) Assuming the label used by the primary is known on the secondary,
tracking the allocated label on the secondary can be done using the
existing tag_alloc_tag API. 
   The tag_alloc_tag API allows marking specific labels as
allocated (when called with a specific label rather than with a null
label). This mechanism is used by RSVP for graceful restart and can be
reused.
- b) Labels are snooped from protocol messages. Protocol messages are
replicated to the secondary. There are potential race conditions
between the allocation of the label, the installation of the route and
the update of the state in the kernel. 

*** Begin open issue *** 
How should labels be tracked? One option is to take the BGP approach
and install a phantom route. Another option is to define the order of
the operations on switchover which will ensure that there are no race
conditions regarding label allocation once the switchover happens.
*** End open issue ***

2.2 Self-id
------------

   Self-ids are used in MPLS for the purpose of statistics
collection. They are used not just by RSVP and LDP, but also by other
code (such as the VPN code). 

   There are two issues regarding self-ids, discussed separately below:

   Issues:
- a) the self-id must be synchronized between the primary and the
secondary for the following reasons: 
	  (i) because otherwise on the secondary the route in rpd and the route
	  that is synched by the kernel will be different.
	  (ii) because otherwise the stats will be compromised after doing the
	  switchover.
- b) the allocated self-ids must be tracked (so that the secondary does
not attempt to allocate a new self-id which is already in use).

   Discussion:
- a)  The self-id is currently allocated by the infrastructure code. This
information is not part of the protocol messages (it is for internal
use only). Therefore, the self-id must be attached as auxiliary data
in addition to the actual protocol messages. 
- b)  To keep track of the allocated self-ids, a similar scheme as for
the allocated labels could be used. This mechanism is not available
today, but is required for fixing pr 63414.

2.3 Policer state
-----------------
 
    Policers (automatic or configured) may be associated with
nexthops. The id assigned to the policer is stored in the tag
structure. The id must be preserved on primary and secondary because
otherwise there will a discrepancy between the rpd route and the
kernel route. 

    Policer IDs are stored in a file. Must make sure that the file is
replicated. 
   
*** Begin open issue ****
o It is not clear if the file storing policer ids is replicated. The ids
are assigned by dfwd. 
o It is not clear if dfwd assignes them such that
the same numbers are always generated, in which case there should be
no problem. 
o It is not clear how automatic policers are treated (the template id
only is sent in that case)
*** End open issue ***

2.4 Degugging support
----------------------

   A lot of the state can be verified by running the relevant protocol
show commands on the primary and the secondary. However, not all state
is externally visible in such show commands. 

   The following areas were identified as useful for debugging
purposes: 

- a way to display allocated labels (on both primary and secondary)
- a way to display messages in queue, and a way to inject faults in
this queue
- a way to display auxiliary info that is required for the replication.


NOTE:-

Curently when krt adds kernel routes, it is going to allocate labels.
When 63414 is fixed, this will also be true for seflIDs in nexthops.
This piece of code MUST be disabled when we are doing NSR on secondary,
since we rely on individual protocols to re-allocate selfIDs/Labels.
If this is not disabled, protocol attempts to re-allocate the same
selfID/Label will fail.  
